
// This file has been automatically generated using nplc.py. Do not edit it manually.
// Version: 1.76.2_0.0.0.0 generated on devsrv15.leaba.local at 2021-05-12 16:04:51


#include <algorithm>
#include "nplapi/npl_types.h"
#include "common/bit_vector.h"
using silicon_one::bit_vector;
using silicon_one::bit_vector64_t;
using silicon_one::bit_vector128_t;
using silicon_one::bit_vector192_t;
using silicon_one::bit_vector384_t;

std::string to_hex_string(uint64_t value)
{
    if (value != 0){
        return "0x" + bit_vector64_t(value).to_string();
    }
    return "0x0";
}

std::string to_short_string_internal(field_structure fs){
    if (fs.subfields.size() == 0)
    {
        return fs.flat_value;
    }
    std::string result = "= {";
        for (auto it = fs.subfields.begin(); it != fs.subfields.end(); it++)
        {
            if (it != fs.subfields.begin()){
                result += ", ";
            }
            result += (*it).first +"= " +  to_short_string((*it).second);
        }
        result += "}";
    return result;
}

std::string to_short_string(field_structure fs){
    if (fs.subfields.size() == 0)
    {
        return fs.flat_value;
    }
    std::string result = fs.field_type +"= {";
        for (auto it = fs.subfields.begin(); it != fs.subfields.end(); it++)
        {
            if (it != fs.subfields.begin()){
                result += ", ";
            }
            result += (*it).first +"= " +  to_short_string_internal((*it).second);
        }
        result += "}";
    return result;
}


std::string to_string(field_structure fs, size_t tabs){
    if (fs.subfields.size() == 0)
    {
        return fs.to_string();
    }
    std::string result = fs.field_type +"= {\n";
        std::string tabs_str;
        for (size_t i = 0; i <= tabs; i++){
            tabs_str += "\t";
        }
        result += tabs_str;
        for (auto it = fs.subfields.begin(); it != fs.subfields.end(); it++)
        {
            if (it != fs.subfields.begin()){
                result += ",\n";
                result += tabs_str;
            }
            result += (*it).first +"= " +  to_string((*it).second);
        }
        result += "}";
    return result;
}

std::string to_string(field_structure fs){
    return to_string(fs, 0);
}

bit_vector64_t npl_additional_mpls_labels_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 20, ene_three_labels_jump_offset);
    bv.set_bits(19, 16, ene_four_labels_jump_offset);
    bv.set_bits(15, 8, ene_five_labels_jump_offset);
    bv.set_bits(7, 4, ene_six_labels_jump_offset);
    bv.set_bits(3, 0, ene_seven_labels_jump_offset);
    return bv;
}


void npl_additional_mpls_labels_offset_t::unpack(bit_vector64_t bv) 
{
    ene_three_labels_jump_offset = (npl_ene_three_labels_jump_offset_e)bv.bits(23, 20).get_value();
    ene_four_labels_jump_offset = (npl_ene_four_labels_jump_offset_e)bv.bits(19, 16).get_value();
    ene_five_labels_jump_offset = (npl_ene_five_labels_jump_offset_e)bv.bits(15, 8).get_value();
    ene_six_labels_jump_offset = (npl_ene_six_labels_jump_offset_e)bv.bits(7, 4).get_value();
    ene_seven_labels_jump_offset = (npl_ene_seven_labels_jump_offset_e)bv.bits(3, 0).get_value();
}



field_structure npl_additional_mpls_labels_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_additional_mpls_labels_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ene_three_labels_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_three_labels_jump_offset", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ene_four_labels_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_four_labels_jump_offset", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ene_five_labels_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_five_labels_jump_offset", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ene_six_labels_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_six_labels_jump_offset", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ene_seven_labels_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_seven_labels_jump_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_additional_mpls_labels_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_additional_mpls_labels_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_all_reachable_vector_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 108);
    bv.set_bits(107, 107, reachable[107]);
    bv.set_bits(106, 106, reachable[106]);
    bv.set_bits(105, 105, reachable[105]);
    bv.set_bits(104, 104, reachable[104]);
    bv.set_bits(103, 103, reachable[103]);
    bv.set_bits(102, 102, reachable[102]);
    bv.set_bits(101, 101, reachable[101]);
    bv.set_bits(100, 100, reachable[100]);
    bv.set_bits(99, 99, reachable[99]);
    bv.set_bits(98, 98, reachable[98]);
    bv.set_bits(97, 97, reachable[97]);
    bv.set_bits(96, 96, reachable[96]);
    bv.set_bits(95, 95, reachable[95]);
    bv.set_bits(94, 94, reachable[94]);
    bv.set_bits(93, 93, reachable[93]);
    bv.set_bits(92, 92, reachable[92]);
    bv.set_bits(91, 91, reachable[91]);
    bv.set_bits(90, 90, reachable[90]);
    bv.set_bits(89, 89, reachable[89]);
    bv.set_bits(88, 88, reachable[88]);
    bv.set_bits(87, 87, reachable[87]);
    bv.set_bits(86, 86, reachable[86]);
    bv.set_bits(85, 85, reachable[85]);
    bv.set_bits(84, 84, reachable[84]);
    bv.set_bits(83, 83, reachable[83]);
    bv.set_bits(82, 82, reachable[82]);
    bv.set_bits(81, 81, reachable[81]);
    bv.set_bits(80, 80, reachable[80]);
    bv.set_bits(79, 79, reachable[79]);
    bv.set_bits(78, 78, reachable[78]);
    bv.set_bits(77, 77, reachable[77]);
    bv.set_bits(76, 76, reachable[76]);
    bv.set_bits(75, 75, reachable[75]);
    bv.set_bits(74, 74, reachable[74]);
    bv.set_bits(73, 73, reachable[73]);
    bv.set_bits(72, 72, reachable[72]);
    bv.set_bits(71, 71, reachable[71]);
    bv.set_bits(70, 70, reachable[70]);
    bv.set_bits(69, 69, reachable[69]);
    bv.set_bits(68, 68, reachable[68]);
    bv.set_bits(67, 67, reachable[67]);
    bv.set_bits(66, 66, reachable[66]);
    bv.set_bits(65, 65, reachable[65]);
    bv.set_bits(64, 64, reachable[64]);
    bv.set_bits(63, 63, reachable[63]);
    bv.set_bits(62, 62, reachable[62]);
    bv.set_bits(61, 61, reachable[61]);
    bv.set_bits(60, 60, reachable[60]);
    bv.set_bits(59, 59, reachable[59]);
    bv.set_bits(58, 58, reachable[58]);
    bv.set_bits(57, 57, reachable[57]);
    bv.set_bits(56, 56, reachable[56]);
    bv.set_bits(55, 55, reachable[55]);
    bv.set_bits(54, 54, reachable[54]);
    bv.set_bits(53, 53, reachable[53]);
    bv.set_bits(52, 52, reachable[52]);
    bv.set_bits(51, 51, reachable[51]);
    bv.set_bits(50, 50, reachable[50]);
    bv.set_bits(49, 49, reachable[49]);
    bv.set_bits(48, 48, reachable[48]);
    bv.set_bits(47, 47, reachable[47]);
    bv.set_bits(46, 46, reachable[46]);
    bv.set_bits(45, 45, reachable[45]);
    bv.set_bits(44, 44, reachable[44]);
    bv.set_bits(43, 43, reachable[43]);
    bv.set_bits(42, 42, reachable[42]);
    bv.set_bits(41, 41, reachable[41]);
    bv.set_bits(40, 40, reachable[40]);
    bv.set_bits(39, 39, reachable[39]);
    bv.set_bits(38, 38, reachable[38]);
    bv.set_bits(37, 37, reachable[37]);
    bv.set_bits(36, 36, reachable[36]);
    bv.set_bits(35, 35, reachable[35]);
    bv.set_bits(34, 34, reachable[34]);
    bv.set_bits(33, 33, reachable[33]);
    bv.set_bits(32, 32, reachable[32]);
    bv.set_bits(31, 31, reachable[31]);
    bv.set_bits(30, 30, reachable[30]);
    bv.set_bits(29, 29, reachable[29]);
    bv.set_bits(28, 28, reachable[28]);
    bv.set_bits(27, 27, reachable[27]);
    bv.set_bits(26, 26, reachable[26]);
    bv.set_bits(25, 25, reachable[25]);
    bv.set_bits(24, 24, reachable[24]);
    bv.set_bits(23, 23, reachable[23]);
    bv.set_bits(22, 22, reachable[22]);
    bv.set_bits(21, 21, reachable[21]);
    bv.set_bits(20, 20, reachable[20]);
    bv.set_bits(19, 19, reachable[19]);
    bv.set_bits(18, 18, reachable[18]);
    bv.set_bits(17, 17, reachable[17]);
    bv.set_bits(16, 16, reachable[16]);
    bv.set_bits(15, 15, reachable[15]);
    bv.set_bits(14, 14, reachable[14]);
    bv.set_bits(13, 13, reachable[13]);
    bv.set_bits(12, 12, reachable[12]);
    bv.set_bits(11, 11, reachable[11]);
    bv.set_bits(10, 10, reachable[10]);
    bv.set_bits(9, 9, reachable[9]);
    bv.set_bits(8, 8, reachable[8]);
    bv.set_bits(7, 7, reachable[7]);
    bv.set_bits(6, 6, reachable[6]);
    bv.set_bits(5, 5, reachable[5]);
    bv.set_bits(4, 4, reachable[4]);
    bv.set_bits(3, 3, reachable[3]);
    bv.set_bits(2, 2, reachable[2]);
    bv.set_bits(1, 1, reachable[1]);
    bv.set_bits(0, 0, reachable[0]);
    return bv;
}


void npl_all_reachable_vector_result_t::unpack(bit_vector128_t bv) 
{
    reachable[107] = (npl_all_devices_reachable_e)bv.bits(107, 107).get_value();
    reachable[106] = (npl_all_devices_reachable_e)bv.bits(106, 106).get_value();
    reachable[105] = (npl_all_devices_reachable_e)bv.bits(105, 105).get_value();
    reachable[104] = (npl_all_devices_reachable_e)bv.bits(104, 104).get_value();
    reachable[103] = (npl_all_devices_reachable_e)bv.bits(103, 103).get_value();
    reachable[102] = (npl_all_devices_reachable_e)bv.bits(102, 102).get_value();
    reachable[101] = (npl_all_devices_reachable_e)bv.bits(101, 101).get_value();
    reachable[100] = (npl_all_devices_reachable_e)bv.bits(100, 100).get_value();
    reachable[99] = (npl_all_devices_reachable_e)bv.bits(99, 99).get_value();
    reachable[98] = (npl_all_devices_reachable_e)bv.bits(98, 98).get_value();
    reachable[97] = (npl_all_devices_reachable_e)bv.bits(97, 97).get_value();
    reachable[96] = (npl_all_devices_reachable_e)bv.bits(96, 96).get_value();
    reachable[95] = (npl_all_devices_reachable_e)bv.bits(95, 95).get_value();
    reachable[94] = (npl_all_devices_reachable_e)bv.bits(94, 94).get_value();
    reachable[93] = (npl_all_devices_reachable_e)bv.bits(93, 93).get_value();
    reachable[92] = (npl_all_devices_reachable_e)bv.bits(92, 92).get_value();
    reachable[91] = (npl_all_devices_reachable_e)bv.bits(91, 91).get_value();
    reachable[90] = (npl_all_devices_reachable_e)bv.bits(90, 90).get_value();
    reachable[89] = (npl_all_devices_reachable_e)bv.bits(89, 89).get_value();
    reachable[88] = (npl_all_devices_reachable_e)bv.bits(88, 88).get_value();
    reachable[87] = (npl_all_devices_reachable_e)bv.bits(87, 87).get_value();
    reachable[86] = (npl_all_devices_reachable_e)bv.bits(86, 86).get_value();
    reachable[85] = (npl_all_devices_reachable_e)bv.bits(85, 85).get_value();
    reachable[84] = (npl_all_devices_reachable_e)bv.bits(84, 84).get_value();
    reachable[83] = (npl_all_devices_reachable_e)bv.bits(83, 83).get_value();
    reachable[82] = (npl_all_devices_reachable_e)bv.bits(82, 82).get_value();
    reachable[81] = (npl_all_devices_reachable_e)bv.bits(81, 81).get_value();
    reachable[80] = (npl_all_devices_reachable_e)bv.bits(80, 80).get_value();
    reachable[79] = (npl_all_devices_reachable_e)bv.bits(79, 79).get_value();
    reachable[78] = (npl_all_devices_reachable_e)bv.bits(78, 78).get_value();
    reachable[77] = (npl_all_devices_reachable_e)bv.bits(77, 77).get_value();
    reachable[76] = (npl_all_devices_reachable_e)bv.bits(76, 76).get_value();
    reachable[75] = (npl_all_devices_reachable_e)bv.bits(75, 75).get_value();
    reachable[74] = (npl_all_devices_reachable_e)bv.bits(74, 74).get_value();
    reachable[73] = (npl_all_devices_reachable_e)bv.bits(73, 73).get_value();
    reachable[72] = (npl_all_devices_reachable_e)bv.bits(72, 72).get_value();
    reachable[71] = (npl_all_devices_reachable_e)bv.bits(71, 71).get_value();
    reachable[70] = (npl_all_devices_reachable_e)bv.bits(70, 70).get_value();
    reachable[69] = (npl_all_devices_reachable_e)bv.bits(69, 69).get_value();
    reachable[68] = (npl_all_devices_reachable_e)bv.bits(68, 68).get_value();
    reachable[67] = (npl_all_devices_reachable_e)bv.bits(67, 67).get_value();
    reachable[66] = (npl_all_devices_reachable_e)bv.bits(66, 66).get_value();
    reachable[65] = (npl_all_devices_reachable_e)bv.bits(65, 65).get_value();
    reachable[64] = (npl_all_devices_reachable_e)bv.bits(64, 64).get_value();
    reachable[63] = (npl_all_devices_reachable_e)bv.bits(63, 63).get_value();
    reachable[62] = (npl_all_devices_reachable_e)bv.bits(62, 62).get_value();
    reachable[61] = (npl_all_devices_reachable_e)bv.bits(61, 61).get_value();
    reachable[60] = (npl_all_devices_reachable_e)bv.bits(60, 60).get_value();
    reachable[59] = (npl_all_devices_reachable_e)bv.bits(59, 59).get_value();
    reachable[58] = (npl_all_devices_reachable_e)bv.bits(58, 58).get_value();
    reachable[57] = (npl_all_devices_reachable_e)bv.bits(57, 57).get_value();
    reachable[56] = (npl_all_devices_reachable_e)bv.bits(56, 56).get_value();
    reachable[55] = (npl_all_devices_reachable_e)bv.bits(55, 55).get_value();
    reachable[54] = (npl_all_devices_reachable_e)bv.bits(54, 54).get_value();
    reachable[53] = (npl_all_devices_reachable_e)bv.bits(53, 53).get_value();
    reachable[52] = (npl_all_devices_reachable_e)bv.bits(52, 52).get_value();
    reachable[51] = (npl_all_devices_reachable_e)bv.bits(51, 51).get_value();
    reachable[50] = (npl_all_devices_reachable_e)bv.bits(50, 50).get_value();
    reachable[49] = (npl_all_devices_reachable_e)bv.bits(49, 49).get_value();
    reachable[48] = (npl_all_devices_reachable_e)bv.bits(48, 48).get_value();
    reachable[47] = (npl_all_devices_reachable_e)bv.bits(47, 47).get_value();
    reachable[46] = (npl_all_devices_reachable_e)bv.bits(46, 46).get_value();
    reachable[45] = (npl_all_devices_reachable_e)bv.bits(45, 45).get_value();
    reachable[44] = (npl_all_devices_reachable_e)bv.bits(44, 44).get_value();
    reachable[43] = (npl_all_devices_reachable_e)bv.bits(43, 43).get_value();
    reachable[42] = (npl_all_devices_reachable_e)bv.bits(42, 42).get_value();
    reachable[41] = (npl_all_devices_reachable_e)bv.bits(41, 41).get_value();
    reachable[40] = (npl_all_devices_reachable_e)bv.bits(40, 40).get_value();
    reachable[39] = (npl_all_devices_reachable_e)bv.bits(39, 39).get_value();
    reachable[38] = (npl_all_devices_reachable_e)bv.bits(38, 38).get_value();
    reachable[37] = (npl_all_devices_reachable_e)bv.bits(37, 37).get_value();
    reachable[36] = (npl_all_devices_reachable_e)bv.bits(36, 36).get_value();
    reachable[35] = (npl_all_devices_reachable_e)bv.bits(35, 35).get_value();
    reachable[34] = (npl_all_devices_reachable_e)bv.bits(34, 34).get_value();
    reachable[33] = (npl_all_devices_reachable_e)bv.bits(33, 33).get_value();
    reachable[32] = (npl_all_devices_reachable_e)bv.bits(32, 32).get_value();
    reachable[31] = (npl_all_devices_reachable_e)bv.bits(31, 31).get_value();
    reachable[30] = (npl_all_devices_reachable_e)bv.bits(30, 30).get_value();
    reachable[29] = (npl_all_devices_reachable_e)bv.bits(29, 29).get_value();
    reachable[28] = (npl_all_devices_reachable_e)bv.bits(28, 28).get_value();
    reachable[27] = (npl_all_devices_reachable_e)bv.bits(27, 27).get_value();
    reachable[26] = (npl_all_devices_reachable_e)bv.bits(26, 26).get_value();
    reachable[25] = (npl_all_devices_reachable_e)bv.bits(25, 25).get_value();
    reachable[24] = (npl_all_devices_reachable_e)bv.bits(24, 24).get_value();
    reachable[23] = (npl_all_devices_reachable_e)bv.bits(23, 23).get_value();
    reachable[22] = (npl_all_devices_reachable_e)bv.bits(22, 22).get_value();
    reachable[21] = (npl_all_devices_reachable_e)bv.bits(21, 21).get_value();
    reachable[20] = (npl_all_devices_reachable_e)bv.bits(20, 20).get_value();
    reachable[19] = (npl_all_devices_reachable_e)bv.bits(19, 19).get_value();
    reachable[18] = (npl_all_devices_reachable_e)bv.bits(18, 18).get_value();
    reachable[17] = (npl_all_devices_reachable_e)bv.bits(17, 17).get_value();
    reachable[16] = (npl_all_devices_reachable_e)bv.bits(16, 16).get_value();
    reachable[15] = (npl_all_devices_reachable_e)bv.bits(15, 15).get_value();
    reachable[14] = (npl_all_devices_reachable_e)bv.bits(14, 14).get_value();
    reachable[13] = (npl_all_devices_reachable_e)bv.bits(13, 13).get_value();
    reachable[12] = (npl_all_devices_reachable_e)bv.bits(12, 12).get_value();
    reachable[11] = (npl_all_devices_reachable_e)bv.bits(11, 11).get_value();
    reachable[10] = (npl_all_devices_reachable_e)bv.bits(10, 10).get_value();
    reachable[9] = (npl_all_devices_reachable_e)bv.bits(9, 9).get_value();
    reachable[8] = (npl_all_devices_reachable_e)bv.bits(8, 8).get_value();
    reachable[7] = (npl_all_devices_reachable_e)bv.bits(7, 7).get_value();
    reachable[6] = (npl_all_devices_reachable_e)bv.bits(6, 6).get_value();
    reachable[5] = (npl_all_devices_reachable_e)bv.bits(5, 5).get_value();
    reachable[4] = (npl_all_devices_reachable_e)bv.bits(4, 4).get_value();
    reachable[3] = (npl_all_devices_reachable_e)bv.bits(3, 3).get_value();
    reachable[2] = (npl_all_devices_reachable_e)bv.bits(2, 2).get_value();
    reachable[1] = (npl_all_devices_reachable_e)bv.bits(1, 1).get_value();
    reachable[0] = (npl_all_devices_reachable_e)bv.bits(0, 0).get_value();
}



field_structure npl_all_reachable_vector_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_all_reachable_vector_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(reachable[107]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[107]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[106]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[106]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[105]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[105]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[104]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[104]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[103]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[103]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[102]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[102]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[101]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[101]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[100]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[100]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[99]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[99]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[98]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[98]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[97]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[97]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[96]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[96]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[95]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[95]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[94]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[94]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[93]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[93]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[92]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[92]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[91]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[91]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[90]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[90]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[89]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[89]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[88]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[88]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[87]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[87]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[86]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[86]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[85]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[85]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[84]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[84]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[83]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[83]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[82]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[82]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[81]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[81]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[80]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[80]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[79]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[79]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[78]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[78]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[77]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[77]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[76]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[76]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[75]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[75]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[74]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[74]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[73]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[73]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[72]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[72]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[71]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[71]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[70]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[70]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[69]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[69]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[68]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[68]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[67]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[67]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[66]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[66]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[65]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[65]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[64]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[64]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[63]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[63]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[62]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[62]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[61]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[61]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[60]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[60]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[59]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[59]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[58]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[58]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[57]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[57]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[56]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[56]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[55]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[55]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[54]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[54]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[53]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[53]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[52]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[52]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[51]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[51]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[50]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[50]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[49]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[49]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[48]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[48]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[47]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[47]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[46]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[46]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[45]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[45]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[44]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[44]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[43]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[43]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[42]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[42]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[41]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[41]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[40]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[40]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[39]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[39]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[38]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[38]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[37]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[37]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[36]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[36]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[35]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[35]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[34]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[34]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[33]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[33]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[32]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[32]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[31]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[31]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[30]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[30]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[29]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[29]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[28]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[28]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[27]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[27]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[26]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[26]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[25]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[25]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[24]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[24]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[23]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[23]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[22]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[22]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[21]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[21]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[20]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[20]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[19]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[19]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[18]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[18]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[17]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[17]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[16]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[16]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[15]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[15]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[14]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[14]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[13]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[13]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[12]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[12]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[11]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[11]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[10]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[10]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[9]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[9]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[8]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[8]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[7]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[7]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[6]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[6]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[5]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[5]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[4]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[4]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[3]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[3]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[2]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[2]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[1]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[1]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(reachable[0]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reachable[0]", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_all_reachable_vector_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_all_reachable_vector_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_app_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, sgacl_drop);
    bv.set_bits(1, 1, sgacl_log);
    bv.set_bits(0, 0, ip_inactivity);
    return bv;
}


void npl_app_traps_t::unpack(bit_vector64_t bv) 
{
    sgacl_drop = bv.bits(2, 2).get_value();
    sgacl_log = bv.bits(1, 1).get_value();
    ip_inactivity = bv.bits(0, 0).get_value();
}



field_structure npl_app_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sgacl_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sgacl_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sgacl_log);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sgacl_log", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_inactivity);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_inactivity", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_app_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_aux_table_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, rd_address);
    return bv;
}


void npl_aux_table_key_t::unpack(bit_vector64_t bv) 
{
    rd_address = bv.bits(11, 0).get_value();
}



field_structure npl_aux_table_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_aux_table_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rd_address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rd_address", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_aux_table_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_aux_table_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_aux_table_result_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 152, packet_header_type);
    bv.set_bits(151, 144, count_phase);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 144 - 1;
        size_t msb = 0;
        const uint64_t * p = aux_data;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_aux_table_result_t::unpack(bit_vector192_t bv) 
{
    packet_header_type = bv.bits(159, 152).get_value();
    count_phase = bv.bits(151, 144).get_value();
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 144 - 1;
        size_t msb = 0;
        uint64_t * p = aux_data;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_aux_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_aux_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(packet_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("packet_header_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(count_phase);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("count_phase", fs_subfield);
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 16;
        size_t max_msb = lsb + 144 - 1;
        size_t msb = 0;
        const uint64_t * p = aux_data;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_aux_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_aux_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_base_voq_nr_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, val);
    return bv;
}


void npl_base_voq_nr_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(15, 0).get_value();
}



field_structure npl_base_voq_nr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_base_voq_nr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_base_voq_nr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_base_voq_nr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bd_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 7, sgacl_enforcement);
    bv.set_bits(6, 1, l2_lpts_attributes);
    bv.set_bits(0, 0, flush_all_macs);
    return bv;
}


void npl_bd_attributes_t::unpack(bit_vector64_t bv) 
{
    sgacl_enforcement = bv.bits(7, 7).get_value();
    l2_lpts_attributes = bv.bits(6, 1).get_value();
    flush_all_macs = bv.bits(0, 0).get_value();
}



field_structure npl_bd_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bd_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sgacl_enforcement);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sgacl_enforcement", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_lpts_attributes);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_lpts_attributes", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(flush_all_macs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("flush_all_macs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bd_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bd_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_aux_ipv4_trans_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 0, sip);
    return bv;
}


void npl_bfd_aux_ipv4_trans_payload_t::unpack(bit_vector64_t bv) 
{
    sip = bv.bits(31, 0).get_value();
}



field_structure npl_bfd_aux_ipv4_trans_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_ipv4_trans_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sip", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_aux_ipv4_trans_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_ipv4_trans_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_aux_ipv6_trans_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 0, ipv6_dip_b);
    return bv;
}


void npl_bfd_aux_ipv6_trans_payload_t::unpack(bit_vector64_t bv) 
{
    ipv6_dip_b = bv.bits(31, 0).get_value();
}



field_structure npl_bfd_aux_ipv6_trans_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_ipv6_trans_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ipv6_dip_b);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_dip_b", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_aux_ipv6_trans_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_ipv6_trans_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_aux_transmit_payload_t_anonymous_union_prot_trans_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    { // union compound field start
        bit_vector64_t tbv = ipv4.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv6.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_bfd_aux_transmit_payload_t_anonymous_union_prot_trans_t::unpack(bit_vector64_t bv) // union
{
    ipv4.unpack(bv.bits(31, 0));
}



field_structure npl_bfd_aux_transmit_payload_t_anonymous_union_prot_trans_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_transmit_payload_t_anonymous_union_prot_trans_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ipv4.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv4", ipv4.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv6.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv6", ipv6.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_bfd_aux_transmit_payload_t_anonymous_union_prot_trans_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_transmit_payload_t_anonymous_union_prot_trans_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_em_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    // PADDING -  bv.set_bits(39, 29, padding);
    bv.set_bits(28, 16, rmep_id);
    bv.set_bits(15, 3, mep_id);
    bv.set_bits(2, 2, access_rmep);
    bv.set_bits(1, 1, mp_data_select);
    bv.set_bits(0, 0, access_mp);
    return bv;
}


void npl_bfd_em_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(39, 29).get_value();
    rmep_id = bv.bits(28, 16).get_value();
    mep_id = bv.bits(15, 3).get_value();
    access_rmep = bv.bits(2, 2).get_value();
    mp_data_select = bv.bits(1, 1).get_value();
    access_mp = bv.bits(0, 0).get_value();
}



field_structure npl_bfd_em_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_em_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(rmep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(access_rmep);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_rmep", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mp_data_select);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_data_select", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(access_mp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_mp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_em_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_em_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 5, poll);
    bv.set_bits(4, 4, final);
    bv.set_bits(3, 3, ctrl_plane_independent);
    bv.set_bits(2, 2, auth_present);
    bv.set_bits(1, 1, demand);
    bv.set_bits(0, 0, multipoint);
    return bv;
}


void npl_bfd_flags_t::unpack(bit_vector64_t bv) 
{
    poll = bv.bits(5, 5).get_value();
    final = bv.bits(4, 4).get_value();
    ctrl_plane_independent = bv.bits(3, 3).get_value();
    auth_present = bv.bits(2, 2).get_value();
    demand = bv.bits(1, 1).get_value();
    multipoint = bv.bits(0, 0).get_value();
}



field_structure npl_bfd_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(poll);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("poll", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(final);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("final", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ctrl_plane_independent);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ctrl_plane_independent", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(auth_present);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("auth_present", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(demand);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("demand", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(multipoint);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("multipoint", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_inject_ttl_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, ttl);
    return bv;
}


void npl_bfd_inject_ttl_t::unpack(bit_vector64_t bv) 
{
    ttl = bv.bits(7, 0).get_value();
}



field_structure npl_bfd_inject_ttl_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_inject_ttl_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_inject_ttl_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_inject_ttl_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_ipv4_prot_shared_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    // PADDING -  bv.set_bits(39, 0, padding);
    return bv;
}


void npl_bfd_ipv4_prot_shared_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(39, 0).get_value();
}



field_structure npl_bfd_ipv4_prot_shared_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_ipv4_prot_shared_t";
    field_structure fs_subfield;
    //add members to result
    
    return fs_result;
}
std::string to_string(npl_bfd_ipv4_prot_shared_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_ipv4_prot_shared_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_ipv6_prot_shared_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 0, ipv6_dip_c);
    return bv;
}


void npl_bfd_ipv6_prot_shared_t::unpack(bit_vector64_t bv) 
{
    ipv6_dip_c = bv.bits(39, 0).get_value();
}



field_structure npl_bfd_ipv6_prot_shared_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_ipv6_prot_shared_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ipv6_dip_c);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_dip_c", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_ipv6_prot_shared_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_ipv6_prot_shared_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_ipv6_selector_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, data);
    return bv;
}


void npl_bfd_ipv6_selector_t::unpack(bit_vector64_t bv) 
{
    data = bv.bits(7, 0).get_value();
}



field_structure npl_bfd_ipv6_selector_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_ipv6_selector_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("data", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_ipv6_selector_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_ipv6_selector_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_local_ipv6_sip_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 0, sip);
    return bv;
}


void npl_bfd_local_ipv6_sip_t::unpack(bit_vector64_t bv) 
{
    sip = bv.bits(31, 0).get_value();
}



field_structure npl_bfd_local_ipv6_sip_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_local_ipv6_sip_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sip", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_local_ipv6_sip_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_local_ipv6_sip_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_mp_ipv4_transport_t::pack(void) const 
{
    bit_vector64_t bv(0, 57);
    bv.set_bits(56, 25, dip);
    bv.set_bits(24, 9, checksum);
    // PADDING -  bv.set_bits(8, 0, padding);
    return bv;
}


void npl_bfd_mp_ipv4_transport_t::unpack(bit_vector64_t bv) 
{
    dip = bv.bits(56, 25).get_value();
    checksum = bv.bits(24, 9).get_value();
    // PADDING -  padding = bv.bits(8, 0).get_value();
}



field_structure npl_bfd_mp_ipv4_transport_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_ipv4_transport_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(checksum);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("checksum", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_bfd_mp_ipv4_transport_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_ipv4_transport_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_mp_ipv6_transport_t::pack(void) const 
{
    bit_vector64_t bv(0, 57);
    bv.set_bits(56, 1, ipv6_dip_a);
    // PADDING -  bv.set_bits(0, 0, padding);
    return bv;
}


void npl_bfd_mp_ipv6_transport_t::unpack(bit_vector64_t bv) 
{
    ipv6_dip_a = bv.bits(56, 1).get_value();
    // PADDING -  padding = bv.bits(0, 0).get_value();
}



field_structure npl_bfd_mp_ipv6_transport_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_ipv6_transport_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ipv6_dip_a);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_dip_a", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_bfd_mp_ipv6_transport_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_ipv6_transport_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_mp_table_shared_msb_t_anonymous_union_trans_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 57);
    { // union compound field start
        bit_vector64_t tbv = ipv4.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(56, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv6.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(56, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_bfd_mp_table_shared_msb_t_anonymous_union_trans_data_t::unpack(bit_vector64_t bv) // union
{
    ipv4.unpack(bv.bits(56, 0));
}



field_structure npl_bfd_mp_table_shared_msb_t_anonymous_union_trans_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_shared_msb_t_anonymous_union_trans_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ipv4.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv4", ipv4.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv6.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv6", ipv6.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_shared_msb_t_anonymous_union_trans_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_shared_msb_t_anonymous_union_trans_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_mp_table_transmit_b_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, local_state_and_flags);
    bv.set_bits(7, 0, sip_selector);
    return bv;
}


void npl_bfd_mp_table_transmit_b_payload_t::unpack(bit_vector64_t bv) 
{
    local_state_and_flags = bv.bits(15, 8).get_value();
    sip_selector = bv.bits(7, 0).get_value();
}



field_structure npl_bfd_mp_table_transmit_b_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_transmit_b_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(local_state_and_flags);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("local_state_and_flags", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sip_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sip_selector", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_transmit_b_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_transmit_b_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_transport_and_label_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 1, transport);
    bv.set_bits(0, 0, requires_label);
    return bv;
}


void npl_bfd_transport_and_label_t::unpack(bit_vector64_t bv) 
{
    transport = (npl_bfd_transport_e)bv.bits(2, 1).get_value();
    requires_label = bv.bits(0, 0).get_value();
}



field_structure npl_bfd_transport_and_label_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_transport_and_label_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(transport);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("transport", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(requires_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("requires_label", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_transport_and_label_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_transport_and_label_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bool_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, val);
    return bv;
}


void npl_bool_t::unpack(bit_vector64_t bv) 
{
    val = (npl_bool_e)bv.bits(0, 0).get_value();
}



field_structure npl_bool_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bool_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bool_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bool_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_burst_size_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 0, value);
    return bv;
}


void npl_burst_size_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(17, 0).get_value();
}



field_structure npl_burst_size_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_burst_size_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_burst_size_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_burst_size_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bvn_profile_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, lp_over_lag);
    bv.set_bits(2, 0, tc_map_profile);
    return bv;
}


void npl_bvn_profile_t::unpack(bit_vector64_t bv) 
{
    lp_over_lag = bv.bits(3, 3).get_value();
    tc_map_profile = bv.bits(2, 0).get_value();
}



field_structure npl_bvn_profile_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bvn_profile_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lp_over_lag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_over_lag", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_map_profile", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bvn_profile_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bvn_profile_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_calc_checksum_enable_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, enable);
    return bv;
}


void npl_calc_checksum_enable_t::unpack(bit_vector64_t bv) 
{
    enable = bv.bits(0, 0).get_value();
}



field_structure npl_calc_checksum_enable_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_calc_checksum_enable_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_calc_checksum_enable_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_calc_checksum_enable_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_color_aware_mode_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, value);
    return bv;
}


void npl_color_aware_mode_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(0, 0).get_value();
}



field_structure npl_color_aware_mode_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_color_aware_mode_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_color_aware_mode_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_color_aware_mode_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_color_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, value);
    return bv;
}


void npl_color_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(1, 0).get_value();
}



field_structure npl_color_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_color_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_color_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_color_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_cntr_5bits_offset_and_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, offset);
    return bv;
}


void npl_common_cntr_5bits_offset_and_padding_t::unpack(bit_vector64_t bv) 
{
    offset = bv.bits(4, 0).get_value();
}



field_structure npl_common_cntr_5bits_offset_and_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_cntr_5bits_offset_and_padding_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_common_cntr_5bits_offset_and_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_cntr_5bits_offset_and_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_cntr_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 0, base_cntr_offset);
    return bv;
}


void npl_common_cntr_offset_t::unpack(bit_vector64_t bv) 
{
    base_cntr_offset = bv.bits(2, 0).get_value();
}



field_structure npl_common_cntr_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_cntr_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(base_cntr_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("base_cntr_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_common_cntr_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_cntr_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_data_ecmp2_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 16, enc_type);
    bv.set_bits(15, 0, te_tunnel14b_or_asbr);
    return bv;
}


void npl_common_data_ecmp2_t::unpack(bit_vector64_t bv) 
{
    enc_type = bv.bits(19, 16).get_value();
    te_tunnel14b_or_asbr = bv.bits(15, 0).get_value();
}



field_structure npl_common_data_ecmp2_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_data_ecmp2_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(te_tunnel14b_or_asbr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_tunnel14b_or_asbr", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_common_data_ecmp2_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_data_ecmp2_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_data_prefix_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 4, te_tunnel16b);
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_common_data_prefix_t::unpack(bit_vector64_t bv) 
{
    te_tunnel16b = bv.bits(19, 4).get_value();
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_common_data_prefix_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_data_prefix_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(te_tunnel16b);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_tunnel16b", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_common_data_prefix_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_data_prefix_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_compound_termination_control_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, append_relay);
    bv.set_bits(0, 0, attempt_termination);
    return bv;
}


void npl_compound_termination_control_t::unpack(bit_vector64_t bv) 
{
    append_relay = (npl_append_relay_e)bv.bits(1, 1).get_value();
    attempt_termination = bv.bits(0, 0).get_value();
}



field_structure npl_compound_termination_control_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_compound_termination_control_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(append_relay);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("append_relay", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(attempt_termination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("attempt_termination", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_compound_termination_control_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_compound_termination_control_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_compressed_counter_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, counter_idx);
    return bv;
}


void npl_compressed_counter_t::unpack(bit_vector64_t bv) 
{
    counter_idx = bv.bits(7, 0).get_value();
}



field_structure npl_compressed_counter_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_compressed_counter_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(counter_idx);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_idx", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_compressed_counter_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_compressed_counter_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_counter_flag_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 19, num_labels_is_3);
    bv.set_bits(18, 0, pad);
    return bv;
}


void npl_counter_flag_t::unpack(bit_vector64_t bv) 
{
    num_labels_is_3 = bv.bits(19, 19).get_value();
    pad = bv.bits(18, 0).get_value();
}



field_structure npl_counter_flag_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_counter_flag_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(num_labels_is_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_labels_is_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pad);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pad", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_counter_flag_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_counter_flag_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_counter_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, offset);
    return bv;
}


void npl_counter_offset_t::unpack(bit_vector64_t bv) 
{
    offset = bv.bits(3, 0).get_value();
}



field_structure npl_counter_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_counter_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_counter_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_counter_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_counter_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 19, update_or_read);
    bv.set_bits(18, 13, cb_id);
    bv.set_bits(12, 0, cb_set_base);
    return bv;
}


void npl_counter_ptr_t::unpack(bit_vector64_t bv) 
{
    update_or_read = bv.bits(19, 19).get_value();
    cb_id = bv.bits(18, 13).get_value();
    cb_set_base = bv.bits(12, 0).get_value();
}



field_structure npl_counter_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_counter_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(update_or_read);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_or_read", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cb_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cb_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cb_set_base);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cb_set_base", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_counter_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_counter_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_counters_block_config_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 23, lm_count_and_read);
    bv.set_bits(22, 22, reset_on_max_counter_read);
    bv.set_bits(21, 20, bank_counter_type);
    bv.set_bits(19, 13, compensation);
    bv.set_bits(12, 12, ignore_pd_compensation);
    bv.set_bits(11, 11, wraparound);
    bv.set_bits(10, 5, cpu_read_cc_wait_before_create_bubble);
    bv.set_bits(4, 3, bank_pipe_client_allocation);
    bv.set_bits(2, 0, bank_slice_allocation);
    return bv;
}


void npl_counters_block_config_t::unpack(bit_vector64_t bv) 
{
    lm_count_and_read = bv.bits(23, 23).get_value();
    reset_on_max_counter_read = bv.bits(22, 22).get_value();
    bank_counter_type = (npl_counter_type_e)bv.bits(21, 20).get_value();
    compensation = bv.bits(19, 13).get_value();
    ignore_pd_compensation = bv.bits(12, 12).get_value();
    wraparound = bv.bits(11, 11).get_value();
    cpu_read_cc_wait_before_create_bubble = bv.bits(10, 5).get_value();
    bank_pipe_client_allocation = bv.bits(4, 3).get_value();
    bank_slice_allocation = bv.bits(2, 0).get_value();
}



field_structure npl_counters_block_config_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_counters_block_config_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lm_count_and_read);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lm_count_and_read", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(reset_on_max_counter_read);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reset_on_max_counter_read", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bank_counter_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bank_counter_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(compensation);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("compensation", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ignore_pd_compensation);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ignore_pd_compensation", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(wraparound);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("wraparound", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cpu_read_cc_wait_before_create_bubble);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cpu_read_cc_wait_before_create_bubble", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bank_pipe_client_allocation);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bank_pipe_client_allocation", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bank_slice_allocation);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bank_slice_allocation", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_counters_block_config_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_counters_block_config_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_counters_voq_block_map_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 22, map_groups_size);
    bv.set_bits(21, 21, tc_profile);
    bv.set_bits(20, 7, counter_offset);
    bv.set_bits(6, 0, bank_id);
    return bv;
}


void npl_counters_voq_block_map_result_t::unpack(bit_vector64_t bv) 
{
    map_groups_size = bv.bits(23, 22).get_value();
    tc_profile = bv.bits(21, 21).get_value();
    counter_offset = bv.bits(20, 7).get_value();
    bank_id = bv.bits(6, 0).get_value();
}



field_structure npl_counters_voq_block_map_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_counters_voq_block_map_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(map_groups_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("map_groups_size", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bank_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bank_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_counters_voq_block_map_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_counters_voq_block_map_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_curr_and_next_prot_type_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, current_proto_type);
    bv.set_bits(3, 0, next_proto_type);
    return bv;
}


void npl_curr_and_next_prot_type_t::unpack(bit_vector64_t bv) 
{
    current_proto_type = bv.bits(7, 4).get_value();
    next_proto_type = bv.bits(3, 0).get_value();
}



field_structure npl_curr_and_next_prot_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_curr_and_next_prot_type_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(current_proto_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("current_proto_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_proto_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_proto_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_curr_and_next_prot_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_curr_and_next_prot_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_common_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, num_of_macros_to_perform);
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_db_access_common_header_t::unpack(bit_vector64_t bv) 
{
    num_of_macros_to_perform = bv.bits(7, 4).get_value();
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_db_access_common_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_common_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(num_of_macros_to_perform);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_of_macros_to_perform", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_db_access_common_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_common_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_fwd_info_header_t_anonymous_union_macro_or_fwd_dest_t::pack(void) const // union
{
    bit_vector64_t bv(0, 24);
    { // union compound field start
        bit_vector64_t tbv = common_header.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 16, tbv);
            return bv;
        }
    } // union compound field end
    
    if (fwd_dest != 0) {  // union primitive field start
        bv.set_bits(19, 0, fwd_dest);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_db_access_fwd_info_header_t_anonymous_union_macro_or_fwd_dest_t::unpack(bit_vector64_t bv) // union
{
    common_header.unpack(bv.bits(23, 16));
}



field_structure npl_db_access_fwd_info_header_t_anonymous_union_macro_or_fwd_dest_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_fwd_info_header_t_anonymous_union_macro_or_fwd_dest_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = common_header.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("common_header", common_header.to_field_structure());
        }
    } // union compound field end
    
    if (fwd_dest != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(fwd_dest);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_db_access_fwd_info_header_t_anonymous_union_macro_or_fwd_dest_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_fwd_info_header_t_anonymous_union_macro_or_fwd_dest_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_key_selectors_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 18, bucket_a_key_selector);
    bv.set_bits(17, 12, bucket_b_key_selector);
    bv.set_bits(11, 6, bucket_c_key_selector);
    bv.set_bits(5, 0, bucket_d_key_selector);
    return bv;
}


void npl_db_access_key_selectors_header_t::unpack(bit_vector64_t bv) 
{
    bucket_a_key_selector = bv.bits(23, 18).get_value();
    bucket_b_key_selector = bv.bits(17, 12).get_value();
    bucket_c_key_selector = bv.bits(11, 6).get_value();
    bucket_d_key_selector = bv.bits(5, 0).get_value();
}



field_structure npl_db_access_key_selectors_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_key_selectors_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bucket_a_key_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_key_selector", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bucket_b_key_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_key_selector", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bucket_c_key_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_key_selector", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bucket_d_key_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_key_selector", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_key_selectors_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_key_selectors_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_lu_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 29);
    bv.set_bits(28, 28, check_result);
    bv.set_bits(27, 20, expected_result);
    bv.set_bits(19, 0, key);
    return bv;
}


void npl_db_access_lu_data_t::unpack(bit_vector64_t bv) 
{
    check_result = bv.bits(28, 28).get_value();
    expected_result = bv.bits(27, 20).get_value();
    key = bv.bits(19, 0).get_value();
}



field_structure npl_db_access_lu_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_lu_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(check_result);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("check_result", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(expected_result);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("expected_result", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(key);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("key", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_lu_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_lu_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_service_mapping_access_attr_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 0, key_lsbs);
    return bv;
}


void npl_db_access_service_mapping_access_attr_t::unpack(bit_vector64_t bv) 
{
    key_lsbs = bv.bits(5, 0).get_value();
}



field_structure npl_db_access_service_mapping_access_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_service_mapping_access_attr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(key_lsbs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("key_lsbs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_service_mapping_access_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_service_mapping_access_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_service_mapping_tcam_access_attr_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 0, key_lsbs);
    return bv;
}


void npl_db_access_service_mapping_tcam_access_attr_t::unpack(bit_vector64_t bv) 
{
    key_lsbs = bv.bits(5, 0).get_value();
}



field_structure npl_db_access_service_mapping_tcam_access_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_service_mapping_tcam_access_attr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(key_lsbs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("key_lsbs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_service_mapping_tcam_access_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_service_mapping_tcam_access_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_splitter_action_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, access_type);
    return bv;
}


void npl_db_access_splitter_action_t::unpack(bit_vector64_t bv) 
{
    access_type = bv.bits(1, 0).get_value();
}



field_structure npl_db_access_splitter_action_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_splitter_action_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(access_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_splitter_action_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_splitter_action_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_term_macro_dests_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 52, bucket_a_lu_dest);
    bv.set_bits(51, 48, bucket_b_lu_dest);
    bv.set_bits(47, 44, bucket_c_lu_dest);
    bv.set_bits(43, 40, bucket_d_lu_dest);
    bv.set_bits(39, 36, bucket_a_result_dest);
    bv.set_bits(35, 32, bucket_b_result_dest);
    bv.set_bits(31, 28, bucket_c_result_dest);
    bv.set_bits(27, 24, bucket_d_result_dest);
    bv.set_bits(23, 0, db_access_key_selectors_header.pack());
    return bv;
}


void npl_db_access_term_macro_dests_header_t::unpack(bit_vector64_t bv) 
{
    bucket_a_lu_dest = (npl_term_bucket_a_lu_dest_e)bv.bits(55, 52).get_value();
    bucket_b_lu_dest = (npl_term_bucket_b_lu_dest_e)bv.bits(51, 48).get_value();
    bucket_c_lu_dest = (npl_term_bucket_c_lu_dest_e)bv.bits(47, 44).get_value();
    bucket_d_lu_dest = (npl_term_bucket_d_lu_dest_e)bv.bits(43, 40).get_value();
    bucket_a_result_dest = (npl_term_bucket_a_result_dest_e)bv.bits(39, 36).get_value();
    bucket_b_result_dest = (npl_term_bucket_b_result_dest_e)bv.bits(35, 32).get_value();
    bucket_c_result_dest = (npl_term_bucket_c_result_dest_e)bv.bits(31, 28).get_value();
    bucket_d_result_dest = (npl_term_bucket_d_result_dest_e)bv.bits(27, 24).get_value();
    db_access_key_selectors_header.unpack(bv.bits(23, 0));
}



field_structure npl_db_access_term_macro_dests_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_term_macro_dests_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(bucket_a_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_b_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_c_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_d_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_a_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_b_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_c_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_d_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_result_dest", fs_subfield);
    
    fs_result.subfields.emplace_back("db_access_key_selectors_header", db_access_key_selectors_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_db_access_term_macro_dests_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_term_macro_dests_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_transmit_macro_dests_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 52, bucket_a_lu_dest);
    bv.set_bits(51, 48, bucket_b_lu_dest);
    bv.set_bits(47, 44, bucket_c_lu_dest);
    bv.set_bits(43, 40, bucket_d_lu_dest);
    bv.set_bits(39, 36, bucket_a_result_dest);
    bv.set_bits(35, 32, bucket_b_result_dest);
    bv.set_bits(31, 28, bucket_c_result_dest);
    bv.set_bits(27, 24, bucket_d_result_dest);
    bv.set_bits(23, 0, db_access_key_selectors_header.pack());
    return bv;
}


void npl_db_access_transmit_macro_dests_header_t::unpack(bit_vector64_t bv) 
{
    bucket_a_lu_dest = (npl_transmit_bucket_a_lu_dest_e)bv.bits(55, 52).get_value();
    bucket_b_lu_dest = (npl_transmit_bucket_b_lu_dest_e)bv.bits(51, 48).get_value();
    bucket_c_lu_dest = (npl_transmit_bucket_c_lu_dest_e)bv.bits(47, 44).get_value();
    bucket_d_lu_dest = (npl_transmit_bucket_d_lu_dest_e)bv.bits(43, 40).get_value();
    bucket_a_result_dest = (npl_transmit_bucket_a_result_dest_e)bv.bits(39, 36).get_value();
    bucket_b_result_dest = (npl_transmit_bucket_b_result_dest_e)bv.bits(35, 32).get_value();
    bucket_c_result_dest = (npl_transmit_bucket_c_result_dest_e)bv.bits(31, 28).get_value();
    bucket_d_result_dest = (npl_transmit_bucket_d_result_dest_e)bv.bits(27, 24).get_value();
    db_access_key_selectors_header.unpack(bv.bits(23, 0));
}



field_structure npl_db_access_transmit_macro_dests_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_transmit_macro_dests_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(bucket_a_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_b_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_c_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_d_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_a_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_b_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_c_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_d_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_result_dest", fs_subfield);
    
    fs_result.subfields.emplace_back("db_access_key_selectors_header", db_access_key_selectors_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_db_access_transmit_macro_dests_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_transmit_macro_dests_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_transmit_per_dest_port_npu_host_macro_stamping_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 1, npu_host_macro);
    bv.set_bits(0, 0, stamp_npu_host_macro_on_packet);
    return bv;
}


void npl_db_access_transmit_per_dest_port_npu_host_macro_stamping_t::unpack(bit_vector64_t bv) 
{
    npu_host_macro = bv.bits(8, 1).get_value();
    stamp_npu_host_macro_on_packet = bv.bits(0, 0).get_value();
}



field_structure npl_db_access_transmit_per_dest_port_npu_host_macro_stamping_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_transmit_per_dest_port_npu_host_macro_stamping_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(npu_host_macro);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("npu_host_macro", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(stamp_npu_host_macro_on_packet);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("stamp_npu_host_macro_on_packet", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_transmit_per_dest_port_npu_host_macro_stamping_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_transmit_per_dest_port_npu_host_macro_stamping_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_tx_basic_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, num_of_macros_to_perform);
    bv.set_bits(3, 0, num_of_ene_instructions_to_perform);
    return bv;
}


void npl_db_access_tx_basic_header_t::unpack(bit_vector64_t bv) 
{
    num_of_macros_to_perform = bv.bits(7, 4).get_value();
    num_of_ene_instructions_to_perform = bv.bits(3, 0).get_value();
}



field_structure npl_db_access_tx_basic_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_tx_basic_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(num_of_macros_to_perform);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_of_macros_to_perform", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(num_of_ene_instructions_to_perform);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_of_ene_instructions_to_perform", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_access_tx_basic_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_tx_basic_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_fc_tx_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, data);
    return bv;
}


void npl_db_fc_tx_result_t::unpack(bit_vector64_t bv) 
{
    data = bv.bits(7, 0).get_value();
}



field_structure npl_db_fc_tx_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_fc_tx_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("data", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_db_fc_tx_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_fc_tx_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dest_class_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, id);
    return bv;
}


void npl_dest_class_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(7, 0).get_value();
}



field_structure npl_dest_class_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dest_class_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dest_class_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dest_class_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dest_slice_voq_map_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, dest_slice_voq);
    return bv;
}


void npl_dest_slice_voq_map_table_result_t::unpack(bit_vector64_t bv) 
{
    dest_slice_voq = bv.bits(15, 0).get_value();
}



field_structure npl_dest_slice_voq_map_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dest_slice_voq_map_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dest_slice_voq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_slice_voq", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dest_slice_voq_map_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dest_slice_voq_map_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dest_with_class_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 15, dest_19_15);
    bv.set_bits(14, 14, has_class_id);
    bv.set_bits(13, 12, dest_13_12);
    bv.set_bits(11, 8, class_id);
    bv.set_bits(7, 0, dest_7_0);
    return bv;
}


void npl_dest_with_class_id_t::unpack(bit_vector64_t bv) 
{
    dest_19_15 = bv.bits(19, 15).get_value();
    has_class_id = bv.bits(14, 14).get_value();
    dest_13_12 = bv.bits(13, 12).get_value();
    class_id = bv.bits(11, 8).get_value();
    dest_7_0 = bv.bits(7, 0).get_value();
}



field_structure npl_dest_with_class_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dest_with_class_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dest_19_15);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_19_15", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(has_class_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("has_class_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_13_12);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_13_12", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(class_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("class_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_7_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_7_0", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dest_with_class_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dest_with_class_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, val);
    return bv;
}


void npl_destination_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(19, 0).get_value();
}



field_structure npl_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_destination_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_device_mode_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, dev_mode);
    return bv;
}


void npl_device_mode_table_result_t::unpack(bit_vector64_t bv) 
{
    dev_mode = bv.bits(1, 0).get_value();
}



field_structure npl_device_mode_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_device_mode_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dev_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dev_mode", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_device_mode_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_device_mode_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dip_index_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 0, dummy_index);
    return bv;
}


void npl_dip_index_t::unpack(bit_vector64_t bv) 
{
    dummy_index = bv.bits(8, 0).get_value();
}



field_structure npl_dip_index_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dip_index_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dummy_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dummy_index", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dip_index_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dip_index_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dlp_profile_local_vars_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 9, dlp_type);
    bv.set_bits(8, 5, dlp_mask);
    bv.set_bits(4, 0, dlp_offset);
    return bv;
}


void npl_dlp_profile_local_vars_t::unpack(bit_vector64_t bv) 
{
    dlp_type = bv.bits(10, 9).get_value();
    dlp_mask = bv.bits(8, 5).get_value();
    dlp_offset = bv.bits(4, 0).get_value();
}



field_structure npl_dlp_profile_local_vars_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dlp_profile_local_vars_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dlp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dlp_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dlp_mask);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dlp_mask", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dlp_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dlp_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dlp_profile_local_vars_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dlp_profile_local_vars_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dram_cgm_cgm_lut_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 5, dp1);
    bv.set_bits(4, 4, dp0);
    bv.set_bits(3, 3, mark1);
    bv.set_bits(2, 2, mark0);
    bv.set_bits(1, 1, set_aging);
    bv.set_bits(0, 0, clr_aging);
    return bv;
}


void npl_dram_cgm_cgm_lut_results_t::unpack(bit_vector64_t bv) 
{
    dp1 = bv.bits(5, 5).get_value();
    dp0 = bv.bits(4, 4).get_value();
    mark1 = bv.bits(3, 3).get_value();
    mark0 = bv.bits(2, 2).get_value();
    set_aging = bv.bits(1, 1).get_value();
    clr_aging = bv.bits(0, 0).get_value();
}



field_structure npl_dram_cgm_cgm_lut_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dram_cgm_cgm_lut_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dp1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dp1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dp0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dp0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mark1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mark1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mark0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mark0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(set_aging);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("set_aging", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(clr_aging);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("clr_aging", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dram_cgm_cgm_lut_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dram_cgm_cgm_lut_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_drop_punt_or_permit_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, drop);
    bv.set_bits(1, 1, force_punt);
    bv.set_bits(0, 0, permit_count_enable);
    return bv;
}


void npl_drop_punt_or_permit_t::unpack(bit_vector64_t bv) 
{
    drop = bv.bits(2, 2).get_value();
    force_punt = bv.bits(1, 1).get_value();
    permit_count_enable = bv.bits(0, 0).get_value();
}



field_structure npl_drop_punt_or_permit_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_drop_punt_or_permit_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(force_punt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("force_punt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(permit_count_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("permit_count_enable", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_drop_punt_or_permit_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_drop_punt_or_permit_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dsp_group_policy_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, enable);
    return bv;
}


void npl_dsp_group_policy_t::unpack(bit_vector64_t bv) 
{
    enable = bv.bits(0, 0).get_value();
}



field_structure npl_dsp_group_policy_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dsp_group_policy_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dsp_group_policy_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dsp_group_policy_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dsp_map_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, dsp_punt_rcy);
    bv.set_bits(0, 0, dsp_is_scheduled_rcy);
    return bv;
}


void npl_dsp_map_info_t::unpack(bit_vector64_t bv) 
{
    dsp_punt_rcy = bv.bits(1, 1).get_value();
    dsp_is_scheduled_rcy = bv.bits(0, 0).get_value();
}



field_structure npl_dsp_map_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dsp_map_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dsp_punt_rcy);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp_punt_rcy", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp_is_scheduled_rcy);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp_is_scheduled_rcy", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dsp_map_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dsp_map_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_direct0_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, direct0_key);
    return bv;
}


void npl_egress_direct0_key_t::unpack(bit_vector64_t bv) 
{
    direct0_key = bv.bits(11, 0).get_value();
}



field_structure npl_egress_direct0_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_direct0_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(direct0_key);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("direct0_key", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_egress_direct0_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_direct0_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_direct1_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 0, direct1_key);
    return bv;
}


void npl_egress_direct1_key_t::unpack(bit_vector64_t bv) 
{
    direct1_key = bv.bits(9, 0).get_value();
}



field_structure npl_egress_direct1_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_direct1_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(direct1_key);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("direct1_key", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_egress_direct1_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_direct1_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_qos_result_t_anonymous_union_remark_l3_t::pack(void) const // union
{
    bit_vector64_t bv(0, 1);
    if (enable_egress_remark != 0) {  // union primitive field start
        bv.set_bits(0, 0, enable_egress_remark);
        return bv;
    }// union primitive field end
    
    if (use_in_mpls_exp != 0) {  // union primitive field start
        bv.set_bits(0, 0, use_in_mpls_exp);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_egress_qos_result_t_anonymous_union_remark_l3_t::unpack(bit_vector64_t bv) // union
{
    enable_egress_remark = bv.bits(0, 0).get_value();
}



field_structure npl_egress_qos_result_t_anonymous_union_remark_l3_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_qos_result_t_anonymous_union_remark_l3_t";
    field_structure fs_subfield;
    //add members to result
    if (enable_egress_remark != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(enable_egress_remark);
        return union_found;
    }// union primitive field end
    
    if (use_in_mpls_exp != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(use_in_mpls_exp);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_egress_qos_result_t_anonymous_union_remark_l3_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_qos_result_t_anonymous_union_remark_l3_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_sec_acl_result_t_anonymous_union_drop_or_permit_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = drop_counter.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = permit_ace_cntr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_egress_sec_acl_result_t_anonymous_union_drop_or_permit_t::unpack(bit_vector64_t bv) // union
{
    drop_counter.unpack(bv.bits(19, 0));
}



field_structure npl_egress_sec_acl_result_t_anonymous_union_drop_or_permit_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_sec_acl_result_t_anonymous_union_drop_or_permit_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = drop_counter.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("drop_counter", drop_counter.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = permit_ace_cntr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("permit_ace_cntr", permit_ace_cntr.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_egress_sec_acl_result_t_anonymous_union_drop_or_permit_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_sec_acl_result_t_anonymous_union_drop_or_permit_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_common_data_raw_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, common_data);
    return bv;
}


void npl_em_common_data_raw_t::unpack(bit_vector64_t bv) 
{
    common_data = bv.bits(19, 0).get_value();
}



field_structure npl_em_common_data_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_common_data_raw_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(common_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("common_data", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_em_common_data_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_common_data_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_common_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = common_data_ecmp2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = common_data_prefix.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_em_common_data_t::unpack(bit_vector64_t bv) // union
{
    common_data_ecmp2.unpack(bv.bits(19, 0));
}



field_structure npl_em_common_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_common_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = common_data_ecmp2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("common_data_ecmp2", common_data_ecmp2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = common_data_prefix.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("common_data_prefix", common_data_prefix.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("raw", raw.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_em_common_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_common_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_result_dsp_host_t::pack(void) const 
{
    bit_vector64_t bv(0, 63);
    bv.set_bits(62, 48, dsp_or_dspa);
    bv.set_bits(47, 0, host_mac);
    return bv;
}


void npl_em_result_dsp_host_t::unpack(bit_vector64_t bv) 
{
    dsp_or_dspa = bv.bits(62, 48).get_value();
    host_mac = bv.bits(47, 0).get_value();
}



field_structure npl_em_result_dsp_host_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_result_dsp_host_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dsp_or_dspa);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp_or_dspa", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(host_mac);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_mac", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_em_result_dsp_host_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_result_dsp_host_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_result_dsp_host_w_class_t_anonymous_union_dest_type_or_has_class_t::pack(void) const // union
{
    bit_vector64_t bv(0, 3);
    if (dest_type != 0) {  // union primitive field start
        bv.set_bits(2, 0, dest_type);
        return bv;
    }// union primitive field end
    
    if (has_class != 0) {  // union primitive field start
        bv.set_bits(2, 2, has_class);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_em_result_dsp_host_w_class_t_anonymous_union_dest_type_or_has_class_t::unpack(bit_vector64_t bv) // union
{
    dest_type = bv.bits(2, 0).get_value();
}



field_structure npl_em_result_dsp_host_w_class_t_anonymous_union_dest_type_or_has_class_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_result_dsp_host_w_class_t_anonymous_union_dest_type_or_has_class_t";
    field_structure fs_subfield;
    //add members to result
    if (dest_type != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(dest_type);
        return union_found;
    }// union primitive field end
    
    if (has_class != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(has_class);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_em_result_dsp_host_w_class_t_anonymous_union_dest_type_or_has_class_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_result_dsp_host_w_class_t_anonymous_union_dest_type_or_has_class_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_result_dsp_host_wo_class_t::pack(void) const 
{
    bit_vector64_t bv(0, 63);
    bv.set_bits(62, 60, dest_type);
    bv.set_bits(59, 48, dest);
    bv.set_bits(47, 41, host_mac_msb);
    bv.set_bits(40, 40, extra_dest_bit);
    bv.set_bits(39, 0, host_mac_lsb);
    return bv;
}


void npl_em_result_dsp_host_wo_class_t::unpack(bit_vector64_t bv) 
{
    dest_type = bv.bits(62, 60).get_value();
    dest = bv.bits(59, 48).get_value();
    host_mac_msb = bv.bits(47, 41).get_value();
    extra_dest_bit = bv.bits(40, 40).get_value();
    host_mac_lsb = bv.bits(39, 0).get_value();
}



field_structure npl_em_result_dsp_host_wo_class_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_result_dsp_host_wo_class_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dest_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(host_mac_msb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_mac_msb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(extra_dest_bit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("extra_dest_bit", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(host_mac_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_mac_lsb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_em_result_dsp_host_wo_class_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_result_dsp_host_wo_class_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_encap_mpls_exp_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, valid);
    bv.set_bits(2, 0, exp);
    return bv;
}


void npl_encap_mpls_exp_t::unpack(bit_vector64_t bv) 
{
    valid = bv.bits(3, 3).get_value();
    exp = bv.bits(2, 0).get_value();
}



field_structure npl_encap_mpls_exp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_encap_mpls_exp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("valid", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(exp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("exp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_encap_mpls_exp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_encap_mpls_exp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_macro_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, id);
    return bv;
}


void npl_ene_macro_id_t::unpack(bit_vector64_t bv) 
{
    id = (npl_ene_macro_ids_e)bv.bits(7, 0).get_value();
}



field_structure npl_ene_macro_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_macro_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ene_macro_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_macro_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_no_bos_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 1, exp);
    // PADDING -  bv.set_bits(0, 0, padding);
    return bv;
}


void npl_ene_no_bos_t::unpack(bit_vector64_t bv) 
{
    exp = bv.bits(3, 1).get_value();
    // PADDING -  padding = bv.bits(0, 0).get_value();
}



field_structure npl_ene_no_bos_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_no_bos_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(exp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("exp", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_ene_no_bos_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_no_bos_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_mp_table_transmit_a_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    // PADDING -  bv.set_bits(59, 53, padding);
    bv.set_bits(52, 52, tx_rdi);
    // PADDING -  bv.set_bits(51, 49, padding);
    bv.set_bits(48, 48, ccm_da);
    bv.set_bits(47, 0, unicast_da);
    return bv;
}


void npl_eth_mp_table_transmit_a_payload_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(59, 53).get_value();
    tx_rdi = bv.bits(52, 52).get_value();
    // PADDING -  padding = bv.bits(51, 49).get_value();
    ccm_da = (npl_eth_oam_da_e)bv.bits(48, 48).get_value();
    unicast_da = bv.bits(47, 0).get_value();
}



field_structure npl_eth_mp_table_transmit_a_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_mp_table_transmit_a_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(tx_rdi);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tx_rdi", fs_subfield);
    
    
    fs_subfield.flat_value = npl_enum_to_string(ccm_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ccm_da", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unicast_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unicast_da", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_eth_mp_table_transmit_a_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_mp_table_transmit_a_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_mp_table_transmit_b_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 0, padding);
    return bv;
}


void npl_eth_mp_table_transmit_b_payload_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 0).get_value();
}



field_structure npl_eth_mp_table_transmit_b_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_mp_table_transmit_b_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    return fs_result;
}
std::string to_string(npl_eth_mp_table_transmit_b_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_mp_table_transmit_b_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_rmep_app_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    // PADDING -  bv.set_bits(3, 2, padding);
    bv.set_bits(1, 1, rmep_rdi);
    bv.set_bits(0, 0, rmep_loc);
    return bv;
}


void npl_eth_rmep_app_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(3, 2).get_value();
    rmep_rdi = bv.bits(1, 1).get_value();
    rmep_loc = bv.bits(0, 0).get_value();
}



field_structure npl_eth_rmep_app_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_rmep_app_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(rmep_rdi);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_rdi", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(rmep_loc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_loc", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_eth_rmep_app_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_rmep_app_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_rmep_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 7, app.pack());
    // PADDING -  bv.set_bits(6, 0, padding);
    return bv;
}


void npl_eth_rmep_attributes_t::unpack(bit_vector64_t bv) 
{
    app.unpack(bv.bits(10, 7));
    // PADDING -  padding = bv.bits(6, 0).get_value();
}



field_structure npl_eth_rmep_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_rmep_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("app", app.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_eth_rmep_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_rmep_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_rtf_prop_over_fwd0_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 7, table_index);
    bv.set_bits(6, 0, acl_id);
    return bv;
}


void npl_eth_rtf_prop_over_fwd0_t::unpack(bit_vector64_t bv) 
{
    table_index = (npl_eth_table_index_e)bv.bits(7, 7).get_value();
    acl_id = bv.bits(6, 0).get_value();
}



field_structure npl_eth_rtf_prop_over_fwd0_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_rtf_prop_over_fwd0_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(table_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("table_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_eth_rtf_prop_over_fwd0_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_rtf_prop_over_fwd0_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_rtf_prop_over_fwd1_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 7, table_index);
    bv.set_bits(6, 0, acl_id);
    return bv;
}


void npl_eth_rtf_prop_over_fwd1_t::unpack(bit_vector64_t bv) 
{
    table_index = (npl_eth_table_index_e)bv.bits(7, 7).get_value();
    acl_id = bv.bits(6, 0).get_value();
}



field_structure npl_eth_rtf_prop_over_fwd1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_rtf_prop_over_fwd1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(table_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("table_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_eth_rtf_prop_over_fwd1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_rtf_prop_over_fwd1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ethernet_header_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, da_is_bc);
    bv.set_bits(1, 1, sa_is_mc);
    bv.set_bits(0, 0, sa_eq_da);
    return bv;
}


void npl_ethernet_header_flags_t::unpack(bit_vector64_t bv) 
{
    da_is_bc = bv.bits(2, 2).get_value();
    sa_is_mc = bv.bits(1, 1).get_value();
    sa_eq_da = bv.bits(0, 0).get_value();
}



field_structure npl_ethernet_header_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ethernet_header_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(da_is_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("da_is_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_is_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_is_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_eq_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_eq_da", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ethernet_header_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ethernet_header_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ethernet_oam_em_t::pack(void) const 
{
    bit_vector64_t bv(0, 29);
    bv.set_bits(28, 16, rmep_id);
    bv.set_bits(15, 3, mep_id);
    bv.set_bits(2, 2, access_rmep);
    bv.set_bits(1, 1, mp_data_select);
    bv.set_bits(0, 0, access_mp);
    return bv;
}


void npl_ethernet_oam_em_t::unpack(bit_vector64_t bv) 
{
    rmep_id = bv.bits(28, 16).get_value();
    mep_id = bv.bits(15, 3).get_value();
    access_rmep = bv.bits(2, 2).get_value();
    mp_data_select = bv.bits(1, 1).get_value();
    access_mp = bv.bits(0, 0).get_value();
}



field_structure npl_ethernet_oam_em_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ethernet_oam_em_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rmep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(access_rmep);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_rmep", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mp_data_select);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_data_select", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(access_mp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_mp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ethernet_oam_em_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ethernet_oam_em_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ethernet_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 55);
    bv.set_bits(54, 54, acl_drop);
    bv.set_bits(53, 53, acl_force_punt);
    bv.set_bits(52, 52, vlan_membership);
    bv.set_bits(51, 51, acceptable_format);
    bv.set_bits(50, 50, no_service_mapping);
    bv.set_bits(49, 49, no_termination_on_l3_port);
    bv.set_bits(48, 48, no_sip_mapping);
    bv.set_bits(47, 47, no_vni_mapping);
    bv.set_bits(46, 46, no_vsid_mapping);
    bv.set_bits(45, 45, arp);
    bv.set_bits(44, 44, sa_da_error);
    bv.set_bits(43, 43, sa_error);
    bv.set_bits(42, 42, da_error);
    bv.set_bits(41, 41, sa_multicast);
    bv.set_bits(40, 40, dhcpv4_server);
    bv.set_bits(39, 39, dhcpv4_client);
    bv.set_bits(38, 38, dhcpv6_server);
    bv.set_bits(37, 37, dhcpv6_client);
    bv.set_bits(36, 36, ingress_stp_block);
    bv.set_bits(35, 35, ptp_over_eth);
    bv.set_bits(34, 34, isis_over_l2);
    bv.set_bits(33, 33, l2cp0);
    bv.set_bits(32, 32, l2cp1);
    bv.set_bits(31, 31, l2cp2);
    bv.set_bits(30, 30, l2cp3);
    bv.set_bits(29, 29, l2cp4);
    bv.set_bits(28, 28, l2cp5);
    bv.set_bits(27, 27, l2cp6);
    bv.set_bits(26, 26, l2cp7);
    bv.set_bits(25, 25, lacp);
    bv.set_bits(24, 24, cisco_protocols);
    bv.set_bits(23, 23, macsec);
    bv.set_bits(22, 22, unknown_l3);
    bv.set_bits(21, 21, test_oam_ac_mep);
    bv.set_bits(20, 20, test_oam_ac_mip);
    bv.set_bits(19, 19, test_oam_cfm_link_mdl0);
    bv.set_bits(18, 18, system_mymac);
    bv.set_bits(17, 17, unknown_bc);
    bv.set_bits(16, 16, unknown_mc);
    bv.set_bits(15, 15, unknown_uc);
    bv.set_bits(14, 14, learn_punt);
    bv.set_bits(13, 13, bcast_pkt);
    bv.set_bits(12, 12, pfc_sample);
    bv.set_bits(11, 11, hop_by_hop);
    bv.set_bits(10, 10, l2_dlp_not_found);
    bv.set_bits(9, 9, same_interface);
    bv.set_bits(8, 8, dspa_mc_trim);
    bv.set_bits(7, 7, egress_stp_block);
    bv.set_bits(6, 6, split_horizon);
    bv.set_bits(5, 5, disabled);
    bv.set_bits(4, 4, incompatible_eve_cmd);
    bv.set_bits(3, 3, padding_residue_in_second_line);
    bv.set_bits(2, 2, pfc_direct_sample);
    bv.set_bits(1, 1, svi_egress_dhcp);
    bv.set_bits(0, 0, no_pwe_l3_dest);
    return bv;
}


void npl_ethernet_traps_t::unpack(bit_vector64_t bv) 
{
    acl_drop = bv.bits(54, 54).get_value();
    acl_force_punt = bv.bits(53, 53).get_value();
    vlan_membership = bv.bits(52, 52).get_value();
    acceptable_format = bv.bits(51, 51).get_value();
    no_service_mapping = bv.bits(50, 50).get_value();
    no_termination_on_l3_port = bv.bits(49, 49).get_value();
    no_sip_mapping = bv.bits(48, 48).get_value();
    no_vni_mapping = bv.bits(47, 47).get_value();
    no_vsid_mapping = bv.bits(46, 46).get_value();
    arp = bv.bits(45, 45).get_value();
    sa_da_error = bv.bits(44, 44).get_value();
    sa_error = bv.bits(43, 43).get_value();
    da_error = bv.bits(42, 42).get_value();
    sa_multicast = bv.bits(41, 41).get_value();
    dhcpv4_server = bv.bits(40, 40).get_value();
    dhcpv4_client = bv.bits(39, 39).get_value();
    dhcpv6_server = bv.bits(38, 38).get_value();
    dhcpv6_client = bv.bits(37, 37).get_value();
    ingress_stp_block = bv.bits(36, 36).get_value();
    ptp_over_eth = bv.bits(35, 35).get_value();
    isis_over_l2 = bv.bits(34, 34).get_value();
    l2cp0 = bv.bits(33, 33).get_value();
    l2cp1 = bv.bits(32, 32).get_value();
    l2cp2 = bv.bits(31, 31).get_value();
    l2cp3 = bv.bits(30, 30).get_value();
    l2cp4 = bv.bits(29, 29).get_value();
    l2cp5 = bv.bits(28, 28).get_value();
    l2cp6 = bv.bits(27, 27).get_value();
    l2cp7 = bv.bits(26, 26).get_value();
    lacp = bv.bits(25, 25).get_value();
    cisco_protocols = bv.bits(24, 24).get_value();
    macsec = bv.bits(23, 23).get_value();
    unknown_l3 = bv.bits(22, 22).get_value();
    test_oam_ac_mep = bv.bits(21, 21).get_value();
    test_oam_ac_mip = bv.bits(20, 20).get_value();
    test_oam_cfm_link_mdl0 = bv.bits(19, 19).get_value();
    system_mymac = bv.bits(18, 18).get_value();
    unknown_bc = bv.bits(17, 17).get_value();
    unknown_mc = bv.bits(16, 16).get_value();
    unknown_uc = bv.bits(15, 15).get_value();
    learn_punt = bv.bits(14, 14).get_value();
    bcast_pkt = bv.bits(13, 13).get_value();
    pfc_sample = bv.bits(12, 12).get_value();
    hop_by_hop = bv.bits(11, 11).get_value();
    l2_dlp_not_found = bv.bits(10, 10).get_value();
    same_interface = bv.bits(9, 9).get_value();
    dspa_mc_trim = bv.bits(8, 8).get_value();
    egress_stp_block = bv.bits(7, 7).get_value();
    split_horizon = bv.bits(6, 6).get_value();
    disabled = bv.bits(5, 5).get_value();
    incompatible_eve_cmd = bv.bits(4, 4).get_value();
    padding_residue_in_second_line = bv.bits(3, 3).get_value();
    pfc_direct_sample = bv.bits(2, 2).get_value();
    svi_egress_dhcp = bv.bits(1, 1).get_value();
    no_pwe_l3_dest = bv.bits(0, 0).get_value();
}



field_structure npl_ethernet_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ethernet_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(acl_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vlan_membership);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vlan_membership", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acceptable_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acceptable_format", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_service_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_service_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_termination_on_l3_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_termination_on_l3_port", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_sip_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_sip_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_vni_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_vni_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_vsid_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_vsid_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(arp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("arp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_da_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_da_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(da_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("da_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_multicast);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_multicast", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv4_server);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv4_server", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv4_client);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv4_client", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv6_server);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv6_server", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv6_client);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv6_client", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ingress_stp_block);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ingress_stp_block", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ptp_over_eth);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ptp_over_eth", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(isis_over_l2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("isis_over_l2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp5);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp5", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp7);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp7", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lacp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lacp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cisco_protocols);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cisco_protocols", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(macsec);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("macsec", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_l3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_l3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(test_oam_ac_mep);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("test_oam_ac_mep", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(test_oam_ac_mip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("test_oam_ac_mip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(test_oam_cfm_link_mdl0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("test_oam_cfm_link_mdl0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(system_mymac);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("system_mymac", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_uc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_uc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(learn_punt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("learn_punt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bcast_pkt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bcast_pkt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pfc_sample);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pfc_sample", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(hop_by_hop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hop_by_hop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_dlp_not_found);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_dlp_not_found", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(same_interface);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("same_interface", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dspa_mc_trim);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dspa_mc_trim", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(egress_stp_block);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("egress_stp_block", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(split_horizon);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("split_horizon", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(incompatible_eve_cmd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("incompatible_eve_cmd", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(padding_residue_in_second_line);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("padding_residue_in_second_line", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pfc_direct_sample);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pfc_direct_sample", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(svi_egress_dhcp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svi_egress_dhcp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_pwe_l3_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_pwe_l3_dest", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ethernet_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ethernet_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_event_queue_address_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 0, address);
    return bv;
}


void npl_event_queue_address_t::unpack(bit_vector64_t bv) 
{
    address = bv.bits(9, 0).get_value();
}



field_structure npl_event_queue_address_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_event_queue_address_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("address", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_event_queue_address_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_event_queue_address_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_event_to_send_t::pack(void) const 
{
    bit_vector64_t bv(0, 61);
    bv.set_bits(60, 29, rmep_last_time);
    bv.set_bits(28, 16, rmep_id);
    bv.set_bits(15, 0, rmep_state_table_data);
    return bv;
}


void npl_event_to_send_t::unpack(bit_vector64_t bv) 
{
    rmep_last_time = bv.bits(60, 29).get_value();
    rmep_id = bv.bits(28, 16).get_value();
    rmep_state_table_data = bv.bits(15, 0).get_value();
}



field_structure npl_event_to_send_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_event_to_send_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rmep_last_time);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_last_time", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(rmep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(rmep_state_table_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_state_table_data", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_event_to_send_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_event_to_send_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_exact_bank_index_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, value);
    return bv;
}


void npl_exact_bank_index_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(3, 0).get_value();
}



field_structure npl_exact_bank_index_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_exact_bank_index_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_exact_bank_index_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_exact_bank_index_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_exact_meter_index_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 0, value);
    return bv;
}


void npl_exact_meter_index_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(10, 0).get_value();
}



field_structure npl_exact_meter_index_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_exact_meter_index_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_exact_meter_index_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_exact_meter_index_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_exp_and_bos_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 1, exp);
    bv.set_bits(0, 0, bos);
    return bv;
}


void npl_exp_and_bos_t::unpack(bit_vector64_t bv) 
{
    exp = bv.bits(3, 1).get_value();
    bos = bv.bits(0, 0).get_value();
}



field_structure npl_exp_and_bos_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_exp_and_bos_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(exp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("exp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bos", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_exp_and_bos_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_exp_and_bos_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_exp_bos_and_label_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 20, label_exp_bos.pack());
    bv.set_bits(19, 0, label);
    return bv;
}


void npl_exp_bos_and_label_t::unpack(bit_vector64_t bv) 
{
    label_exp_bos.unpack(bv.bits(23, 20));
    label = bv.bits(19, 0).get_value();
}



field_structure npl_exp_bos_and_label_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_exp_bos_and_label_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("label_exp_bos", label_exp_bos.to_field_structure());
    fs_subfield.flat_value = to_hex_string(label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_exp_bos_and_label_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_exp_bos_and_label_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_expanded_forward_response_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 4, dest);
    bv.set_bits(3, 0, pad);
    return bv;
}


void npl_expanded_forward_response_t::unpack(bit_vector64_t bv) 
{
    dest = bv.bits(23, 4).get_value();
    pad = bv.bits(3, 0).get_value();
}



field_structure npl_expanded_forward_response_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_expanded_forward_response_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pad);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pad", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_expanded_forward_response_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_expanded_forward_response_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_extended_encap_data2_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 0, ene_ipv6_dip_lsb);
    return bv;
}


void npl_extended_encap_data2_t::unpack(bit_vector64_t bv) 
{
    ene_ipv6_dip_lsb = bv.bits(47, 0).get_value();
}



field_structure npl_extended_encap_data2_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_extended_encap_data2_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ene_ipv6_dip_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_ipv6_dip_lsb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_extended_encap_data2_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_extended_encap_data2_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_extended_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = ene_ipv6_dip_msb;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_extended_encap_data_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        uint64_t * p = ene_ipv6_dip_msb;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_extended_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_extended_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = ene_ipv6_dip_msb;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_extended_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_extended_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_cfg_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 10, issu_codespace);
    bv.set_bits(9, 9, plb_type);
    bv.set_bits(8, 0, device);
    return bv;
}


void npl_fabric_cfg_t::unpack(bit_vector64_t bv) 
{
    issu_codespace = bv.bits(10, 10).get_value();
    plb_type = (npl_plb_type_e)bv.bits(9, 9).get_value();
    device = bv.bits(8, 0).get_value();
}



field_structure npl_fabric_cfg_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_cfg_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(issu_codespace);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("issu_codespace", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(plb_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("plb_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(device);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("device", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fabric_cfg_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_cfg_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_header_ctrl_sn_plb_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, link_fc);
    bv.set_bits(2, 2, fcn);
    // PADDING -  bv.set_bits(1, 1, padding);
    bv.set_bits(0, 0, plb_ctxt);
    return bv;
}


void npl_fabric_header_ctrl_sn_plb_t::unpack(bit_vector64_t bv) 
{
    link_fc = bv.bits(3, 3).get_value();
    fcn = bv.bits(2, 2).get_value();
    // PADDING -  padding = bv.bits(1, 1).get_value();
    plb_ctxt = bv.bits(0, 0).get_value();
}



field_structure npl_fabric_header_ctrl_sn_plb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_header_ctrl_sn_plb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(link_fc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_fc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fcn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fcn", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(plb_ctxt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("plb_ctxt", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fabric_header_ctrl_sn_plb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_header_ctrl_sn_plb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_header_ctrl_ts_plb_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, link_fc);
    bv.set_bits(2, 2, fcn);
    bv.set_bits(1, 0, plb_ctxt);
    return bv;
}


void npl_fabric_header_ctrl_ts_plb_t::unpack(bit_vector64_t bv) 
{
    link_fc = bv.bits(3, 3).get_value();
    fcn = bv.bits(2, 2).get_value();
    plb_ctxt = (npl_fabric_ts_plb_ctxt_e)bv.bits(1, 0).get_value();
}



field_structure npl_fabric_header_ctrl_ts_plb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_header_ctrl_ts_plb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(link_fc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_fc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fcn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fcn", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(plb_ctxt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("plb_ctxt", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fabric_header_ctrl_ts_plb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_header_ctrl_ts_plb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_header_start_template_t_anonymous_union_ctrl_t::pack(void) const // union
{
    bit_vector64_t bv(0, 4);
    { // union compound field start
        bit_vector64_t tbv = ts_plb.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(3, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = sn_plb.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(3, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_fabric_header_start_template_t_anonymous_union_ctrl_t::unpack(bit_vector64_t bv) // union
{
    ts_plb.unpack(bv.bits(3, 0));
}



field_structure npl_fabric_header_start_template_t_anonymous_union_ctrl_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_header_start_template_t_anonymous_union_ctrl_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ts_plb.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ts_plb", ts_plb.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = sn_plb.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("sn_plb", sn_plb.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_fabric_header_start_template_t_anonymous_union_ctrl_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_header_start_template_t_anonymous_union_ctrl_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_ibm_cmd_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 5, ibm_cmd_padding);
    bv.set_bits(4, 0, ibm_cmd);
    return bv;
}


void npl_fabric_ibm_cmd_t::unpack(bit_vector64_t bv) 
{
    ibm_cmd_padding = bv.bits(7, 5).get_value();
    ibm_cmd = bv.bits(4, 0).get_value();
}



field_structure npl_fabric_ibm_cmd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_ibm_cmd_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ibm_cmd_padding);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ibm_cmd_padding", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ibm_cmd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ibm_cmd", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fabric_ibm_cmd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_ibm_cmd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_mc_ibm_cmd_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 20, fabric_mc_encapsulation_type);
    bv.set_bits(19, 17, fabric_mc_ibm_cmd_padding);
    bv.set_bits(16, 12, fabric_mc_ibm_cmd);
    bv.set_bits(11, 8, fabric_mc_ibm_cmd_src);
    // PADDING -  bv.set_bits(7, 0, padding);
    return bv;
}


void npl_fabric_mc_ibm_cmd_t::unpack(bit_vector64_t bv) 
{
    fabric_mc_encapsulation_type = (npl_npu_mirror_or_redirect_encap_type_e)bv.bits(23, 20).get_value();
    fabric_mc_ibm_cmd_padding = bv.bits(19, 17).get_value();
    fabric_mc_ibm_cmd = bv.bits(16, 12).get_value();
    fabric_mc_ibm_cmd_src = (npl_punt_source_e)bv.bits(11, 8).get_value();
    // PADDING -  padding = bv.bits(7, 0).get_value();
}



field_structure npl_fabric_mc_ibm_cmd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_mc_ibm_cmd_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(fabric_mc_encapsulation_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_mc_encapsulation_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fabric_mc_ibm_cmd_padding);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_mc_ibm_cmd_padding", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fabric_mc_ibm_cmd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_mc_ibm_cmd", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_mc_ibm_cmd_src);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_mc_ibm_cmd_src", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_fabric_mc_ibm_cmd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_mc_ibm_cmd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fabric_port_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 0, val);
    return bv;
}


void npl_fabric_port_id_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(6, 0).get_value();
}



field_structure npl_fabric_port_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fabric_port_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fabric_port_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fabric_port_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fb_link_2_link_bundle_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 0, bundle_num);
    return bv;
}


void npl_fb_link_2_link_bundle_table_result_t::unpack(bit_vector64_t bv) 
{
    bundle_num = bv.bits(5, 0).get_value();
}



field_structure npl_fb_link_2_link_bundle_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fb_link_2_link_bundle_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bundle_num);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_num", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fb_link_2_link_bundle_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fb_link_2_link_bundle_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_fe_broadcast_bmp_table_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 108);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 108 - 1;
        size_t msb = 0;
        const uint64_t * p = links_bmp;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_fe_broadcast_bmp_table_result_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 108 - 1;
        size_t msb = 0;
        uint64_t * p = links_bmp;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_fe_broadcast_bmp_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fe_broadcast_bmp_table_result_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 108 - 1;
        size_t msb = 0;
        const uint64_t * p = links_bmp;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_fe_broadcast_bmp_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fe_broadcast_bmp_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fe_rlb_uc_tx_fb_link_to_oq_map_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 0, base_oq);
    return bv;
}


void npl_fe_rlb_uc_tx_fb_link_to_oq_map_table_result_t::unpack(bit_vector64_t bv) 
{
    base_oq = bv.bits(8, 0).get_value();
}



field_structure npl_fe_rlb_uc_tx_fb_link_to_oq_map_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fe_rlb_uc_tx_fb_link_to_oq_map_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(base_oq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("base_oq", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fe_rlb_uc_tx_fb_link_to_oq_map_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fe_rlb_uc_tx_fb_link_to_oq_map_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fe_uc_bundle_selected_link_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 0, bundle_link);
    return bv;
}


void npl_fe_uc_bundle_selected_link_t::unpack(bit_vector64_t bv) 
{
    bundle_link = bv.bits(6, 0).get_value();
}



field_structure npl_fe_uc_bundle_selected_link_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fe_uc_bundle_selected_link_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bundle_link);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fe_uc_bundle_selected_link_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fe_uc_bundle_selected_link_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_fe_uc_link_bundle_desc_table_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 88);
    bv.set_bits(87, 73, bundle_link_3_bc);
    bv.set_bits(72, 66, bundle_link_3);
    bv.set_bits(65, 51, bundle_link_2_bc);
    bv.set_bits(50, 44, bundle_link_2);
    bv.set_bits(43, 29, bundle_link_1_bc);
    bv.set_bits(28, 22, bundle_link_1);
    bv.set_bits(21, 7, bundle_link_0_bc);
    bv.set_bits(6, 0, bundle_link_0);
    return bv;
}


void npl_fe_uc_link_bundle_desc_table_result_t::unpack(bit_vector128_t bv) 
{
    bundle_link_3_bc = bv.bits(87, 73).get_value();
    bundle_link_3 = bv.bits(72, 66).get_value();
    bundle_link_2_bc = bv.bits(65, 51).get_value();
    bundle_link_2 = bv.bits(50, 44).get_value();
    bundle_link_1_bc = bv.bits(43, 29).get_value();
    bundle_link_1 = bv.bits(28, 22).get_value();
    bundle_link_0_bc = bv.bits(21, 7).get_value();
    bundle_link_0 = bv.bits(6, 0).get_value();
}



field_structure npl_fe_uc_link_bundle_desc_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fe_uc_link_bundle_desc_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bundle_link_3_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_3_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_2_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_2_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_1_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_1_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_0_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_0_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bundle_link_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bundle_link_0", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fe_uc_link_bundle_desc_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fe_uc_link_bundle_desc_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fe_uc_random_fb_link_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 0, link_num);
    return bv;
}


void npl_fe_uc_random_fb_link_t::unpack(bit_vector64_t bv) 
{
    link_num = bv.bits(6, 0).get_value();
}



field_structure npl_fe_uc_random_fb_link_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fe_uc_random_fb_link_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(link_num);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_num", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fe_uc_random_fb_link_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fe_uc_random_fb_link_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_fec_destination1_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 76, enc_type);
    // PADDING -  bv.set_bits(75, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_fec_destination1_t::unpack(bit_vector128_t bv) 
{
    enc_type = bv.bits(79, 76).get_value();
    // PADDING -  padding = bv.bits(75, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_fec_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_fec_destination1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fec_destination1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fec_destination1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fec_destination1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_fec_fec_destination_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    // PADDING -  bv.set_bits(79, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_fec_fec_destination_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(79, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_fec_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_fec_fec_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fec_fec_destination_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fec_fec_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fec_fec_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_fec_raw_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 6;
        size_t max_msb = lsb + 74 - 1;
        size_t msb = 0;
        const uint64_t * p = payload;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_fec_raw_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 6;
        size_t max_msb = lsb + 74 - 1;
        size_t msb = 0;
        uint64_t * p = payload;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    type = (npl_fec_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_fec_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fec_raw_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 6;
        size_t max_msb = lsb + 74 - 1;
        size_t msb = 0;
        const uint64_t * p = payload;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fec_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fec_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_fi_macro_config_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    bv.set_bits(71, 67, tcam_key_inst1_offset);
    bv.set_bits(66, 61, tcam_key_inst1_width);
    bv.set_bits(60, 55, tcam_key_inst0_offset);
    bv.set_bits(54, 50, tcam_key_inst0_width);
    bv.set_bits(49, 45, alu_shift2);
    bv.set_bits(44, 41, alu_shift1);
    bv.set_bits(40, 38, hw_logic_select);
    bv.set_bits(37, 37, alu_mux2_select);
    bv.set_bits(36, 36, alu_mux1_select);
    bv.set_bits(35, 28, fs2_const);
    bv.set_bits(27, 20, fs1_const);
    bv.set_bits(19, 16, alu_fs2_valid_bits);
    bv.set_bits(15, 10, alu_fs2_offset);
    bv.set_bits(9, 6, alu_fs1_valid_bits);
    bv.set_bits(5, 0, alu_fs1_offset);
    return bv;
}


void npl_fi_macro_config_data_t::unpack(bit_vector128_t bv) 
{
    tcam_key_inst1_offset = bv.bits(71, 67).get_value();
    tcam_key_inst1_width = bv.bits(66, 61).get_value();
    tcam_key_inst0_offset = bv.bits(60, 55).get_value();
    tcam_key_inst0_width = bv.bits(54, 50).get_value();
    alu_shift2 = bv.bits(49, 45).get_value();
    alu_shift1 = bv.bits(44, 41).get_value();
    hw_logic_select = (npl_fi_hardwired_logic_e)bv.bits(40, 38).get_value();
    alu_mux2_select = bv.bits(37, 37).get_value();
    alu_mux1_select = bv.bits(36, 36).get_value();
    fs2_const = bv.bits(35, 28).get_value();
    fs1_const = bv.bits(27, 20).get_value();
    alu_fs2_valid_bits = bv.bits(19, 16).get_value();
    alu_fs2_offset = bv.bits(15, 10).get_value();
    alu_fs1_valid_bits = bv.bits(9, 6).get_value();
    alu_fs1_offset = bv.bits(5, 0).get_value();
}



field_structure npl_fi_macro_config_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fi_macro_config_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tcam_key_inst1_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_key_inst1_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tcam_key_inst1_width);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_key_inst1_width", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tcam_key_inst0_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_key_inst0_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tcam_key_inst0_width);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_key_inst0_width", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_shift2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_shift2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_shift1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_shift1", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(hw_logic_select);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hw_logic_select", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_mux2_select);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_mux2_select", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_mux1_select);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_mux1_select", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fs2_const);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fs2_const", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fs1_const);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fs1_const", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_fs2_valid_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_fs2_valid_bits", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_fs2_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_fs2_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_fs1_valid_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_fs1_valid_bits", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(alu_fs1_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("alu_fs1_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fi_macro_config_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fi_macro_config_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fi_tcam_hardwired_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 11, start_new_layer);
    bv.set_bits(10, 5, next_macro_id);
    bv.set_bits(4, 0, next_header_type);
    return bv;
}


void npl_fi_tcam_hardwired_result_t::unpack(bit_vector64_t bv) 
{
    start_new_layer = bv.bits(11, 11).get_value();
    next_macro_id = bv.bits(10, 5).get_value();
    next_header_type = (npl_protocol_type_e)bv.bits(4, 0).get_value();
}



field_structure npl_fi_tcam_hardwired_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fi_tcam_hardwired_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(start_new_layer);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("start_new_layer", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_macro_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_macro_id", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(next_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_header_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fi_tcam_hardwired_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fi_tcam_hardwired_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_filb_voq_mapping_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 26);
    bv.set_bits(25, 25, packing_eligible);
    bv.set_bits(24, 21, snr_plb_ss2dd);
    bv.set_bits(20, 12, dest_oq);
    bv.set_bits(11, 9, dest_slice);
    bv.set_bits(8, 0, dest_dev);
    return bv;
}


void npl_filb_voq_mapping_result_t::unpack(bit_vector64_t bv) 
{
    packing_eligible = bv.bits(25, 25).get_value();
    snr_plb_ss2dd = bv.bits(24, 21).get_value();
    dest_oq = bv.bits(20, 12).get_value();
    dest_slice = bv.bits(11, 9).get_value();
    dest_dev = bv.bits(8, 0).get_value();
}



field_structure npl_filb_voq_mapping_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_filb_voq_mapping_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(packing_eligible);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("packing_eligible", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(snr_plb_ss2dd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("snr_plb_ss2dd", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_oq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_oq", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_slice);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_slice", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_dev);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_dev", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_filb_voq_mapping_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_filb_voq_mapping_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_flc_header_types_array_key_t::pack(void) const 
{
    bit_vector128_t bv(0, 73);
    bv.set_bits(72, 68, source_port);
    bv.set_bits(67, 67, ifg);
    bv.set_bits(66, 65, recycle_code);
    bv.set_bits(64, 40, fi_hdr_5to9);
    bv.set_bits(39, 0, fi_hdr_4to0);
    return bv;
}


void npl_flc_header_types_array_key_t::unpack(bit_vector128_t bv) 
{
    source_port = bv.bits(72, 68).get_value();
    ifg = bv.bits(67, 67).get_value();
    recycle_code = bv.bits(66, 65).get_value();
    fi_hdr_5to9 = bv.bits(64, 40).get_value();
    fi_hdr_4to0 = bv.bits(39, 0).get_value();
}



field_structure npl_flc_header_types_array_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_header_types_array_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(source_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("source_port", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ifg", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(recycle_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("recycle_code", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fi_hdr_5to9);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fi_hdr_5to9", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fi_hdr_4to0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fi_hdr_4to0", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_header_types_array_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_header_types_array_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_map_header_type_mask_id_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, mask_id);
    return bv;
}


void npl_flc_map_header_type_mask_id_data_t::unpack(bit_vector64_t bv) 
{
    mask_id = bv.bits(4, 0).get_value();
}



field_structure npl_flc_map_header_type_mask_id_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_id_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mask_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mask_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_id_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_id_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_map_header_type_mask_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, sel);
    return bv;
}


void npl_flc_map_header_type_mask_id_t::unpack(bit_vector64_t bv) 
{
    sel = bv.bits(4, 0).get_value();
}



field_structure npl_flc_map_header_type_mask_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sel", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector npl_flc_map_header_type_mask_l_data_t::pack(void) const 
{
    bit_vector bv(0, 640);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 320;
        size_t max_msb = lsb + 320 - 1;
        size_t msb = 0;
        const uint64_t * p = cache_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 320 - 1;
        size_t msb = 0;
        const uint64_t * p = queue_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_flc_map_header_type_mask_l_data_t::unpack(bit_vector bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 320;
        size_t max_msb = lsb + 320 - 1;
        size_t msb = 0;
        uint64_t * p = cache_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 320 - 1;
        size_t msb = 0;
        uint64_t * p = queue_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_flc_map_header_type_mask_l_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_l_data_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 320;
        size_t max_msb = lsb + 320 - 1;
        size_t msb = 0;
        const uint64_t * p = cache_mask;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 320;
        size_t max_msb = lsb + 320 - 1;
        size_t msb = 0;
        const uint64_t * p = queue_mask;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_l_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_l_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_map_header_type_mask_lm_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 0, sel);
    return bv;
}


void npl_flc_map_header_type_mask_lm_key_t::unpack(bit_vector64_t bv) 
{
    sel = bv.bits(2, 0).get_value();
}



field_structure npl_flc_map_header_type_mask_lm_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_lm_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sel", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_lm_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_lm_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_flc_map_header_type_mask_m_data_t::pack(void) const 
{
    bit_vector384_t bv(0, 320);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 160;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        const uint64_t * p = cache_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        const uint64_t * p = queue_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_flc_map_header_type_mask_m_data_t::unpack(bit_vector384_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 160;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        uint64_t * p = cache_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        uint64_t * p = queue_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_flc_map_header_type_mask_m_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_m_data_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 160;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        const uint64_t * p = cache_mask;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 160;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        const uint64_t * p = queue_mask;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_m_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_m_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_flc_map_header_type_mask_s_data_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 80;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = cache_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = queue_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_flc_map_header_type_mask_s_data_t::unpack(bit_vector192_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 80;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        uint64_t * p = cache_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        uint64_t * p = queue_mask;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_flc_map_header_type_mask_s_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_s_data_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 80;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = cache_mask;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 80;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = queue_mask;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_s_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_s_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_map_header_type_mask_s_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, sel);
    return bv;
}


void npl_flc_map_header_type_mask_s_key_t::unpack(bit_vector64_t bv) 
{
    sel = bv.bits(3, 0).get_value();
}



field_structure npl_flc_map_header_type_mask_s_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_map_header_type_mask_s_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sel", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_map_header_type_mask_s_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_map_header_type_mask_s_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_range_comp_profile_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 14, range_set);
    bv.set_bits(13, 10, src_size);
    bv.set_bits(9, 4, src_offset);
    bv.set_bits(3, 0, src_hdr);
    return bv;
}


void npl_flc_range_comp_profile_data_t::unpack(bit_vector64_t bv) 
{
    range_set = bv.bits(15, 14).get_value();
    src_size = bv.bits(13, 10).get_value();
    src_offset = bv.bits(9, 4).get_value();
    src_hdr = bv.bits(3, 0).get_value();
}



field_structure npl_flc_range_comp_profile_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_range_comp_profile_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(range_set);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_set", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(src_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("src_size", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(src_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("src_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(src_hdr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("src_hdr", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_range_comp_profile_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_range_comp_profile_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_range_comp_profile_sel_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, profile_selector);
    return bv;
}


void npl_flc_range_comp_profile_sel_t::unpack(bit_vector64_t bv) 
{
    profile_selector = bv.bits(4, 0).get_value();
}



field_structure npl_flc_range_comp_profile_sel_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_range_comp_profile_sel_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(profile_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("profile_selector", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_range_comp_profile_sel_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_range_comp_profile_sel_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_range_comp_ranges_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 48, q_lower_limit);
    bv.set_bits(47, 32, q_upper_limit);
    bv.set_bits(31, 16, cache_lower_limit);
    bv.set_bits(15, 0, cache_upper_limit);
    return bv;
}


void npl_flc_range_comp_ranges_data_t::unpack(bit_vector64_t bv) 
{
    q_lower_limit = bv.bits(63, 48).get_value();
    q_upper_limit = bv.bits(47, 32).get_value();
    cache_lower_limit = bv.bits(31, 16).get_value();
    cache_upper_limit = bv.bits(15, 0).get_value();
}



field_structure npl_flc_range_comp_ranges_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_range_comp_ranges_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(q_lower_limit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("q_lower_limit", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(q_upper_limit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("q_upper_limit", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cache_lower_limit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cache_lower_limit", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cache_upper_limit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cache_upper_limit", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_range_comp_ranges_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_range_comp_ranges_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_range_comp_ranges_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 2, range_id_msb);
    bv.set_bits(1, 0, range_id_lsb);
    return bv;
}


void npl_flc_range_comp_ranges_key_t::unpack(bit_vector64_t bv) 
{
    range_id_msb = bv.bits(5, 2).get_value();
    range_id_lsb = bv.bits(1, 0).get_value();
}



field_structure npl_flc_range_comp_ranges_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_range_comp_ranges_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(range_id_msb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_id_msb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(range_id_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_id_lsb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_range_comp_ranges_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_range_comp_ranges_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_frm_db_fabric_routing_table_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 108);
    bv.set_bits(107, 107, fabric_routing_table_data[107]);
    bv.set_bits(106, 106, fabric_routing_table_data[106]);
    bv.set_bits(105, 105, fabric_routing_table_data[105]);
    bv.set_bits(104, 104, fabric_routing_table_data[104]);
    bv.set_bits(103, 103, fabric_routing_table_data[103]);
    bv.set_bits(102, 102, fabric_routing_table_data[102]);
    bv.set_bits(101, 101, fabric_routing_table_data[101]);
    bv.set_bits(100, 100, fabric_routing_table_data[100]);
    bv.set_bits(99, 99, fabric_routing_table_data[99]);
    bv.set_bits(98, 98, fabric_routing_table_data[98]);
    bv.set_bits(97, 97, fabric_routing_table_data[97]);
    bv.set_bits(96, 96, fabric_routing_table_data[96]);
    bv.set_bits(95, 95, fabric_routing_table_data[95]);
    bv.set_bits(94, 94, fabric_routing_table_data[94]);
    bv.set_bits(93, 93, fabric_routing_table_data[93]);
    bv.set_bits(92, 92, fabric_routing_table_data[92]);
    bv.set_bits(91, 91, fabric_routing_table_data[91]);
    bv.set_bits(90, 90, fabric_routing_table_data[90]);
    bv.set_bits(89, 89, fabric_routing_table_data[89]);
    bv.set_bits(88, 88, fabric_routing_table_data[88]);
    bv.set_bits(87, 87, fabric_routing_table_data[87]);
    bv.set_bits(86, 86, fabric_routing_table_data[86]);
    bv.set_bits(85, 85, fabric_routing_table_data[85]);
    bv.set_bits(84, 84, fabric_routing_table_data[84]);
    bv.set_bits(83, 83, fabric_routing_table_data[83]);
    bv.set_bits(82, 82, fabric_routing_table_data[82]);
    bv.set_bits(81, 81, fabric_routing_table_data[81]);
    bv.set_bits(80, 80, fabric_routing_table_data[80]);
    bv.set_bits(79, 79, fabric_routing_table_data[79]);
    bv.set_bits(78, 78, fabric_routing_table_data[78]);
    bv.set_bits(77, 77, fabric_routing_table_data[77]);
    bv.set_bits(76, 76, fabric_routing_table_data[76]);
    bv.set_bits(75, 75, fabric_routing_table_data[75]);
    bv.set_bits(74, 74, fabric_routing_table_data[74]);
    bv.set_bits(73, 73, fabric_routing_table_data[73]);
    bv.set_bits(72, 72, fabric_routing_table_data[72]);
    bv.set_bits(71, 71, fabric_routing_table_data[71]);
    bv.set_bits(70, 70, fabric_routing_table_data[70]);
    bv.set_bits(69, 69, fabric_routing_table_data[69]);
    bv.set_bits(68, 68, fabric_routing_table_data[68]);
    bv.set_bits(67, 67, fabric_routing_table_data[67]);
    bv.set_bits(66, 66, fabric_routing_table_data[66]);
    bv.set_bits(65, 65, fabric_routing_table_data[65]);
    bv.set_bits(64, 64, fabric_routing_table_data[64]);
    bv.set_bits(63, 63, fabric_routing_table_data[63]);
    bv.set_bits(62, 62, fabric_routing_table_data[62]);
    bv.set_bits(61, 61, fabric_routing_table_data[61]);
    bv.set_bits(60, 60, fabric_routing_table_data[60]);
    bv.set_bits(59, 59, fabric_routing_table_data[59]);
    bv.set_bits(58, 58, fabric_routing_table_data[58]);
    bv.set_bits(57, 57, fabric_routing_table_data[57]);
    bv.set_bits(56, 56, fabric_routing_table_data[56]);
    bv.set_bits(55, 55, fabric_routing_table_data[55]);
    bv.set_bits(54, 54, fabric_routing_table_data[54]);
    bv.set_bits(53, 53, fabric_routing_table_data[53]);
    bv.set_bits(52, 52, fabric_routing_table_data[52]);
    bv.set_bits(51, 51, fabric_routing_table_data[51]);
    bv.set_bits(50, 50, fabric_routing_table_data[50]);
    bv.set_bits(49, 49, fabric_routing_table_data[49]);
    bv.set_bits(48, 48, fabric_routing_table_data[48]);
    bv.set_bits(47, 47, fabric_routing_table_data[47]);
    bv.set_bits(46, 46, fabric_routing_table_data[46]);
    bv.set_bits(45, 45, fabric_routing_table_data[45]);
    bv.set_bits(44, 44, fabric_routing_table_data[44]);
    bv.set_bits(43, 43, fabric_routing_table_data[43]);
    bv.set_bits(42, 42, fabric_routing_table_data[42]);
    bv.set_bits(41, 41, fabric_routing_table_data[41]);
    bv.set_bits(40, 40, fabric_routing_table_data[40]);
    bv.set_bits(39, 39, fabric_routing_table_data[39]);
    bv.set_bits(38, 38, fabric_routing_table_data[38]);
    bv.set_bits(37, 37, fabric_routing_table_data[37]);
    bv.set_bits(36, 36, fabric_routing_table_data[36]);
    bv.set_bits(35, 35, fabric_routing_table_data[35]);
    bv.set_bits(34, 34, fabric_routing_table_data[34]);
    bv.set_bits(33, 33, fabric_routing_table_data[33]);
    bv.set_bits(32, 32, fabric_routing_table_data[32]);
    bv.set_bits(31, 31, fabric_routing_table_data[31]);
    bv.set_bits(30, 30, fabric_routing_table_data[30]);
    bv.set_bits(29, 29, fabric_routing_table_data[29]);
    bv.set_bits(28, 28, fabric_routing_table_data[28]);
    bv.set_bits(27, 27, fabric_routing_table_data[27]);
    bv.set_bits(26, 26, fabric_routing_table_data[26]);
    bv.set_bits(25, 25, fabric_routing_table_data[25]);
    bv.set_bits(24, 24, fabric_routing_table_data[24]);
    bv.set_bits(23, 23, fabric_routing_table_data[23]);
    bv.set_bits(22, 22, fabric_routing_table_data[22]);
    bv.set_bits(21, 21, fabric_routing_table_data[21]);
    bv.set_bits(20, 20, fabric_routing_table_data[20]);
    bv.set_bits(19, 19, fabric_routing_table_data[19]);
    bv.set_bits(18, 18, fabric_routing_table_data[18]);
    bv.set_bits(17, 17, fabric_routing_table_data[17]);
    bv.set_bits(16, 16, fabric_routing_table_data[16]);
    bv.set_bits(15, 15, fabric_routing_table_data[15]);
    bv.set_bits(14, 14, fabric_routing_table_data[14]);
    bv.set_bits(13, 13, fabric_routing_table_data[13]);
    bv.set_bits(12, 12, fabric_routing_table_data[12]);
    bv.set_bits(11, 11, fabric_routing_table_data[11]);
    bv.set_bits(10, 10, fabric_routing_table_data[10]);
    bv.set_bits(9, 9, fabric_routing_table_data[9]);
    bv.set_bits(8, 8, fabric_routing_table_data[8]);
    bv.set_bits(7, 7, fabric_routing_table_data[7]);
    bv.set_bits(6, 6, fabric_routing_table_data[6]);
    bv.set_bits(5, 5, fabric_routing_table_data[5]);
    bv.set_bits(4, 4, fabric_routing_table_data[4]);
    bv.set_bits(3, 3, fabric_routing_table_data[3]);
    bv.set_bits(2, 2, fabric_routing_table_data[2]);
    bv.set_bits(1, 1, fabric_routing_table_data[1]);
    bv.set_bits(0, 0, fabric_routing_table_data[0]);
    return bv;
}


void npl_frm_db_fabric_routing_table_result_t::unpack(bit_vector128_t bv) 
{
    fabric_routing_table_data[107] = (npl_fabric_port_can_reach_device_e)bv.bits(107, 107).get_value();
    fabric_routing_table_data[106] = (npl_fabric_port_can_reach_device_e)bv.bits(106, 106).get_value();
    fabric_routing_table_data[105] = (npl_fabric_port_can_reach_device_e)bv.bits(105, 105).get_value();
    fabric_routing_table_data[104] = (npl_fabric_port_can_reach_device_e)bv.bits(104, 104).get_value();
    fabric_routing_table_data[103] = (npl_fabric_port_can_reach_device_e)bv.bits(103, 103).get_value();
    fabric_routing_table_data[102] = (npl_fabric_port_can_reach_device_e)bv.bits(102, 102).get_value();
    fabric_routing_table_data[101] = (npl_fabric_port_can_reach_device_e)bv.bits(101, 101).get_value();
    fabric_routing_table_data[100] = (npl_fabric_port_can_reach_device_e)bv.bits(100, 100).get_value();
    fabric_routing_table_data[99] = (npl_fabric_port_can_reach_device_e)bv.bits(99, 99).get_value();
    fabric_routing_table_data[98] = (npl_fabric_port_can_reach_device_e)bv.bits(98, 98).get_value();
    fabric_routing_table_data[97] = (npl_fabric_port_can_reach_device_e)bv.bits(97, 97).get_value();
    fabric_routing_table_data[96] = (npl_fabric_port_can_reach_device_e)bv.bits(96, 96).get_value();
    fabric_routing_table_data[95] = (npl_fabric_port_can_reach_device_e)bv.bits(95, 95).get_value();
    fabric_routing_table_data[94] = (npl_fabric_port_can_reach_device_e)bv.bits(94, 94).get_value();
    fabric_routing_table_data[93] = (npl_fabric_port_can_reach_device_e)bv.bits(93, 93).get_value();
    fabric_routing_table_data[92] = (npl_fabric_port_can_reach_device_e)bv.bits(92, 92).get_value();
    fabric_routing_table_data[91] = (npl_fabric_port_can_reach_device_e)bv.bits(91, 91).get_value();
    fabric_routing_table_data[90] = (npl_fabric_port_can_reach_device_e)bv.bits(90, 90).get_value();
    fabric_routing_table_data[89] = (npl_fabric_port_can_reach_device_e)bv.bits(89, 89).get_value();
    fabric_routing_table_data[88] = (npl_fabric_port_can_reach_device_e)bv.bits(88, 88).get_value();
    fabric_routing_table_data[87] = (npl_fabric_port_can_reach_device_e)bv.bits(87, 87).get_value();
    fabric_routing_table_data[86] = (npl_fabric_port_can_reach_device_e)bv.bits(86, 86).get_value();
    fabric_routing_table_data[85] = (npl_fabric_port_can_reach_device_e)bv.bits(85, 85).get_value();
    fabric_routing_table_data[84] = (npl_fabric_port_can_reach_device_e)bv.bits(84, 84).get_value();
    fabric_routing_table_data[83] = (npl_fabric_port_can_reach_device_e)bv.bits(83, 83).get_value();
    fabric_routing_table_data[82] = (npl_fabric_port_can_reach_device_e)bv.bits(82, 82).get_value();
    fabric_routing_table_data[81] = (npl_fabric_port_can_reach_device_e)bv.bits(81, 81).get_value();
    fabric_routing_table_data[80] = (npl_fabric_port_can_reach_device_e)bv.bits(80, 80).get_value();
    fabric_routing_table_data[79] = (npl_fabric_port_can_reach_device_e)bv.bits(79, 79).get_value();
    fabric_routing_table_data[78] = (npl_fabric_port_can_reach_device_e)bv.bits(78, 78).get_value();
    fabric_routing_table_data[77] = (npl_fabric_port_can_reach_device_e)bv.bits(77, 77).get_value();
    fabric_routing_table_data[76] = (npl_fabric_port_can_reach_device_e)bv.bits(76, 76).get_value();
    fabric_routing_table_data[75] = (npl_fabric_port_can_reach_device_e)bv.bits(75, 75).get_value();
    fabric_routing_table_data[74] = (npl_fabric_port_can_reach_device_e)bv.bits(74, 74).get_value();
    fabric_routing_table_data[73] = (npl_fabric_port_can_reach_device_e)bv.bits(73, 73).get_value();
    fabric_routing_table_data[72] = (npl_fabric_port_can_reach_device_e)bv.bits(72, 72).get_value();
    fabric_routing_table_data[71] = (npl_fabric_port_can_reach_device_e)bv.bits(71, 71).get_value();
    fabric_routing_table_data[70] = (npl_fabric_port_can_reach_device_e)bv.bits(70, 70).get_value();
    fabric_routing_table_data[69] = (npl_fabric_port_can_reach_device_e)bv.bits(69, 69).get_value();
    fabric_routing_table_data[68] = (npl_fabric_port_can_reach_device_e)bv.bits(68, 68).get_value();
    fabric_routing_table_data[67] = (npl_fabric_port_can_reach_device_e)bv.bits(67, 67).get_value();
    fabric_routing_table_data[66] = (npl_fabric_port_can_reach_device_e)bv.bits(66, 66).get_value();
    fabric_routing_table_data[65] = (npl_fabric_port_can_reach_device_e)bv.bits(65, 65).get_value();
    fabric_routing_table_data[64] = (npl_fabric_port_can_reach_device_e)bv.bits(64, 64).get_value();
    fabric_routing_table_data[63] = (npl_fabric_port_can_reach_device_e)bv.bits(63, 63).get_value();
    fabric_routing_table_data[62] = (npl_fabric_port_can_reach_device_e)bv.bits(62, 62).get_value();
    fabric_routing_table_data[61] = (npl_fabric_port_can_reach_device_e)bv.bits(61, 61).get_value();
    fabric_routing_table_data[60] = (npl_fabric_port_can_reach_device_e)bv.bits(60, 60).get_value();
    fabric_routing_table_data[59] = (npl_fabric_port_can_reach_device_e)bv.bits(59, 59).get_value();
    fabric_routing_table_data[58] = (npl_fabric_port_can_reach_device_e)bv.bits(58, 58).get_value();
    fabric_routing_table_data[57] = (npl_fabric_port_can_reach_device_e)bv.bits(57, 57).get_value();
    fabric_routing_table_data[56] = (npl_fabric_port_can_reach_device_e)bv.bits(56, 56).get_value();
    fabric_routing_table_data[55] = (npl_fabric_port_can_reach_device_e)bv.bits(55, 55).get_value();
    fabric_routing_table_data[54] = (npl_fabric_port_can_reach_device_e)bv.bits(54, 54).get_value();
    fabric_routing_table_data[53] = (npl_fabric_port_can_reach_device_e)bv.bits(53, 53).get_value();
    fabric_routing_table_data[52] = (npl_fabric_port_can_reach_device_e)bv.bits(52, 52).get_value();
    fabric_routing_table_data[51] = (npl_fabric_port_can_reach_device_e)bv.bits(51, 51).get_value();
    fabric_routing_table_data[50] = (npl_fabric_port_can_reach_device_e)bv.bits(50, 50).get_value();
    fabric_routing_table_data[49] = (npl_fabric_port_can_reach_device_e)bv.bits(49, 49).get_value();
    fabric_routing_table_data[48] = (npl_fabric_port_can_reach_device_e)bv.bits(48, 48).get_value();
    fabric_routing_table_data[47] = (npl_fabric_port_can_reach_device_e)bv.bits(47, 47).get_value();
    fabric_routing_table_data[46] = (npl_fabric_port_can_reach_device_e)bv.bits(46, 46).get_value();
    fabric_routing_table_data[45] = (npl_fabric_port_can_reach_device_e)bv.bits(45, 45).get_value();
    fabric_routing_table_data[44] = (npl_fabric_port_can_reach_device_e)bv.bits(44, 44).get_value();
    fabric_routing_table_data[43] = (npl_fabric_port_can_reach_device_e)bv.bits(43, 43).get_value();
    fabric_routing_table_data[42] = (npl_fabric_port_can_reach_device_e)bv.bits(42, 42).get_value();
    fabric_routing_table_data[41] = (npl_fabric_port_can_reach_device_e)bv.bits(41, 41).get_value();
    fabric_routing_table_data[40] = (npl_fabric_port_can_reach_device_e)bv.bits(40, 40).get_value();
    fabric_routing_table_data[39] = (npl_fabric_port_can_reach_device_e)bv.bits(39, 39).get_value();
    fabric_routing_table_data[38] = (npl_fabric_port_can_reach_device_e)bv.bits(38, 38).get_value();
    fabric_routing_table_data[37] = (npl_fabric_port_can_reach_device_e)bv.bits(37, 37).get_value();
    fabric_routing_table_data[36] = (npl_fabric_port_can_reach_device_e)bv.bits(36, 36).get_value();
    fabric_routing_table_data[35] = (npl_fabric_port_can_reach_device_e)bv.bits(35, 35).get_value();
    fabric_routing_table_data[34] = (npl_fabric_port_can_reach_device_e)bv.bits(34, 34).get_value();
    fabric_routing_table_data[33] = (npl_fabric_port_can_reach_device_e)bv.bits(33, 33).get_value();
    fabric_routing_table_data[32] = (npl_fabric_port_can_reach_device_e)bv.bits(32, 32).get_value();
    fabric_routing_table_data[31] = (npl_fabric_port_can_reach_device_e)bv.bits(31, 31).get_value();
    fabric_routing_table_data[30] = (npl_fabric_port_can_reach_device_e)bv.bits(30, 30).get_value();
    fabric_routing_table_data[29] = (npl_fabric_port_can_reach_device_e)bv.bits(29, 29).get_value();
    fabric_routing_table_data[28] = (npl_fabric_port_can_reach_device_e)bv.bits(28, 28).get_value();
    fabric_routing_table_data[27] = (npl_fabric_port_can_reach_device_e)bv.bits(27, 27).get_value();
    fabric_routing_table_data[26] = (npl_fabric_port_can_reach_device_e)bv.bits(26, 26).get_value();
    fabric_routing_table_data[25] = (npl_fabric_port_can_reach_device_e)bv.bits(25, 25).get_value();
    fabric_routing_table_data[24] = (npl_fabric_port_can_reach_device_e)bv.bits(24, 24).get_value();
    fabric_routing_table_data[23] = (npl_fabric_port_can_reach_device_e)bv.bits(23, 23).get_value();
    fabric_routing_table_data[22] = (npl_fabric_port_can_reach_device_e)bv.bits(22, 22).get_value();
    fabric_routing_table_data[21] = (npl_fabric_port_can_reach_device_e)bv.bits(21, 21).get_value();
    fabric_routing_table_data[20] = (npl_fabric_port_can_reach_device_e)bv.bits(20, 20).get_value();
    fabric_routing_table_data[19] = (npl_fabric_port_can_reach_device_e)bv.bits(19, 19).get_value();
    fabric_routing_table_data[18] = (npl_fabric_port_can_reach_device_e)bv.bits(18, 18).get_value();
    fabric_routing_table_data[17] = (npl_fabric_port_can_reach_device_e)bv.bits(17, 17).get_value();
    fabric_routing_table_data[16] = (npl_fabric_port_can_reach_device_e)bv.bits(16, 16).get_value();
    fabric_routing_table_data[15] = (npl_fabric_port_can_reach_device_e)bv.bits(15, 15).get_value();
    fabric_routing_table_data[14] = (npl_fabric_port_can_reach_device_e)bv.bits(14, 14).get_value();
    fabric_routing_table_data[13] = (npl_fabric_port_can_reach_device_e)bv.bits(13, 13).get_value();
    fabric_routing_table_data[12] = (npl_fabric_port_can_reach_device_e)bv.bits(12, 12).get_value();
    fabric_routing_table_data[11] = (npl_fabric_port_can_reach_device_e)bv.bits(11, 11).get_value();
    fabric_routing_table_data[10] = (npl_fabric_port_can_reach_device_e)bv.bits(10, 10).get_value();
    fabric_routing_table_data[9] = (npl_fabric_port_can_reach_device_e)bv.bits(9, 9).get_value();
    fabric_routing_table_data[8] = (npl_fabric_port_can_reach_device_e)bv.bits(8, 8).get_value();
    fabric_routing_table_data[7] = (npl_fabric_port_can_reach_device_e)bv.bits(7, 7).get_value();
    fabric_routing_table_data[6] = (npl_fabric_port_can_reach_device_e)bv.bits(6, 6).get_value();
    fabric_routing_table_data[5] = (npl_fabric_port_can_reach_device_e)bv.bits(5, 5).get_value();
    fabric_routing_table_data[4] = (npl_fabric_port_can_reach_device_e)bv.bits(4, 4).get_value();
    fabric_routing_table_data[3] = (npl_fabric_port_can_reach_device_e)bv.bits(3, 3).get_value();
    fabric_routing_table_data[2] = (npl_fabric_port_can_reach_device_e)bv.bits(2, 2).get_value();
    fabric_routing_table_data[1] = (npl_fabric_port_can_reach_device_e)bv.bits(1, 1).get_value();
    fabric_routing_table_data[0] = (npl_fabric_port_can_reach_device_e)bv.bits(0, 0).get_value();
}



field_structure npl_frm_db_fabric_routing_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_frm_db_fabric_routing_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[107]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[107]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[106]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[106]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[105]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[105]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[104]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[104]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[103]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[103]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[102]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[102]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[101]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[101]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[100]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[100]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[99]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[99]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[98]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[98]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[97]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[97]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[96]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[96]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[95]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[95]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[94]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[94]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[93]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[93]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[92]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[92]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[91]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[91]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[90]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[90]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[89]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[89]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[88]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[88]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[87]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[87]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[86]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[86]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[85]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[85]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[84]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[84]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[83]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[83]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[82]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[82]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[81]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[81]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[80]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[80]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[79]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[79]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[78]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[78]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[77]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[77]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[76]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[76]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[75]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[75]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[74]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[74]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[73]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[73]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[72]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[72]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[71]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[71]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[70]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[70]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[69]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[69]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[68]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[68]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[67]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[67]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[66]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[66]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[65]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[65]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[64]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[64]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[63]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[63]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[62]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[62]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[61]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[61]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[60]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[60]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[59]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[59]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[58]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[58]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[57]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[57]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[56]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[56]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[55]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[55]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[54]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[54]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[53]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[53]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[52]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[52]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[51]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[51]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[50]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[50]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[49]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[49]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[48]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[48]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[47]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[47]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[46]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[46]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[45]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[45]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[44]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[44]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[43]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[43]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[42]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[42]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[41]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[41]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[40]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[40]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[39]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[39]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[38]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[38]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[37]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[37]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[36]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[36]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[35]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[35]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[34]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[34]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[33]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[33]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[32]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[32]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[31]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[31]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[30]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[30]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[29]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[29]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[28]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[28]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[27]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[27]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[26]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[26]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[25]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[25]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[24]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[24]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[23]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[23]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[22]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[22]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[21]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[21]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[20]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[20]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[19]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[19]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[18]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[18]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[17]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[17]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[16]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[16]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[15]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[15]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[14]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[14]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[13]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[13]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[12]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[12]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[11]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[11]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[10]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[10]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[9]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[9]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[8]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[8]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[7]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[7]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[6]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[6]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[5]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[5]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[4]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[4]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[3]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[3]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[2]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[2]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[1]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[1]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(fabric_routing_table_data[0]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_routing_table_data[0]", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_frm_db_fabric_routing_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_frm_db_fabric_routing_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_class_qos_group_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 5, fwd_class);
    bv.set_bits(4, 0, qos_group);
    return bv;
}


void npl_fwd_class_qos_group_t::unpack(bit_vector64_t bv) 
{
    fwd_class = bv.bits(7, 5).get_value();
    qos_group = bv.bits(4, 0).get_value();
}



field_structure npl_fwd_class_qos_group_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_class_qos_group_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(fwd_class);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_class", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_group", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fwd_class_qos_group_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_class_qos_group_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_layer_and_rtf_stage_compressed_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, fwd_layer);
    bv.set_bits(1, 0, rtf_stage);
    return bv;
}


void npl_fwd_layer_and_rtf_stage_compressed_fields_t::unpack(bit_vector64_t bv) 
{
    fwd_layer = (npl_fwd_layer_e)bv.bits(2, 2).get_value();
    rtf_stage = (npl_rtf_stage_e)bv.bits(1, 0).get_value();
}



field_structure npl_fwd_layer_and_rtf_stage_compressed_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_layer_and_rtf_stage_compressed_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(fwd_layer);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_layer", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtf_stage", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fwd_layer_and_rtf_stage_compressed_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_layer_and_rtf_stage_compressed_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_qos_tag_dscp_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    // PADDING -  bv.set_bits(6, 6, padding);
    bv.set_bits(5, 0, dscp);
    return bv;
}


void npl_fwd_qos_tag_dscp_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(6, 6).get_value();
    dscp = bv.bits(5, 0).get_value();
}



field_structure npl_fwd_qos_tag_dscp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_qos_tag_dscp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(dscp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dscp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fwd_qos_tag_dscp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_qos_tag_dscp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_qos_tag_exp_or_qosgroup_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    // PADDING -  bv.set_bits(6, 5, padding);
    bv.set_bits(4, 0, exp_or_qos_group);
    return bv;
}


void npl_fwd_qos_tag_exp_or_qosgroup_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(6, 5).get_value();
    exp_or_qos_group = bv.bits(4, 0).get_value();
}



field_structure npl_fwd_qos_tag_exp_or_qosgroup_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_qos_tag_exp_or_qosgroup_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(exp_or_qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("exp_or_qos_group", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fwd_qos_tag_exp_or_qosgroup_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_qos_tag_exp_or_qosgroup_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_qos_tag_group_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    // PADDING -  bv.set_bits(6, 5, padding);
    bv.set_bits(4, 0, qos_group_id);
    return bv;
}


void npl_fwd_qos_tag_group_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(6, 5).get_value();
    qos_group_id = bv.bits(4, 0).get_value();
}



field_structure npl_fwd_qos_tag_group_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_qos_tag_group_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(qos_group_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_group_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fwd_qos_tag_group_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_qos_tag_group_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_qos_tag_pcpdei_or_qosgroup_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    // PADDING -  bv.set_bits(6, 5, padding);
    bv.set_bits(4, 0, pcp_dei_or_qos_group);
    return bv;
}


void npl_fwd_qos_tag_pcpdei_or_qosgroup_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(6, 5).get_value();
    pcp_dei_or_qos_group = bv.bits(4, 0).get_value();
}



field_structure npl_fwd_qos_tag_pcpdei_or_qosgroup_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_qos_tag_pcpdei_or_qosgroup_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(pcp_dei_or_qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pcp_dei_or_qos_group", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fwd_qos_tag_pcpdei_or_qosgroup_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_qos_tag_pcpdei_or_qosgroup_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fwd_qos_tag_t::pack(void) const // union
{
    bit_vector64_t bv(0, 7);
    { // union compound field start
        bit_vector64_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(6, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(6, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mpls.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(6, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = group.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(6, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_fwd_qos_tag_t::unpack(bit_vector64_t bv) // union
{
    l2.unpack(bv.bits(6, 0));
}



field_structure npl_fwd_qos_tag_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fwd_qos_tag_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2", l2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3", l3.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mpls.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mpls", mpls.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = group.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("group", group.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_fwd_qos_tag_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fwd_qos_tag_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_g_ifg_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, value);
    return bv;
}


void npl_g_ifg_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(3, 0).get_value();
}



field_structure npl_g_ifg_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_g_ifg_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_g_ifg_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_g_ifg_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_gre_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, flag_res_version);
    bv.set_bits(15, 0, proto);
    return bv;
}


void npl_gre_encap_data_t::unpack(bit_vector64_t bv) 
{
    flag_res_version = bv.bits(31, 16).get_value();
    proto = bv.bits(15, 0).get_value();
}



field_structure npl_gre_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_gre_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(flag_res_version);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("flag_res_version", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(proto);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("proto", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_gre_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_gre_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_hw_mp_table_app_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 14, lm_count_phase_lsb);
    bv.set_bits(13, 11, lm_period);
    bv.set_bits(10, 0, ccm_count_phase_msb);
    return bv;
}


void npl_hw_mp_table_app_t::unpack(bit_vector64_t bv) 
{
    lm_count_phase_lsb = bv.bits(15, 14).get_value();
    lm_period = bv.bits(13, 11).get_value();
    ccm_count_phase_msb = bv.bits(10, 0).get_value();
}



field_structure npl_hw_mp_table_app_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_hw_mp_table_app_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lm_count_phase_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lm_count_phase_lsb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lm_period);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lm_period", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ccm_count_phase_msb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ccm_count_phase_msb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_hw_mp_table_app_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_hw_mp_table_app_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ibm_cmd_table_result_t_anonymous_union_voq_or_bitmap_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (base_voq != 0) {  // union primitive field start
        bv.set_bits(15, 0, base_voq);
        return bv;
    }// union primitive field end
    
    if (mc_bitmap != 0) {  // union primitive field start
        bv.set_bits(5, 0, mc_bitmap);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ibm_cmd_table_result_t_anonymous_union_voq_or_bitmap_t::unpack(bit_vector64_t bv) // union
{
    base_voq = bv.bits(15, 0).get_value();
}



field_structure npl_ibm_cmd_table_result_t_anonymous_union_voq_or_bitmap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ibm_cmd_table_result_t_anonymous_union_voq_or_bitmap_t";
    field_structure fs_subfield;
    //add members to result
    if (base_voq != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(base_voq);
        return union_found;
    }// union primitive field end
    
    if (mc_bitmap != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mc_bitmap);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ibm_cmd_table_result_t_anonymous_union_voq_or_bitmap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ibm_cmd_table_result_t_anonymous_union_voq_or_bitmap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_ibm_enables_table_result_t::pack(void) const 
{
    bit_vector192_t bv(0, 159);
    bv.set_bits(158, 145, ibm_partial_mirror_packet_size);
    bv.set_bits(144, 113, ibm_partial_mirror_en);
    bv.set_bits(112, 81, ibm_enable_ive);
    bv.set_bits(80, 49, ibm_enable_hw_termination);
    bv.set_bits(48, 9, cud_ibm_offset);
    bv.set_bits(8, 0, cud_has_ibm);
    return bv;
}


void npl_ibm_enables_table_result_t::unpack(bit_vector192_t bv) 
{
    ibm_partial_mirror_packet_size = bv.bits(158, 145).get_value();
    ibm_partial_mirror_en = bv.bits(144, 113).get_value();
    ibm_enable_ive = bv.bits(112, 81).get_value();
    ibm_enable_hw_termination = bv.bits(80, 49).get_value();
    cud_ibm_offset = bv.bits(48, 9).get_value();
    cud_has_ibm = bv.bits(8, 0).get_value();
}



field_structure npl_ibm_enables_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ibm_enables_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ibm_partial_mirror_packet_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ibm_partial_mirror_packet_size", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ibm_partial_mirror_en);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ibm_partial_mirror_en", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ibm_enable_ive);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ibm_enable_ive", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ibm_enable_hw_termination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ibm_enable_hw_termination", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cud_ibm_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cud_ibm_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cud_has_ibm);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cud_has_ibm", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ibm_enables_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ibm_enables_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_icmp_type_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, type);
    bv.set_bits(7, 0, code);
    return bv;
}


void npl_icmp_type_code_t::unpack(bit_vector64_t bv) 
{
    type = bv.bits(15, 8).get_value();
    code = bv.bits(7, 0).get_value();
}



field_structure npl_icmp_type_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_icmp_type_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("code", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_icmp_type_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_icmp_type_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ifg_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, value);
    return bv;
}


void npl_ifg_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(0, 0).get_value();
}



field_structure npl_ifg_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ifg_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ifg_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ifg_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ifg_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, index);
    return bv;
}


void npl_ifg_t::unpack(bit_vector64_t bv) 
{
    index = bv.bits(0, 0).get_value();
}



field_structure npl_ifg_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ifg_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("index", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ifg_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ifg_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ifgb_tc_lut_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 5, use_lut);
    bv.set_bits(4, 0, data);
    return bv;
}


void npl_ifgb_tc_lut_results_t::unpack(bit_vector64_t bv) 
{
    use_lut = bv.bits(5, 5).get_value();
    data = bv.bits(4, 0).get_value();
}



field_structure npl_ifgb_tc_lut_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ifgb_tc_lut_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(use_lut);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("use_lut", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("data", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ifgb_tc_lut_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ifgb_tc_lut_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_lpts_og_app_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    // PADDING -  bv.set_bits(4, 4, padding);
    bv.set_bits(3, 0, lpts_og_app_id);
    return bv;
}


void npl_ingress_lpts_og_app_data_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(4, 4).get_value();
    lpts_og_app_id = bv.bits(3, 0).get_value();
}



field_structure npl_ingress_lpts_og_app_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_lpts_og_app_data_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(lpts_og_app_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpts_og_app_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ingress_lpts_og_app_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_lpts_og_app_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_ptp_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 1, ptp_transport_type);
    bv.set_bits(0, 0, is_ptp_trans_sup);
    return bv;
}


void npl_ingress_ptp_info_t::unpack(bit_vector64_t bv) 
{
    ptp_transport_type = (npl_ptp_transport_type_e)bv.bits(2, 1).get_value();
    is_ptp_trans_sup = bv.bits(0, 0).get_value();
}



field_structure npl_ingress_ptp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_ptp_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ptp_transport_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ptp_transport_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_ptp_trans_sup);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_ptp_trans_sup", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ingress_ptp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_ptp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_mapping_remark_t::pack(void) const 
{
    bit_vector64_t bv(0, 19);
    bv.set_bits(18, 12, qos_group);
    bv.set_bits(11, 8, encap_mpls_exp.pack());
    bv.set_bits(7, 7, enable_ingress_remark);
    bv.set_bits(6, 0, fwd_qos_tag);
    return bv;
}


void npl_ingress_qos_mapping_remark_t::unpack(bit_vector64_t bv) 
{
    qos_group = bv.bits(18, 12).get_value();
    encap_mpls_exp.unpack(bv.bits(11, 8));
    enable_ingress_remark = bv.bits(7, 7).get_value();
    fwd_qos_tag = bv.bits(6, 0).get_value();
}



field_structure npl_ingress_qos_mapping_remark_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_mapping_remark_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_group", fs_subfield);
    
    fs_result.subfields.emplace_back("encap_mpls_exp", encap_mpls_exp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(enable_ingress_remark);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_ingress_remark", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fwd_qos_tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_qos_tag", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_mapping_remark_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_mapping_remark_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_remark_t_anonymous_union_encap_qos_tag_u_t::pack(void) const // union
{
    bit_vector64_t bv(0, 7);
    if (encap_qos_tag != 0) {  // union primitive field start
        bv.set_bits(6, 0, encap_qos_tag);
        return bv;
    }// union primitive field end
    
    if (in_mpls_exp != 0) {  // union primitive field start
        bv.set_bits(3, 0, in_mpls_exp);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ingress_qos_remark_t_anonymous_union_encap_qos_tag_u_t::unpack(bit_vector64_t bv) // union
{
    encap_qos_tag = bv.bits(6, 0).get_value();
}



field_structure npl_ingress_qos_remark_t_anonymous_union_encap_qos_tag_u_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_remark_t_anonymous_union_encap_qos_tag_u_t";
    field_structure fs_subfield;
    //add members to result
    if (encap_qos_tag != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(encap_qos_tag);
        return union_found;
    }// union primitive field end
    
    if (in_mpls_exp != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(in_mpls_exp);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_remark_t_anonymous_union_encap_qos_tag_u_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_remark_t_anonymous_union_encap_qos_tag_u_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_result_t_anonymous_union_fwd_class_qos_group_u_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    { // union compound field start
        bit_vector64_t tbv = fwd_class_qos_group.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (qos_group_pd != 0) {  // union primitive field start
        bv.set_bits(6, 0, qos_group_pd);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ingress_qos_result_t_anonymous_union_fwd_class_qos_group_u_t::unpack(bit_vector64_t bv) // union
{
    fwd_class_qos_group.unpack(bv.bits(7, 0));
}



field_structure npl_ingress_qos_result_t_anonymous_union_fwd_class_qos_group_u_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_result_t_anonymous_union_fwd_class_qos_group_u_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = fwd_class_qos_group.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("fwd_class_qos_group", fwd_class_qos_group.to_field_structure());
        }
    } // union compound field end
    
    if (qos_group_pd != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(qos_group_pd);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_result_t_anonymous_union_fwd_class_qos_group_u_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_result_t_anonymous_union_fwd_class_qos_group_u_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_initial_pd_nw_rx_data_t_anonymous_union_init_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (initial_npp_attributes_index != 0) {  // union primitive field start
        bv.set_bits(7, 0, initial_npp_attributes_index);
        return bv;
    }// union primitive field end
    
    if (initial_slice_id != 0) {  // union primitive field start
        bv.set_bits(2, 0, initial_slice_id);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_initial_pd_nw_rx_data_t_anonymous_union_init_data_t::unpack(bit_vector64_t bv) // union
{
    initial_npp_attributes_index = bv.bits(7, 0).get_value();
}



field_structure npl_initial_pd_nw_rx_data_t_anonymous_union_init_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_initial_pd_nw_rx_data_t_anonymous_union_init_data_t";
    field_structure fs_subfield;
    //add members to result
    if (initial_npp_attributes_index != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(initial_npp_attributes_index);
        return union_found;
    }// union primitive field end
    
    if (initial_slice_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(initial_slice_id);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_initial_pd_nw_rx_data_t_anonymous_union_init_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_initial_pd_nw_rx_data_t_anonymous_union_init_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_initial_recycle_pd_nw_rx_data_t_anonymous_union_init_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (initial_npp_attributes_index != 0) {  // union primitive field start
        bv.set_bits(7, 0, initial_npp_attributes_index);
        return bv;
    }// union primitive field end
    
    if (initial_slice_id != 0) {  // union primitive field start
        bv.set_bits(2, 0, initial_slice_id);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_initial_recycle_pd_nw_rx_data_t_anonymous_union_init_data_t::unpack(bit_vector64_t bv) // union
{
    initial_npp_attributes_index = bv.bits(7, 0).get_value();
}



field_structure npl_initial_recycle_pd_nw_rx_data_t_anonymous_union_init_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_initial_recycle_pd_nw_rx_data_t_anonymous_union_init_data_t";
    field_structure fs_subfield;
    //add members to result
    if (initial_npp_attributes_index != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(initial_npp_attributes_index);
        return union_found;
    }// union primitive field end
    
    if (initial_slice_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(initial_slice_id);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_initial_recycle_pd_nw_rx_data_t_anonymous_union_init_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_initial_recycle_pd_nw_rx_data_t_anonymous_union_init_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_header_type_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, inject_type);
    return bv;
}


void npl_inject_header_type_t::unpack(bit_vector64_t bv) 
{
    inject_type = (npl_inject_header_type_e)bv.bits(7, 0).get_value();
}



field_structure npl_inject_header_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_type_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(inject_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_header_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_source_if_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 7, inject_ifg);
    bv.set_bits(6, 2, inject_pif);
    // PADDING -  bv.set_bits(1, 0, padding);
    return bv;
}


void npl_inject_source_if_t::unpack(bit_vector64_t bv) 
{
    inject_ifg = bv.bits(7, 7).get_value();
    inject_pif = bv.bits(6, 2).get_value();
    // PADDING -  padding = bv.bits(1, 0).get_value();
}



field_structure npl_inject_source_if_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_source_if_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(inject_ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_ifg", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(inject_pif);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_pif", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_inject_source_if_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_source_if_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_destination_override_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    // PADDING -  bv.set_bits(23, 20, padding);
    bv.set_bits(19, 0, dest_override.pack());
    return bv;
}


void npl_inject_up_destination_override_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(23, 20).get_value();
    dest_override.unpack(bv.bits(19, 0));
}



field_structure npl_inject_up_destination_override_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_destination_override_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("dest_override", dest_override.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_up_destination_override_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_destination_override_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_eth_header_t_anonymous_union_from_port_t::pack(void) const // union
{
    bit_vector64_t bv(0, 12);
    if (up_ssp != 0) {  // union primitive field start
        bv.set_bits(11, 0, up_ssp);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = up_source_if.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(11, 4, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_up_eth_header_t_anonymous_union_from_port_t::unpack(bit_vector64_t bv) // union
{
    up_ssp = bv.bits(11, 0).get_value();
}



field_structure npl_inject_up_eth_header_t_anonymous_union_from_port_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_eth_header_t_anonymous_union_from_port_t";
    field_structure fs_subfield;
    //add members to result
    if (up_ssp != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(up_ssp);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = up_source_if.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("up_source_if", up_source_if.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_up_eth_header_t_anonymous_union_from_port_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_eth_header_t_anonymous_union_from_port_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_none_routable_mc_lpts_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, placeholder);
    return bv;
}


void npl_inject_up_none_routable_mc_lpts_t::unpack(bit_vector64_t bv) 
{
    placeholder = bv.bits(19, 0).get_value();
}



field_structure npl_inject_up_none_routable_mc_lpts_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_none_routable_mc_lpts_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(placeholder);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("placeholder", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_up_none_routable_mc_lpts_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_none_routable_mc_lpts_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_vxlan_mc_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 0, placeholder);
    return bv;
}


void npl_inject_up_vxlan_mc_t::unpack(bit_vector64_t bv) 
{
    placeholder = bv.bits(27, 0).get_value();
}



field_structure npl_inject_up_vxlan_mc_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_vxlan_mc_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(placeholder);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("placeholder", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_up_vxlan_mc_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_vxlan_mc_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_internal_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 4, l3_lpm_lpts);
    bv.set_bits(3, 3, ipv4_non_routable_mc_routing);
    bv.set_bits(2, 2, ipv4_non_routable_mc_bridging);
    bv.set_bits(1, 1, ipv6_non_routable_mc_routing);
    bv.set_bits(0, 0, ipv6_non_routable_mc_bridging);
    return bv;
}


void npl_internal_traps_t::unpack(bit_vector64_t bv) 
{
    l3_lpm_lpts = bv.bits(4, 4).get_value();
    ipv4_non_routable_mc_routing = bv.bits(3, 3).get_value();
    ipv4_non_routable_mc_bridging = bv.bits(2, 2).get_value();
    ipv6_non_routable_mc_routing = bv.bits(1, 1).get_value();
    ipv6_non_routable_mc_bridging = bv.bits(0, 0).get_value();
}



field_structure npl_internal_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_internal_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l3_lpm_lpts);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_lpm_lpts", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ipv4_non_routable_mc_routing);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv4_non_routable_mc_routing", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ipv4_non_routable_mc_bridging);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv4_non_routable_mc_bridging", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ipv6_non_routable_mc_routing);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_non_routable_mc_routing", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ipv6_non_routable_mc_bridging);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_non_routable_mc_bridging", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_internal_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_internal_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_lpm_result_t_anonymous_union_destination_or_default_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (is_default != 0) {  // union primitive field start
        bv.set_bits(19, 19, is_default);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ip_lpm_result_t_anonymous_union_destination_or_default_t::unpack(bit_vector64_t bv) // union
{
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_ip_lpm_result_t_anonymous_union_destination_or_default_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_lpm_result_t_anonymous_union_destination_or_default_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("destination", destination.to_field_structure());
        }
    } // union compound field end
    
    if (is_default != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(is_default);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ip_lpm_result_t_anonymous_union_destination_or_default_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_lpm_result_t_anonymous_union_destination_or_default_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_lpm_result_t_anonymous_union_rtype_or_is_fec_t::pack(void) const // union
{
    bit_vector64_t bv(0, 2);
    if (rtype != 0) {  // union primitive field start
        bv.set_bits(1, 0, rtype);
        return bv;
    }// union primitive field end
    
    if (is_fec != 0) {  // union primitive field start
        bv.set_bits(0, 0, is_fec);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ip_lpm_result_t_anonymous_union_rtype_or_is_fec_t::unpack(bit_vector64_t bv) // union
{
    rtype = bv.bits(1, 0).get_value();
}



field_structure npl_ip_lpm_result_t_anonymous_union_rtype_or_is_fec_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_lpm_result_t_anonymous_union_rtype_or_is_fec_t";
    field_structure fs_subfield;
    //add members to result
    if (rtype != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(rtype);
        return union_found;
    }// union primitive field end
    
    if (is_fec != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(is_fec);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ip_lpm_result_t_anonymous_union_rtype_or_is_fec_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_lpm_result_t_anonymous_union_rtype_or_is_fec_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_prefix_destination_compound_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 4, ip_prefix_destination.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_ip_prefix_destination_compound_results_t::unpack(bit_vector64_t bv) 
{
    ip_prefix_destination.unpack(bv.bits(23, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_ip_prefix_destination_compound_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_prefix_destination_compound_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ip_prefix_destination", ip_prefix_destination.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_ip_prefix_destination_compound_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_prefix_destination_compound_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_relay_egress_qos_key_pack_table_load_t::pack(void) const 
{
    bit_vector64_t bv(0, 44);
    // PADDING -  bv.set_bits(43, 43, padding);
    bv.set_bits(42, 36, muxed_qos_group.pack());
    // PADDING -  bv.set_bits(35, 35, padding);
    bv.set_bits(34, 28, mapping_qos_fwd_qos_tag.pack());
    // PADDING -  bv.set_bits(27, 27, padding);
    bv.set_bits(26, 20, mapping_qos_pd_tag.pack());
    bv.set_bits(19, 0, zero_counter_ptr);
    return bv;
}


void npl_ip_relay_egress_qos_key_pack_table_load_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(43, 43).get_value();
    muxed_qos_group.unpack(bv.bits(42, 36));
    // PADDING -  padding = bv.bits(35, 35).get_value();
    mapping_qos_fwd_qos_tag.unpack(bv.bits(34, 28));
    // PADDING -  padding = bv.bits(27, 27).get_value();
    mapping_qos_pd_tag.unpack(bv.bits(26, 20));
    zero_counter_ptr = bv.bits(19, 0).get_value();
}



field_structure npl_ip_relay_egress_qos_key_pack_table_load_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_relay_egress_qos_key_pack_table_load_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("muxed_qos_group", muxed_qos_group.to_field_structure());
    
    fs_result.subfields.emplace_back("mapping_qos_fwd_qos_tag", mapping_qos_fwd_qos_tag.to_field_structure());
    
    fs_result.subfields.emplace_back("mapping_qos_pd_tag", mapping_qos_pd_tag.to_field_structure());
    fs_subfield.flat_value = to_hex_string(zero_counter_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("zero_counter_ptr", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_relay_egress_qos_key_pack_table_load_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_relay_egress_qos_key_pack_table_load_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_rtf_iter_prop_over_fwd0_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 7, table_index);
    bv.set_bits(6, 0, acl_id);
    return bv;
}


void npl_ip_rtf_iter_prop_over_fwd0_t::unpack(bit_vector64_t bv) 
{
    table_index = (npl_fwd0_table_index_e)bv.bits(9, 7).get_value();
    acl_id = bv.bits(6, 0).get_value();
}



field_structure npl_ip_rtf_iter_prop_over_fwd0_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_rtf_iter_prop_over_fwd0_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(table_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("table_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_rtf_iter_prop_over_fwd0_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_rtf_iter_prop_over_fwd0_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_rtf_iter_prop_over_fwd1_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 7, table_index);
    bv.set_bits(6, 0, acl_id);
    return bv;
}


void npl_ip_rtf_iter_prop_over_fwd1_t::unpack(bit_vector64_t bv) 
{
    table_index = (npl_fwd1_table_index_e)bv.bits(8, 7).get_value();
    acl_id = bv.bits(6, 0).get_value();
}



field_structure npl_ip_rtf_iter_prop_over_fwd1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_rtf_iter_prop_over_fwd1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(table_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("table_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_rtf_iter_prop_over_fwd1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_rtf_iter_prop_over_fwd1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_rx_global_counter_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, tunnel_transit_counter_p.pack());
    return bv;
}


void npl_ip_rx_global_counter_t::unpack(bit_vector64_t bv) 
{
    tunnel_transit_counter_p.unpack(bv.bits(19, 0));
}



field_structure npl_ip_rx_global_counter_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_rx_global_counter_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("tunnel_transit_counter_p", tunnel_transit_counter_p.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_rx_global_counter_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_rx_global_counter_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_sgt_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    // PADDING -  bv.set_bits(19, 17, padding);
    bv.set_bits(16, 16, valid_group);
    bv.set_bits(15, 0, security_group_tag);
    return bv;
}


void npl_ip_sgt_result_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(19, 17).get_value();
    valid_group = bv.bits(16, 16).get_value();
    security_group_tag = bv.bits(15, 0).get_value();
}



field_structure npl_ip_sgt_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_sgt_result_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(valid_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("valid_group", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(security_group_tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("security_group_tag", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_sgt_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_sgt_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_tunnel_dip_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    if (ipv6_dip_index != 0) {  // union primitive field start
        bv.set_bits(31, 20, ipv6_dip_index);
        return bv;
    }// union primitive field end
    
    if (ipv4_dip != 0) {  // union primitive field start
        bv.set_bits(31, 0, ipv4_dip);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ip_tunnel_dip_t::unpack(bit_vector64_t bv) // union
{
    ipv6_dip_index = bv.bits(31, 20).get_value();
}



field_structure npl_ip_tunnel_dip_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_tunnel_dip_t";
    field_structure fs_subfield;
    //add members to result
    if (ipv6_dip_index != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(ipv6_dip_index);
        return union_found;
    }// union primitive field end
    
    if (ipv4_dip != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(ipv4_dip);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ip_tunnel_dip_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_tunnel_dip_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_ver_and_post_fwd_stage_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, ip_ver);
    bv.set_bits(2, 0, post_fwd_rtf_stage);
    return bv;
}


void npl_ip_ver_and_post_fwd_stage_t::unpack(bit_vector64_t bv) 
{
    ip_ver = (npl_ip_version_e)bv.bits(3, 3).get_value();
    post_fwd_rtf_stage = (npl_rtf_stage_and_type_e)bv.bits(2, 0).get_value();
}



field_structure npl_ip_ver_and_post_fwd_stage_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_ver_and_post_fwd_stage_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ip_ver);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_ver", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(post_fwd_rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("post_fwd_rtf_stage", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_ver_and_post_fwd_stage_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_ver_and_post_fwd_stage_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_ver_mc_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, ip_version);
    bv.set_bits(0, 0, is_mc.pack());
    return bv;
}


void npl_ip_ver_mc_t::unpack(bit_vector64_t bv) 
{
    ip_version = (npl_ip_version_e)bv.bits(1, 1).get_value();
    is_mc.unpack(bv.bits(0, 0));
}



field_structure npl_ip_ver_mc_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_ver_mc_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ip_version);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_version", fs_subfield);
    
    fs_result.subfields.emplace_back("is_mc", is_mc.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_ver_mc_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_ver_mc_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv4_header_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, header_error);
    bv.set_bits(1, 1, fragmented);
    bv.set_bits(0, 0, checksum_error);
    return bv;
}


void npl_ipv4_header_flags_t::unpack(bit_vector64_t bv) 
{
    header_error = bv.bits(2, 2).get_value();
    fragmented = bv.bits(1, 1).get_value();
    checksum_error = bv.bits(0, 0).get_value();
}



field_structure npl_ipv4_header_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_header_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(header_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("header_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fragmented);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fragmented", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(checksum_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("checksum_error", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv4_header_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_header_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv4_ipv6_init_rtf_stage_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 2, ipv4_init_rtf_stage);
    bv.set_bits(1, 0, ipv6_init_rtf_stage);
    return bv;
}


void npl_ipv4_ipv6_init_rtf_stage_t::unpack(bit_vector64_t bv) 
{
    ipv4_init_rtf_stage = (npl_init_rtf_stage_and_type_e)bv.bits(3, 2).get_value();
    ipv6_init_rtf_stage = (npl_init_rtf_stage_and_type_e)bv.bits(1, 0).get_value();
}



field_structure npl_ipv4_ipv6_init_rtf_stage_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_ipv6_init_rtf_stage_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ipv4_init_rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv4_init_rtf_stage", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ipv6_init_rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_init_rtf_stage", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv4_ipv6_init_rtf_stage_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_ipv6_init_rtf_stage_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv4_sip_dip_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 32, sip);
    bv.set_bits(31, 0, dip);
    return bv;
}


void npl_ipv4_sip_dip_t::unpack(bit_vector64_t bv) 
{
    sip = bv.bits(63, 32).get_value();
    dip = bv.bits(31, 0).get_value();
}



field_structure npl_ipv4_sip_dip_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_sip_dip_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dip", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv4_sip_dip_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_sip_dip_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv4_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 6, mc_forwarding_disabled);
    bv.set_bits(5, 5, uc_forwarding_disabled);
    bv.set_bits(4, 4, checksum);
    bv.set_bits(3, 3, header_error);
    bv.set_bits(2, 2, unknown_protocol);
    bv.set_bits(1, 1, options_exist);
    bv.set_bits(0, 0, non_comp_mc);
    return bv;
}


void npl_ipv4_traps_t::unpack(bit_vector64_t bv) 
{
    mc_forwarding_disabled = bv.bits(6, 6).get_value();
    uc_forwarding_disabled = bv.bits(5, 5).get_value();
    checksum = bv.bits(4, 4).get_value();
    header_error = bv.bits(3, 3).get_value();
    unknown_protocol = bv.bits(2, 2).get_value();
    options_exist = bv.bits(1, 1).get_value();
    non_comp_mc = bv.bits(0, 0).get_value();
}



field_structure npl_ipv4_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mc_forwarding_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mc_forwarding_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(uc_forwarding_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("uc_forwarding_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(checksum);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("checksum", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(header_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("header_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_protocol);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_protocol", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(options_exist);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("options_exist", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(non_comp_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("non_comp_mc", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv4_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv4_ttl_and_protocol_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, ttl);
    bv.set_bits(7, 0, protocol);
    return bv;
}


void npl_ipv4_ttl_and_protocol_t::unpack(bit_vector64_t bv) 
{
    ttl = bv.bits(15, 8).get_value();
    protocol = bv.bits(7, 0).get_value();
}



field_structure npl_ipv4_ttl_and_protocol_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_ttl_and_protocol_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(protocol);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("protocol", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv4_ttl_and_protocol_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_ttl_and_protocol_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv6_header_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, header_error);
    bv.set_bits(1, 1, not_first_fragment);
    bv.set_bits(0, 0, next_header_check);
    return bv;
}


void npl_ipv6_header_flags_t::unpack(bit_vector64_t bv) 
{
    header_error = bv.bits(2, 2).get_value();
    not_first_fragment = bv.bits(1, 1).get_value();
    next_header_check = bv.bits(0, 0).get_value();
}



field_structure npl_ipv6_header_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv6_header_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(header_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("header_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(not_first_fragment);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("not_first_fragment", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_header_check);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_header_check", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv6_header_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv6_header_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv6_next_header_and_hop_limit_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, next_header);
    bv.set_bits(7, 0, hop_limit);
    return bv;
}


void npl_ipv6_next_header_and_hop_limit_t::unpack(bit_vector64_t bv) 
{
    next_header = bv.bits(15, 8).get_value();
    hop_limit = bv.bits(7, 0).get_value();
}



field_structure npl_ipv6_next_header_and_hop_limit_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv6_next_header_and_hop_limit_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(next_header);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_header", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(hop_limit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hop_limit", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv6_next_header_and_hop_limit_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv6_next_header_and_hop_limit_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv6_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 8, mc_forwarding_disabled);
    bv.set_bits(7, 7, uc_forwarding_disabled);
    bv.set_bits(6, 6, hop_by_hop);
    bv.set_bits(5, 5, header_error);
    bv.set_bits(4, 4, illegal_sip);
    bv.set_bits(3, 3, illegal_dip);
    bv.set_bits(2, 2, zero_payload);
    bv.set_bits(1, 1, next_header_check);
    bv.set_bits(0, 0, non_comp_mc);
    return bv;
}


void npl_ipv6_traps_t::unpack(bit_vector64_t bv) 
{
    mc_forwarding_disabled = bv.bits(8, 8).get_value();
    uc_forwarding_disabled = bv.bits(7, 7).get_value();
    hop_by_hop = bv.bits(6, 6).get_value();
    header_error = bv.bits(5, 5).get_value();
    illegal_sip = bv.bits(4, 4).get_value();
    illegal_dip = bv.bits(3, 3).get_value();
    zero_payload = bv.bits(2, 2).get_value();
    next_header_check = bv.bits(1, 1).get_value();
    non_comp_mc = bv.bits(0, 0).get_value();
}



field_structure npl_ipv6_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv6_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mc_forwarding_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mc_forwarding_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(uc_forwarding_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("uc_forwarding_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(hop_by_hop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hop_by_hop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(header_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("header_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(illegal_sip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("illegal_sip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(illegal_dip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("illegal_dip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(zero_payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("zero_payload", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_header_check);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_header_check", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(non_comp_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("non_comp_mc", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv6_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv6_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_is_inject_up_and_ip_first_fragment_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, is_inject_up_dest_override.pack());
    bv.set_bits(1, 1, is_inject_up.pack());
    bv.set_bits(0, 0, ip_first_fragment.pack());
    return bv;
}


void npl_is_inject_up_and_ip_first_fragment_t::unpack(bit_vector64_t bv) 
{
    is_inject_up_dest_override.unpack(bv.bits(2, 2));
    is_inject_up.unpack(bv.bits(1, 1));
    ip_first_fragment.unpack(bv.bits(0, 0));
}



field_structure npl_is_inject_up_and_ip_first_fragment_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_is_inject_up_and_ip_first_fragment_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("is_inject_up_dest_override", is_inject_up_dest_override.to_field_structure());
    fs_result.subfields.emplace_back("is_inject_up", is_inject_up.to_field_structure());
    fs_result.subfields.emplace_back("ip_first_fragment", ip_first_fragment.to_field_structure());
    return fs_result;
}
std::string to_string(npl_is_inject_up_and_ip_first_fragment_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_is_inject_up_and_ip_first_fragment_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ive_enable_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, enable);
    return bv;
}


void npl_ive_enable_t::unpack(bit_vector64_t bv) 
{
    enable = bv.bits(0, 0).get_value();
}



field_structure npl_ive_enable_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ive_enable_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ive_enable_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ive_enable_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_dlp_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 0, id);
    return bv;
}


void npl_l2_dlp_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(17, 0).get_value();
}



field_structure npl_l2_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_dlp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_global_slp_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    // PADDING -  bv.set_bits(19, 18, padding);
    bv.set_bits(17, 0, id);
    return bv;
}


void npl_l2_global_slp_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(19, 18).get_value();
    id = bv.bits(17, 0).get_value();
}



field_structure npl_l2_global_slp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_global_slp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_global_slp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_global_slp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_lpts_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, mac_terminated);
    return bv;
}


void npl_l2_lpts_attributes_t::unpack(bit_vector64_t bv) 
{
    mac_terminated = bv.bits(0, 0).get_value();
}



field_structure npl_l2_lpts_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lpts_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mac_terminated);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_terminated", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_lpts_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lpts_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_lpts_ip_fragment_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, v6_not_first_fragment);
    bv.set_bits(0, 0, v4_not_first_fragment);
    return bv;
}


void npl_l2_lpts_ip_fragment_t::unpack(bit_vector64_t bv) 
{
    v6_not_first_fragment = bv.bits(1, 1).get_value();
    v4_not_first_fragment = bv.bits(0, 0).get_value();
}



field_structure npl_l2_lpts_ip_fragment_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lpts_ip_fragment_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(v6_not_first_fragment);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("v6_not_first_fragment", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(v4_not_first_fragment);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("v4_not_first_fragment", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_lpts_ip_fragment_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lpts_ip_fragment_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_lpts_next_macro_pack_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, l2_lpts);
    return bv;
}


void npl_l2_lpts_next_macro_pack_fields_t::unpack(bit_vector64_t bv) 
{
    l2_lpts = bv.bits(1, 0).get_value();
}



field_structure npl_l2_lpts_next_macro_pack_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lpts_next_macro_pack_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l2_lpts);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_lpts", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_lpts_next_macro_pack_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lpts_next_macro_pack_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_lpts_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 11, trap0);
    bv.set_bits(10, 10, trap1);
    bv.set_bits(9, 9, trap2);
    bv.set_bits(8, 8, trap3);
    bv.set_bits(7, 7, trap4);
    bv.set_bits(6, 6, trap5);
    bv.set_bits(5, 5, trap6);
    bv.set_bits(4, 4, trap7);
    bv.set_bits(3, 3, trap8);
    bv.set_bits(2, 2, trap9);
    bv.set_bits(1, 1, trap10);
    bv.set_bits(0, 0, trap11);
    return bv;
}


void npl_l2_lpts_traps_t::unpack(bit_vector64_t bv) 
{
    trap0 = bv.bits(11, 11).get_value();
    trap1 = bv.bits(10, 10).get_value();
    trap2 = bv.bits(9, 9).get_value();
    trap3 = bv.bits(8, 8).get_value();
    trap4 = bv.bits(7, 7).get_value();
    trap5 = bv.bits(6, 6).get_value();
    trap6 = bv.bits(5, 5).get_value();
    trap7 = bv.bits(4, 4).get_value();
    trap8 = bv.bits(3, 3).get_value();
    trap9 = bv.bits(2, 2).get_value();
    trap10 = bv.bits(1, 1).get_value();
    trap11 = bv.bits(0, 0).get_value();
}



field_structure npl_l2_lpts_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lpts_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(trap0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap5);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap5", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap7);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap7", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap8);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap8", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap9);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap9", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap10);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap10", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(trap11);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("trap11", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_lpts_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lpts_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_relay_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 0, id);
    return bv;
}


void npl_l2_relay_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(13, 0).get_value();
}



field_structure npl_l2_relay_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_relay_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_relay_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_relay_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2vpn_control_bits_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, enable_pwe_cntr);
    bv.set_bits(2, 2, no_fat);
    bv.set_bits(1, 0, cw_fat_exists);
    return bv;
}


void npl_l2vpn_control_bits_t::unpack(bit_vector64_t bv) 
{
    enable_pwe_cntr = bv.bits(3, 3).get_value();
    no_fat = bv.bits(2, 2).get_value();
    cw_fat_exists = (npl_l2vpn_cw_fat_exists_e)bv.bits(1, 0).get_value();
}



field_structure npl_l2vpn_control_bits_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2vpn_control_bits_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable_pwe_cntr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_pwe_cntr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_fat);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_fat", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(cw_fat_exists);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cw_fat_exists", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2vpn_control_bits_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2vpn_control_bits_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_l2vpn_label_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 76);
    bv.set_bits(75, 56, pwe_encap_cntr.pack());
    // PADDING -  bv.set_bits(55, 54, padding);
    bv.set_bits(53, 52, lp_profile);
    bv.set_bits(51, 44, first_ene_macro.pack());
    bv.set_bits(43, 24, pwe_l2_dlp_id);
    bv.set_bits(23, 20, l2vpn_control_bits.pack());
    bv.set_bits(19, 0, label);
    return bv;
}


void npl_l2vpn_label_encap_data_t::unpack(bit_vector128_t bv) 
{
    pwe_encap_cntr.unpack(bv.bits(75, 56));
    // PADDING -  padding = bv.bits(55, 54).get_value();
    lp_profile = bv.bits(53, 52).get_value();
    first_ene_macro.unpack(bv.bits(51, 44));
    pwe_l2_dlp_id = bv.bits(43, 24).get_value();
    l2vpn_control_bits.unpack(bv.bits(23, 20));
    label = bv.bits(19, 0).get_value();
}



field_structure npl_l2vpn_label_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2vpn_label_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("pwe_encap_cntr", pwe_encap_cntr.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(lp_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_profile", fs_subfield);
    
    fs_result.subfields.emplace_back("first_ene_macro", first_ene_macro.to_field_structure());
    fs_subfield.flat_value = to_hex_string(pwe_l2_dlp_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pwe_l2_dlp_id", fs_subfield);
    
    fs_result.subfields.emplace_back("l2vpn_control_bits", l2vpn_control_bits.to_field_structure());
    fs_subfield.flat_value = to_hex_string(label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2vpn_label_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2vpn_label_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_dlp_lsbs_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, l3_dlp_lsbs);
    return bv;
}


void npl_l3_dlp_lsbs_t::unpack(bit_vector64_t bv) 
{
    l3_dlp_lsbs = bv.bits(11, 0).get_value();
}



field_structure npl_l3_dlp_lsbs_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_lsbs_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l3_dlp_lsbs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_dlp_lsbs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_dlp_lsbs_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_lsbs_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_dlp_msbs_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, l3_dlp_msbs);
    return bv;
}


void npl_l3_dlp_msbs_t::unpack(bit_vector64_t bv) 
{
    l3_dlp_msbs = bv.bits(1, 0).get_value();
}



field_structure npl_l3_dlp_msbs_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_msbs_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l3_dlp_msbs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_dlp_msbs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_dlp_msbs_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_msbs_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_ecn_ctrl_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, count_cong_pkt);
    bv.set_bits(0, 0, disable_ecn);
    return bv;
}


void npl_l3_ecn_ctrl_t::unpack(bit_vector64_t bv) 
{
    count_cong_pkt = bv.bits(1, 1).get_value();
    disable_ecn = bv.bits(0, 0).get_value();
}



field_structure npl_l3_ecn_ctrl_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_ecn_ctrl_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(count_cong_pkt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("count_cong_pkt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(disable_ecn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disable_ecn", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_ecn_ctrl_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_ecn_ctrl_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_pfc_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 15);
    bv.set_bits(14, 12, tc);
    bv.set_bits(11, 0, dsp);
    return bv;
}


void npl_l3_pfc_data_t::unpack(bit_vector64_t bv) 
{
    tc = bv.bits(14, 12).get_value();
    dsp = bv.bits(11, 0).get_value();
}



field_structure npl_l3_pfc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_pfc_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_pfc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_pfc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_relay_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, id);
    return bv;
}


void npl_l3_relay_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(11, 0).get_value();
}



field_structure npl_l3_relay_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_relay_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_relay_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_relay_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_slp_lsbs_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, l3_slp_lsbs);
    return bv;
}


void npl_l3_slp_lsbs_t::unpack(bit_vector64_t bv) 
{
    l3_slp_lsbs = bv.bits(11, 0).get_value();
}



field_structure npl_l3_slp_lsbs_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_slp_lsbs_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l3_slp_lsbs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_slp_lsbs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_slp_lsbs_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_slp_lsbs_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_slp_msbs_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, l3_slp_msbs);
    return bv;
}


void npl_l3_slp_msbs_t::unpack(bit_vector64_t bv) 
{
    l3_slp_msbs = bv.bits(1, 0).get_value();
}



field_structure npl_l3_slp_msbs_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_slp_msbs_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l3_slp_msbs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_slp_msbs", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_slp_msbs_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_slp_msbs_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 53);
    bv.set_bits(52, 52, ip_unicast_rpf);
    bv.set_bits(51, 51, ip_multicast_rpf);
    bv.set_bits(50, 50, ip_mc_drop);
    bv.set_bits(49, 49, ip_mc_punt_dc_pass);
    bv.set_bits(48, 48, ip_mc_snoop_dc_pass);
    bv.set_bits(47, 47, ip_mc_snoop_rpf_fail);
    bv.set_bits(46, 46, ip_mc_punt_rpf_fail);
    bv.set_bits(45, 45, ip_mc_snoop_lookup_miss);
    bv.set_bits(44, 44, ip_multicast_not_found);
    bv.set_bits(43, 43, ip_mc_s_g_punt_member);
    bv.set_bits(42, 42, ip_mc_g_punt_member);
    bv.set_bits(41, 41, ip_mc_egress_punt);
    bv.set_bits(40, 40, isis_over_l3);
    bv.set_bits(39, 39, isis_drain);
    bv.set_bits(38, 38, no_hbm_access_dip);
    bv.set_bits(37, 37, no_hbm_access_sip);
    bv.set_bits(36, 36, lpm_error);
    bv.set_bits(35, 35, lpm_drop);
    bv.set_bits(34, 34, local_subnet);
    bv.set_bits(33, 33, icmp_redirect);
    bv.set_bits(32, 32, no_lp_over_lag_mapping);
    bv.set_bits(31, 31, ingress_monitor);
    bv.set_bits(30, 30, egress_monitor);
    bv.set_bits(29, 29, acl_drop);
    bv.set_bits(28, 28, acl_force_punt);
    bv.set_bits(27, 27, acl_force_punt1);
    bv.set_bits(26, 26, acl_force_punt2);
    bv.set_bits(25, 25, acl_force_punt3);
    bv.set_bits(24, 24, acl_force_punt4);
    bv.set_bits(23, 23, acl_force_punt5);
    bv.set_bits(22, 22, acl_force_punt6);
    bv.set_bits(21, 21, acl_force_punt7);
    bv.set_bits(20, 20, glean_adj);
    bv.set_bits(19, 19, drop_adj);
    bv.set_bits(18, 18, drop_adj_non_inject);
    bv.set_bits(17, 17, null_adj);
    bv.set_bits(16, 16, user_trap1);
    bv.set_bits(15, 15, user_trap2);
    bv.set_bits(14, 14, lpm_default_drop);
    bv.set_bits(13, 13, lpm_incomplete0);
    bv.set_bits(12, 12, lpm_incomplete2);
    bv.set_bits(11, 11, bfd_micro_ip_disabled);
    bv.set_bits(10, 10, no_vni_mapping);
    bv.set_bits(9, 9, no_hbm_access_og_sip);
    bv.set_bits(8, 8, no_hbm_access_og_dip);
    bv.set_bits(7, 7, no_l3_dlp_mapping);
    bv.set_bits(6, 6, l3_dlp_disabled);
    bv.set_bits(5, 5, split_horizon);
    bv.set_bits(4, 4, mc_same_interface);
    bv.set_bits(3, 3, no_vpn_label_found);
    bv.set_bits(2, 2, ttl_or_hop_limit_is_one);
    bv.set_bits(1, 1, tx_mtu_failure);
    bv.set_bits(0, 0, tx_frr_drop);
    return bv;
}


void npl_l3_traps_t::unpack(bit_vector64_t bv) 
{
    ip_unicast_rpf = bv.bits(52, 52).get_value();
    ip_multicast_rpf = bv.bits(51, 51).get_value();
    ip_mc_drop = bv.bits(50, 50).get_value();
    ip_mc_punt_dc_pass = bv.bits(49, 49).get_value();
    ip_mc_snoop_dc_pass = bv.bits(48, 48).get_value();
    ip_mc_snoop_rpf_fail = bv.bits(47, 47).get_value();
    ip_mc_punt_rpf_fail = bv.bits(46, 46).get_value();
    ip_mc_snoop_lookup_miss = bv.bits(45, 45).get_value();
    ip_multicast_not_found = bv.bits(44, 44).get_value();
    ip_mc_s_g_punt_member = bv.bits(43, 43).get_value();
    ip_mc_g_punt_member = bv.bits(42, 42).get_value();
    ip_mc_egress_punt = bv.bits(41, 41).get_value();
    isis_over_l3 = bv.bits(40, 40).get_value();
    isis_drain = bv.bits(39, 39).get_value();
    no_hbm_access_dip = bv.bits(38, 38).get_value();
    no_hbm_access_sip = bv.bits(37, 37).get_value();
    lpm_error = bv.bits(36, 36).get_value();
    lpm_drop = bv.bits(35, 35).get_value();
    local_subnet = bv.bits(34, 34).get_value();
    icmp_redirect = bv.bits(33, 33).get_value();
    no_lp_over_lag_mapping = bv.bits(32, 32).get_value();
    ingress_monitor = bv.bits(31, 31).get_value();
    egress_monitor = bv.bits(30, 30).get_value();
    acl_drop = bv.bits(29, 29).get_value();
    acl_force_punt = bv.bits(28, 28).get_value();
    acl_force_punt1 = bv.bits(27, 27).get_value();
    acl_force_punt2 = bv.bits(26, 26).get_value();
    acl_force_punt3 = bv.bits(25, 25).get_value();
    acl_force_punt4 = bv.bits(24, 24).get_value();
    acl_force_punt5 = bv.bits(23, 23).get_value();
    acl_force_punt6 = bv.bits(22, 22).get_value();
    acl_force_punt7 = bv.bits(21, 21).get_value();
    glean_adj = bv.bits(20, 20).get_value();
    drop_adj = bv.bits(19, 19).get_value();
    drop_adj_non_inject = bv.bits(18, 18).get_value();
    null_adj = bv.bits(17, 17).get_value();
    user_trap1 = bv.bits(16, 16).get_value();
    user_trap2 = bv.bits(15, 15).get_value();
    lpm_default_drop = bv.bits(14, 14).get_value();
    lpm_incomplete0 = bv.bits(13, 13).get_value();
    lpm_incomplete2 = bv.bits(12, 12).get_value();
    bfd_micro_ip_disabled = bv.bits(11, 11).get_value();
    no_vni_mapping = bv.bits(10, 10).get_value();
    no_hbm_access_og_sip = bv.bits(9, 9).get_value();
    no_hbm_access_og_dip = bv.bits(8, 8).get_value();
    no_l3_dlp_mapping = bv.bits(7, 7).get_value();
    l3_dlp_disabled = bv.bits(6, 6).get_value();
    split_horizon = bv.bits(5, 5).get_value();
    mc_same_interface = bv.bits(4, 4).get_value();
    no_vpn_label_found = bv.bits(3, 3).get_value();
    ttl_or_hop_limit_is_one = bv.bits(2, 2).get_value();
    tx_mtu_failure = bv.bits(1, 1).get_value();
    tx_frr_drop = bv.bits(0, 0).get_value();
}



field_structure npl_l3_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ip_unicast_rpf);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_unicast_rpf", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_multicast_rpf);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_multicast_rpf", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_punt_dc_pass);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_punt_dc_pass", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_snoop_dc_pass);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_snoop_dc_pass", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_snoop_rpf_fail);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_snoop_rpf_fail", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_punt_rpf_fail);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_punt_rpf_fail", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_snoop_lookup_miss);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_snoop_lookup_miss", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_multicast_not_found);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_multicast_not_found", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_s_g_punt_member);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_s_g_punt_member", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_g_punt_member);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_g_punt_member", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ip_mc_egress_punt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_mc_egress_punt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(isis_over_l3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("isis_over_l3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(isis_drain);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("isis_drain", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access_dip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access_dip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access_sip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access_sip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpm_error);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpm_error", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpm_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpm_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(local_subnet);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("local_subnet", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(icmp_redirect);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("icmp_redirect", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_lp_over_lag_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_lp_over_lag_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ingress_monitor);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ingress_monitor", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(egress_monitor);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("egress_monitor", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt5);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt5", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_force_punt7);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_force_punt7", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(glean_adj);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("glean_adj", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop_adj);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_adj", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop_adj_non_inject);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_adj_non_inject", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(null_adj);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("null_adj", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(user_trap1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("user_trap1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(user_trap2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("user_trap2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpm_default_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpm_default_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpm_incomplete0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpm_incomplete0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpm_incomplete2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpm_incomplete2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_micro_ip_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_micro_ip_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_vni_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_vni_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access_og_sip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access_og_sip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access_og_dip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access_og_dip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_l3_dlp_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_l3_dlp_mapping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_dlp_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_dlp_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(split_horizon);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("split_horizon", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mc_same_interface);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mc_same_interface", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_vpn_label_found);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_vpn_label_found", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ttl_or_hop_limit_is_one);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl_or_hop_limit_is_one", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tx_mtu_failure);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tx_mtu_failure", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tx_frr_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tx_frr_drop", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l4_ports_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, src_port);
    bv.set_bits(15, 0, dst_port);
    return bv;
}


void npl_l4_ports_header_t::unpack(bit_vector64_t bv) 
{
    src_port = bv.bits(31, 16).get_value();
    dst_port = bv.bits(15, 0).get_value();
}



field_structure npl_l4_ports_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l4_ports_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(src_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("src_port", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dst_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dst_port", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l4_ports_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l4_ports_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_large_em_label_encap_data_and_counter_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 45);
    bv.set_bits(44, 44, num_labels);
    bv.set_bits(43, 20, label_encap.pack());
    bv.set_bits(19, 0, counter_ptr.pack());
    return bv;
}


void npl_large_em_label_encap_data_and_counter_ptr_t::unpack(bit_vector64_t bv) 
{
    num_labels = bv.bits(44, 44).get_value();
    label_encap.unpack(bv.bits(43, 20));
    counter_ptr.unpack(bv.bits(19, 0));
}



field_structure npl_large_em_label_encap_data_and_counter_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_large_em_label_encap_data_and_counter_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(num_labels);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_labels", fs_subfield);
    
    fs_result.subfields.emplace_back("label_encap", label_encap.to_field_structure());
    fs_result.subfields.emplace_back("counter_ptr", counter_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_large_em_label_encap_data_and_counter_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_large_em_label_encap_data_and_counter_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lb_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, value);
    return bv;
}


void npl_lb_key_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(15, 0).get_value();
}



field_structure npl_lb_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lb_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lb_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lb_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_learn_manager_cfg_max_learn_type_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, lr_type);
    return bv;
}


void npl_learn_manager_cfg_max_learn_type_t::unpack(bit_vector64_t bv) 
{
    lr_type = (npl_system_local_learn_type_e)bv.bits(1, 0).get_value();
}



field_structure npl_learn_manager_cfg_max_learn_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_learn_manager_cfg_max_learn_type_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(lr_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lr_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_learn_manager_cfg_max_learn_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_learn_manager_cfg_max_learn_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_light_fi_stage_cfg_t::pack(void) const 
{
    bit_vector64_t bv(0, 21);
    bv.set_bits(20, 20, update_protocol_is_layer);
    bv.set_bits(19, 19, update_current_header_info);
    bv.set_bits(18, 15, size_width);
    bv.set_bits(14, 9, size_offset);
    bv.set_bits(8, 6, next_protocol_or_type_width);
    bv.set_bits(5, 0, next_protocol_or_type_offset);
    return bv;
}


void npl_light_fi_stage_cfg_t::unpack(bit_vector64_t bv) 
{
    update_protocol_is_layer = bv.bits(20, 20).get_value();
    update_current_header_info = bv.bits(19, 19).get_value();
    size_width = bv.bits(18, 15).get_value();
    size_offset = bv.bits(14, 9).get_value();
    next_protocol_or_type_width = bv.bits(8, 6).get_value();
    next_protocol_or_type_offset = bv.bits(5, 0).get_value();
}



field_structure npl_light_fi_stage_cfg_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_light_fi_stage_cfg_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(update_protocol_is_layer);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_protocol_is_layer", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(update_current_header_info);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_current_header_info", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(size_width);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("size_width", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(size_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("size_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_protocol_or_type_width);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_protocol_or_type_width", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_protocol_or_type_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_protocol_or_type_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_light_fi_stage_cfg_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_light_fi_stage_cfg_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_link_up_vector_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 108);
    bv.set_bits(107, 107, link_up[107]);
    bv.set_bits(106, 106, link_up[106]);
    bv.set_bits(105, 105, link_up[105]);
    bv.set_bits(104, 104, link_up[104]);
    bv.set_bits(103, 103, link_up[103]);
    bv.set_bits(102, 102, link_up[102]);
    bv.set_bits(101, 101, link_up[101]);
    bv.set_bits(100, 100, link_up[100]);
    bv.set_bits(99, 99, link_up[99]);
    bv.set_bits(98, 98, link_up[98]);
    bv.set_bits(97, 97, link_up[97]);
    bv.set_bits(96, 96, link_up[96]);
    bv.set_bits(95, 95, link_up[95]);
    bv.set_bits(94, 94, link_up[94]);
    bv.set_bits(93, 93, link_up[93]);
    bv.set_bits(92, 92, link_up[92]);
    bv.set_bits(91, 91, link_up[91]);
    bv.set_bits(90, 90, link_up[90]);
    bv.set_bits(89, 89, link_up[89]);
    bv.set_bits(88, 88, link_up[88]);
    bv.set_bits(87, 87, link_up[87]);
    bv.set_bits(86, 86, link_up[86]);
    bv.set_bits(85, 85, link_up[85]);
    bv.set_bits(84, 84, link_up[84]);
    bv.set_bits(83, 83, link_up[83]);
    bv.set_bits(82, 82, link_up[82]);
    bv.set_bits(81, 81, link_up[81]);
    bv.set_bits(80, 80, link_up[80]);
    bv.set_bits(79, 79, link_up[79]);
    bv.set_bits(78, 78, link_up[78]);
    bv.set_bits(77, 77, link_up[77]);
    bv.set_bits(76, 76, link_up[76]);
    bv.set_bits(75, 75, link_up[75]);
    bv.set_bits(74, 74, link_up[74]);
    bv.set_bits(73, 73, link_up[73]);
    bv.set_bits(72, 72, link_up[72]);
    bv.set_bits(71, 71, link_up[71]);
    bv.set_bits(70, 70, link_up[70]);
    bv.set_bits(69, 69, link_up[69]);
    bv.set_bits(68, 68, link_up[68]);
    bv.set_bits(67, 67, link_up[67]);
    bv.set_bits(66, 66, link_up[66]);
    bv.set_bits(65, 65, link_up[65]);
    bv.set_bits(64, 64, link_up[64]);
    bv.set_bits(63, 63, link_up[63]);
    bv.set_bits(62, 62, link_up[62]);
    bv.set_bits(61, 61, link_up[61]);
    bv.set_bits(60, 60, link_up[60]);
    bv.set_bits(59, 59, link_up[59]);
    bv.set_bits(58, 58, link_up[58]);
    bv.set_bits(57, 57, link_up[57]);
    bv.set_bits(56, 56, link_up[56]);
    bv.set_bits(55, 55, link_up[55]);
    bv.set_bits(54, 54, link_up[54]);
    bv.set_bits(53, 53, link_up[53]);
    bv.set_bits(52, 52, link_up[52]);
    bv.set_bits(51, 51, link_up[51]);
    bv.set_bits(50, 50, link_up[50]);
    bv.set_bits(49, 49, link_up[49]);
    bv.set_bits(48, 48, link_up[48]);
    bv.set_bits(47, 47, link_up[47]);
    bv.set_bits(46, 46, link_up[46]);
    bv.set_bits(45, 45, link_up[45]);
    bv.set_bits(44, 44, link_up[44]);
    bv.set_bits(43, 43, link_up[43]);
    bv.set_bits(42, 42, link_up[42]);
    bv.set_bits(41, 41, link_up[41]);
    bv.set_bits(40, 40, link_up[40]);
    bv.set_bits(39, 39, link_up[39]);
    bv.set_bits(38, 38, link_up[38]);
    bv.set_bits(37, 37, link_up[37]);
    bv.set_bits(36, 36, link_up[36]);
    bv.set_bits(35, 35, link_up[35]);
    bv.set_bits(34, 34, link_up[34]);
    bv.set_bits(33, 33, link_up[33]);
    bv.set_bits(32, 32, link_up[32]);
    bv.set_bits(31, 31, link_up[31]);
    bv.set_bits(30, 30, link_up[30]);
    bv.set_bits(29, 29, link_up[29]);
    bv.set_bits(28, 28, link_up[28]);
    bv.set_bits(27, 27, link_up[27]);
    bv.set_bits(26, 26, link_up[26]);
    bv.set_bits(25, 25, link_up[25]);
    bv.set_bits(24, 24, link_up[24]);
    bv.set_bits(23, 23, link_up[23]);
    bv.set_bits(22, 22, link_up[22]);
    bv.set_bits(21, 21, link_up[21]);
    bv.set_bits(20, 20, link_up[20]);
    bv.set_bits(19, 19, link_up[19]);
    bv.set_bits(18, 18, link_up[18]);
    bv.set_bits(17, 17, link_up[17]);
    bv.set_bits(16, 16, link_up[16]);
    bv.set_bits(15, 15, link_up[15]);
    bv.set_bits(14, 14, link_up[14]);
    bv.set_bits(13, 13, link_up[13]);
    bv.set_bits(12, 12, link_up[12]);
    bv.set_bits(11, 11, link_up[11]);
    bv.set_bits(10, 10, link_up[10]);
    bv.set_bits(9, 9, link_up[9]);
    bv.set_bits(8, 8, link_up[8]);
    bv.set_bits(7, 7, link_up[7]);
    bv.set_bits(6, 6, link_up[6]);
    bv.set_bits(5, 5, link_up[5]);
    bv.set_bits(4, 4, link_up[4]);
    bv.set_bits(3, 3, link_up[3]);
    bv.set_bits(2, 2, link_up[2]);
    bv.set_bits(1, 1, link_up[1]);
    bv.set_bits(0, 0, link_up[0]);
    return bv;
}


void npl_link_up_vector_result_t::unpack(bit_vector128_t bv) 
{
    link_up[107] = (npl_link_state_e)bv.bits(107, 107).get_value();
    link_up[106] = (npl_link_state_e)bv.bits(106, 106).get_value();
    link_up[105] = (npl_link_state_e)bv.bits(105, 105).get_value();
    link_up[104] = (npl_link_state_e)bv.bits(104, 104).get_value();
    link_up[103] = (npl_link_state_e)bv.bits(103, 103).get_value();
    link_up[102] = (npl_link_state_e)bv.bits(102, 102).get_value();
    link_up[101] = (npl_link_state_e)bv.bits(101, 101).get_value();
    link_up[100] = (npl_link_state_e)bv.bits(100, 100).get_value();
    link_up[99] = (npl_link_state_e)bv.bits(99, 99).get_value();
    link_up[98] = (npl_link_state_e)bv.bits(98, 98).get_value();
    link_up[97] = (npl_link_state_e)bv.bits(97, 97).get_value();
    link_up[96] = (npl_link_state_e)bv.bits(96, 96).get_value();
    link_up[95] = (npl_link_state_e)bv.bits(95, 95).get_value();
    link_up[94] = (npl_link_state_e)bv.bits(94, 94).get_value();
    link_up[93] = (npl_link_state_e)bv.bits(93, 93).get_value();
    link_up[92] = (npl_link_state_e)bv.bits(92, 92).get_value();
    link_up[91] = (npl_link_state_e)bv.bits(91, 91).get_value();
    link_up[90] = (npl_link_state_e)bv.bits(90, 90).get_value();
    link_up[89] = (npl_link_state_e)bv.bits(89, 89).get_value();
    link_up[88] = (npl_link_state_e)bv.bits(88, 88).get_value();
    link_up[87] = (npl_link_state_e)bv.bits(87, 87).get_value();
    link_up[86] = (npl_link_state_e)bv.bits(86, 86).get_value();
    link_up[85] = (npl_link_state_e)bv.bits(85, 85).get_value();
    link_up[84] = (npl_link_state_e)bv.bits(84, 84).get_value();
    link_up[83] = (npl_link_state_e)bv.bits(83, 83).get_value();
    link_up[82] = (npl_link_state_e)bv.bits(82, 82).get_value();
    link_up[81] = (npl_link_state_e)bv.bits(81, 81).get_value();
    link_up[80] = (npl_link_state_e)bv.bits(80, 80).get_value();
    link_up[79] = (npl_link_state_e)bv.bits(79, 79).get_value();
    link_up[78] = (npl_link_state_e)bv.bits(78, 78).get_value();
    link_up[77] = (npl_link_state_e)bv.bits(77, 77).get_value();
    link_up[76] = (npl_link_state_e)bv.bits(76, 76).get_value();
    link_up[75] = (npl_link_state_e)bv.bits(75, 75).get_value();
    link_up[74] = (npl_link_state_e)bv.bits(74, 74).get_value();
    link_up[73] = (npl_link_state_e)bv.bits(73, 73).get_value();
    link_up[72] = (npl_link_state_e)bv.bits(72, 72).get_value();
    link_up[71] = (npl_link_state_e)bv.bits(71, 71).get_value();
    link_up[70] = (npl_link_state_e)bv.bits(70, 70).get_value();
    link_up[69] = (npl_link_state_e)bv.bits(69, 69).get_value();
    link_up[68] = (npl_link_state_e)bv.bits(68, 68).get_value();
    link_up[67] = (npl_link_state_e)bv.bits(67, 67).get_value();
    link_up[66] = (npl_link_state_e)bv.bits(66, 66).get_value();
    link_up[65] = (npl_link_state_e)bv.bits(65, 65).get_value();
    link_up[64] = (npl_link_state_e)bv.bits(64, 64).get_value();
    link_up[63] = (npl_link_state_e)bv.bits(63, 63).get_value();
    link_up[62] = (npl_link_state_e)bv.bits(62, 62).get_value();
    link_up[61] = (npl_link_state_e)bv.bits(61, 61).get_value();
    link_up[60] = (npl_link_state_e)bv.bits(60, 60).get_value();
    link_up[59] = (npl_link_state_e)bv.bits(59, 59).get_value();
    link_up[58] = (npl_link_state_e)bv.bits(58, 58).get_value();
    link_up[57] = (npl_link_state_e)bv.bits(57, 57).get_value();
    link_up[56] = (npl_link_state_e)bv.bits(56, 56).get_value();
    link_up[55] = (npl_link_state_e)bv.bits(55, 55).get_value();
    link_up[54] = (npl_link_state_e)bv.bits(54, 54).get_value();
    link_up[53] = (npl_link_state_e)bv.bits(53, 53).get_value();
    link_up[52] = (npl_link_state_e)bv.bits(52, 52).get_value();
    link_up[51] = (npl_link_state_e)bv.bits(51, 51).get_value();
    link_up[50] = (npl_link_state_e)bv.bits(50, 50).get_value();
    link_up[49] = (npl_link_state_e)bv.bits(49, 49).get_value();
    link_up[48] = (npl_link_state_e)bv.bits(48, 48).get_value();
    link_up[47] = (npl_link_state_e)bv.bits(47, 47).get_value();
    link_up[46] = (npl_link_state_e)bv.bits(46, 46).get_value();
    link_up[45] = (npl_link_state_e)bv.bits(45, 45).get_value();
    link_up[44] = (npl_link_state_e)bv.bits(44, 44).get_value();
    link_up[43] = (npl_link_state_e)bv.bits(43, 43).get_value();
    link_up[42] = (npl_link_state_e)bv.bits(42, 42).get_value();
    link_up[41] = (npl_link_state_e)bv.bits(41, 41).get_value();
    link_up[40] = (npl_link_state_e)bv.bits(40, 40).get_value();
    link_up[39] = (npl_link_state_e)bv.bits(39, 39).get_value();
    link_up[38] = (npl_link_state_e)bv.bits(38, 38).get_value();
    link_up[37] = (npl_link_state_e)bv.bits(37, 37).get_value();
    link_up[36] = (npl_link_state_e)bv.bits(36, 36).get_value();
    link_up[35] = (npl_link_state_e)bv.bits(35, 35).get_value();
    link_up[34] = (npl_link_state_e)bv.bits(34, 34).get_value();
    link_up[33] = (npl_link_state_e)bv.bits(33, 33).get_value();
    link_up[32] = (npl_link_state_e)bv.bits(32, 32).get_value();
    link_up[31] = (npl_link_state_e)bv.bits(31, 31).get_value();
    link_up[30] = (npl_link_state_e)bv.bits(30, 30).get_value();
    link_up[29] = (npl_link_state_e)bv.bits(29, 29).get_value();
    link_up[28] = (npl_link_state_e)bv.bits(28, 28).get_value();
    link_up[27] = (npl_link_state_e)bv.bits(27, 27).get_value();
    link_up[26] = (npl_link_state_e)bv.bits(26, 26).get_value();
    link_up[25] = (npl_link_state_e)bv.bits(25, 25).get_value();
    link_up[24] = (npl_link_state_e)bv.bits(24, 24).get_value();
    link_up[23] = (npl_link_state_e)bv.bits(23, 23).get_value();
    link_up[22] = (npl_link_state_e)bv.bits(22, 22).get_value();
    link_up[21] = (npl_link_state_e)bv.bits(21, 21).get_value();
    link_up[20] = (npl_link_state_e)bv.bits(20, 20).get_value();
    link_up[19] = (npl_link_state_e)bv.bits(19, 19).get_value();
    link_up[18] = (npl_link_state_e)bv.bits(18, 18).get_value();
    link_up[17] = (npl_link_state_e)bv.bits(17, 17).get_value();
    link_up[16] = (npl_link_state_e)bv.bits(16, 16).get_value();
    link_up[15] = (npl_link_state_e)bv.bits(15, 15).get_value();
    link_up[14] = (npl_link_state_e)bv.bits(14, 14).get_value();
    link_up[13] = (npl_link_state_e)bv.bits(13, 13).get_value();
    link_up[12] = (npl_link_state_e)bv.bits(12, 12).get_value();
    link_up[11] = (npl_link_state_e)bv.bits(11, 11).get_value();
    link_up[10] = (npl_link_state_e)bv.bits(10, 10).get_value();
    link_up[9] = (npl_link_state_e)bv.bits(9, 9).get_value();
    link_up[8] = (npl_link_state_e)bv.bits(8, 8).get_value();
    link_up[7] = (npl_link_state_e)bv.bits(7, 7).get_value();
    link_up[6] = (npl_link_state_e)bv.bits(6, 6).get_value();
    link_up[5] = (npl_link_state_e)bv.bits(5, 5).get_value();
    link_up[4] = (npl_link_state_e)bv.bits(4, 4).get_value();
    link_up[3] = (npl_link_state_e)bv.bits(3, 3).get_value();
    link_up[2] = (npl_link_state_e)bv.bits(2, 2).get_value();
    link_up[1] = (npl_link_state_e)bv.bits(1, 1).get_value();
    link_up[0] = (npl_link_state_e)bv.bits(0, 0).get_value();
}



field_structure npl_link_up_vector_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_link_up_vector_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(link_up[107]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[107]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[106]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[106]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[105]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[105]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[104]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[104]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[103]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[103]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[102]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[102]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[101]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[101]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[100]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[100]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[99]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[99]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[98]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[98]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[97]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[97]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[96]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[96]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[95]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[95]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[94]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[94]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[93]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[93]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[92]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[92]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[91]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[91]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[90]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[90]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[89]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[89]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[88]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[88]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[87]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[87]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[86]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[86]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[85]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[85]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[84]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[84]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[83]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[83]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[82]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[82]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[81]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[81]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[80]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[80]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[79]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[79]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[78]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[78]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[77]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[77]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[76]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[76]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[75]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[75]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[74]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[74]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[73]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[73]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[72]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[72]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[71]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[71]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[70]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[70]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[69]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[69]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[68]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[68]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[67]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[67]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[66]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[66]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[65]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[65]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[64]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[64]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[63]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[63]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[62]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[62]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[61]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[61]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[60]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[60]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[59]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[59]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[58]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[58]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[57]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[57]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[56]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[56]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[55]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[55]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[54]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[54]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[53]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[53]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[52]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[52]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[51]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[51]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[50]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[50]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[49]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[49]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[48]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[48]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[47]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[47]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[46]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[46]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[45]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[45]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[44]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[44]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[43]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[43]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[42]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[42]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[41]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[41]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[40]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[40]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[39]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[39]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[38]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[38]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[37]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[37]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[36]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[36]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[35]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[35]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[34]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[34]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[33]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[33]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[32]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[32]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[31]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[31]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[30]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[30]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[29]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[29]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[28]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[28]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[27]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[27]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[26]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[26]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[25]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[25]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[24]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[24]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[23]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[23]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[22]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[22]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[21]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[21]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[20]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[20]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[19]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[19]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[18]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[18]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[17]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[17]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[16]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[16]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[15]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[15]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[14]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[14]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[13]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[13]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[12]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[12]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[11]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[11]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[10]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[10]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[9]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[9]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[8]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[8]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[7]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[7]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[6]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[6]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[5]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[5]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[4]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[4]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[3]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[3]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[2]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[2]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[1]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[1]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(link_up[0]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("link_up[0]", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_link_up_vector_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_link_up_vector_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lm_command_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 8, op);
    // PADDING -  bv.set_bits(7, 7, padding);
    bv.set_bits(6, 0, offset);
    return bv;
}


void npl_lm_command_t::unpack(bit_vector64_t bv) 
{
    op = bv.bits(11, 8).get_value();
    // PADDING -  padding = bv.bits(7, 7).get_value();
    offset = bv.bits(6, 0).get_value();
}



field_structure npl_lm_command_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lm_command_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(op);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("op", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lm_command_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lm_command_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_local_tx_ip_mapping_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, is_mpls_fwd);
    bv.set_bits(1, 1, is_underlying_ip_proto);
    bv.set_bits(0, 0, is_mapped_v4);
    return bv;
}


void npl_local_tx_ip_mapping_t::unpack(bit_vector64_t bv) 
{
    is_mpls_fwd = bv.bits(2, 2).get_value();
    is_underlying_ip_proto = bv.bits(1, 1).get_value();
    is_mapped_v4 = bv.bits(0, 0).get_value();
}



field_structure npl_local_tx_ip_mapping_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_local_tx_ip_mapping_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_mpls_fwd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_mpls_fwd", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_underlying_ip_proto);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_underlying_ip_proto", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_mapped_v4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_mapped_v4", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_local_tx_ip_mapping_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_local_tx_ip_mapping_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_lp_attr_update_raw_bits_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 108, update_12_bits);
    bv.set_bits(107, 105, update_3_bits);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 40;
        size_t max_msb = lsb + 65 - 1;
        size_t msb = 0;
        const uint64_t * p = update_65_bits;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    bv.set_bits(39, 0, update_q_m_counters);
    return bv;
}


void npl_lp_attr_update_raw_bits_t::unpack(bit_vector128_t bv) 
{
    update_12_bits = bv.bits(119, 108).get_value();
    update_3_bits = bv.bits(107, 105).get_value();
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 40;
        size_t max_msb = lsb + 65 - 1;
        size_t msb = 0;
        uint64_t * p = update_65_bits;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    update_q_m_counters = bv.bits(39, 0).get_value();
}



field_structure npl_lp_attr_update_raw_bits_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lp_attr_update_raw_bits_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(update_12_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_12_bits", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(update_3_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_3_bits", fs_subfield);
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 55;
        size_t max_msb = lsb + 65 - 1;
        size_t msb = 0;
        const uint64_t * p = update_65_bits;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    fs_subfield.flat_value = to_hex_string(update_q_m_counters);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_q_m_counters", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lp_attr_update_raw_bits_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lp_attr_update_raw_bits_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lp_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, id);
    return bv;
}


void npl_lp_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(15, 0).get_value();
}



field_structure npl_lp_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lp_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lp_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lp_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lp_rtf_conf_set_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, val);
    return bv;
}


void npl_lp_rtf_conf_set_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(7, 0).get_value();
}



field_structure npl_lp_rtf_conf_set_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lp_rtf_conf_set_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lp_rtf_conf_set_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lp_rtf_conf_set_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpm_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 20, class_id.pack());
    bv.set_bits(19, 0, destination.pack());
    return bv;
}


void npl_lpm_payload_t::unpack(bit_vector64_t bv) 
{
    class_id.unpack(bv.bits(27, 20));
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_lpm_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpm_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("class_id", class_id.to_field_structure());
    fs_result.subfields.emplace_back("destination", destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lpm_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpm_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpm_prefix_fec_access_map_output_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, access_fec_table);
    return bv;
}


void npl_lpm_prefix_fec_access_map_output_t::unpack(bit_vector64_t bv) 
{
    access_fec_table = bv.bits(0, 0).get_value();
}



field_structure npl_lpm_prefix_fec_access_map_output_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpm_prefix_fec_access_map_output_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(access_fec_table);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_fec_table", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lpm_prefix_fec_access_map_output_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpm_prefix_fec_access_map_output_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_lpm_std_ip_em_lpm_result_destination_t_anonymous_union_union_for_padding_t::pack(void) const // union
{
    bit_vector128_t bv(0, 124);
    { // union compound field start
        bit_vector64_t tbv = payload.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_lpm_std_ip_em_lpm_result_destination_t_anonymous_union_union_for_padding_t::unpack(bit_vector128_t bv) // union
{
    payload.unpack(bv.bits(27, 0));
}



field_structure npl_lpm_std_ip_em_lpm_result_destination_t_anonymous_union_union_for_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpm_std_ip_em_lpm_result_destination_t_anonymous_union_union_for_padding_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = payload.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("payload", payload.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_lpm_std_ip_em_lpm_result_destination_t_anonymous_union_union_for_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpm_std_ip_em_lpm_result_destination_t_anonymous_union_union_for_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_cntr_and_lookup_index_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 25, meter_index_lsb);
    bv.set_bits(24, 20, lpts_second_lookup_index);
    bv.set_bits(19, 0, lpts_counter_ptr.pack());
    return bv;
}


void npl_lpts_cntr_and_lookup_index_t::unpack(bit_vector64_t bv) 
{
    meter_index_lsb = bv.bits(31, 25).get_value();
    lpts_second_lookup_index = bv.bits(24, 20).get_value();
    lpts_counter_ptr.unpack(bv.bits(19, 0));
}



field_structure npl_lpts_cntr_and_lookup_index_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_cntr_and_lookup_index_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(meter_index_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter_index_lsb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpts_second_lookup_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpts_second_lookup_index", fs_subfield);
    
    fs_result.subfields.emplace_back("lpts_counter_ptr", lpts_counter_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lpts_cntr_and_lookup_index_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_cntr_and_lookup_index_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_flow_type_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, lpts_flow);
    return bv;
}


void npl_lpts_flow_type_t::unpack(bit_vector64_t bv) 
{
    lpts_flow = bv.bits(3, 0).get_value();
}



field_structure npl_lpts_flow_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_flow_type_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lpts_flow);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpts_flow", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lpts_flow_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_flow_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_packet_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, established);
    bv.set_bits(0, 0, skip_bfd_or_ttl_255);
    return bv;
}


void npl_lpts_packet_flags_t::unpack(bit_vector64_t bv) 
{
    established = bv.bits(1, 1).get_value();
    skip_bfd_or_ttl_255 = bv.bits(0, 0).get_value();
}



field_structure npl_lpts_packet_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_packet_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(established);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("established", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(skip_bfd_or_ttl_255);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("skip_bfd_or_ttl_255", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lpts_packet_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_packet_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_tcam_first_result_encap_data_msb_t_anonymous_union_encap_punt_code_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (mirror_or_redirect_code != 0) {  // union primitive field start
        bv.set_bits(7, 0, mirror_or_redirect_code);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = fabric_ibm_cmd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (lpts_reason != 0) {  // union primitive field start
        bv.set_bits(7, 0, lpts_reason);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_lpts_tcam_first_result_encap_data_msb_t_anonymous_union_encap_punt_code_t::unpack(bit_vector64_t bv) // union
{
    mirror_or_redirect_code = bv.bits(7, 0).get_value();
}



field_structure npl_lpts_tcam_first_result_encap_data_msb_t_anonymous_union_encap_punt_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_tcam_first_result_encap_data_msb_t_anonymous_union_encap_punt_code_t";
    field_structure fs_subfield;
    //add members to result
    if (mirror_or_redirect_code != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mirror_or_redirect_code);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = fabric_ibm_cmd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("fabric_ibm_cmd", fabric_ibm_cmd.to_field_structure());
        }
    } // union compound field end
    
    if (lpts_reason != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lpts_reason);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_lpts_tcam_first_result_encap_data_msb_t_anonymous_union_encap_punt_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_tcam_first_result_encap_data_msb_t_anonymous_union_encap_punt_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lr_fifo_register_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, address);
    return bv;
}


void npl_lr_fifo_register_t::unpack(bit_vector64_t bv) 
{
    address = bv.bits(3, 0).get_value();
}



field_structure npl_lr_fifo_register_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lr_fifo_register_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("address", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lr_fifo_register_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lr_fifo_register_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lr_filter_fifo_register_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, address);
    return bv;
}


void npl_lr_filter_fifo_register_t::unpack(bit_vector64_t bv) 
{
    address = bv.bits(4, 0).get_value();
}



field_structure npl_lr_filter_fifo_register_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lr_filter_fifo_register_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("address", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lr_filter_fifo_register_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lr_filter_fifo_register_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_encap_mapping_data_payload_t_anonymous_union_counter_and_flag_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = counter_flag.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lsp_counter.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_lsp_encap_mapping_data_payload_t_anonymous_union_counter_and_flag_t::unpack(bit_vector64_t bv) // union
{
    counter_flag.unpack(bv.bits(19, 0));
}



field_structure npl_lsp_encap_mapping_data_payload_t_anonymous_union_counter_and_flag_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_encap_mapping_data_payload_t_anonymous_union_counter_and_flag_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = counter_flag.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("counter_flag", counter_flag.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lsp_counter.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lsp_counter", lsp_counter.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_lsp_encap_mapping_data_payload_t_anonymous_union_counter_and_flag_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_encap_mapping_data_payload_t_anonymous_union_counter_and_flag_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_impose_2_mpls_labels_ene_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, lsp_two_labels_ene_jump_offset);
    bv.set_bits(3, 0, lsp_one_label_ene_jump_offset);
    return bv;
}


void npl_lsp_impose_2_mpls_labels_ene_offset_t::unpack(bit_vector64_t bv) 
{
    lsp_two_labels_ene_jump_offset = (npl_lsp_two_labels_ene_jump_offset_e)bv.bits(7, 4).get_value();
    lsp_one_label_ene_jump_offset = (npl_lsp_one_label_ene_jump_offset_e)bv.bits(3, 0).get_value();
}



field_structure npl_lsp_impose_2_mpls_labels_ene_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_impose_2_mpls_labels_ene_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(lsp_two_labels_ene_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lsp_two_labels_ene_jump_offset", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(lsp_one_label_ene_jump_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lsp_one_label_ene_jump_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lsp_impose_2_mpls_labels_ene_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_impose_2_mpls_labels_ene_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_impose_mpls_labels_ene_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, lsp_impose_2_mpls_labels_ene_offset.pack());
    return bv;
}


void npl_lsp_impose_mpls_labels_ene_offset_t::unpack(bit_vector64_t bv) 
{
    lsp_impose_2_mpls_labels_ene_offset.unpack(bv.bits(7, 0));
}



field_structure npl_lsp_impose_mpls_labels_ene_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_impose_mpls_labels_ene_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lsp_impose_2_mpls_labels_ene_offset", lsp_impose_2_mpls_labels_ene_offset.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lsp_impose_mpls_labels_ene_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_impose_mpls_labels_ene_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_labels_opt3_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 40, label_0);
    bv.set_bits(39, 20, label_1);
    bv.set_bits(19, 0, label_2);
    return bv;
}


void npl_lsp_labels_opt3_t::unpack(bit_vector64_t bv) 
{
    label_0 = bv.bits(59, 40).get_value();
    label_1 = bv.bits(39, 20).get_value();
    label_2 = bv.bits(19, 0).get_value();
}



field_structure npl_lsp_labels_opt3_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_labels_opt3_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(label_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_2", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lsp_labels_opt3_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_labels_opt3_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_labels_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 20, label_0);
    bv.set_bits(19, 0, label_1);
    return bv;
}


void npl_lsp_labels_t::unpack(bit_vector64_t bv) 
{
    label_0 = bv.bits(39, 20).get_value();
    label_1 = bv.bits(19, 0).get_value();
}



field_structure npl_lsp_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_labels_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(label_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_1", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lsp_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_type_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 2, destination_encoding);
    bv.set_bits(1, 1, vpn);
    bv.set_bits(0, 0, inter_as);
    return bv;
}


void npl_lsp_type_t::unpack(bit_vector64_t bv) 
{
    destination_encoding = bv.bits(3, 2).get_value();
    vpn = bv.bits(1, 1).get_value();
    inter_as = bv.bits(0, 0).get_value();
}



field_structure npl_lsp_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_type_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(destination_encoding);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_encoding", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inter_as", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lsp_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsr_encap_t_anonymous_union_lsp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    if (swap_label != 0) {  // union primitive field start
        bv.set_bits(19, 0, swap_label);
        return bv;
    }// union primitive field end
    
    if (lsp_id != 0) {  // union primitive field start
        bv.set_bits(19, 0, lsp_id);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_lsr_encap_t_anonymous_union_lsp_t::unpack(bit_vector64_t bv) // union
{
    swap_label = bv.bits(19, 0).get_value();
}



field_structure npl_lsr_encap_t_anonymous_union_lsp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsr_encap_t_anonymous_union_lsp_t";
    field_structure fs_subfield;
    //add members to result
    if (swap_label != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(swap_label);
        return union_found;
    }// union primitive field end
    
    if (lsp_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lsp_id);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_lsr_encap_t_anonymous_union_lsp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsr_encap_t_anonymous_union_lsp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_addr_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 0, mac_address);
    return bv;
}


void npl_mac_addr_t::unpack(bit_vector64_t bv) 
{
    mac_address = bv.bits(47, 0).get_value();
}



field_structure npl_mac_addr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_addr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mac_address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_address", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_addr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_addr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_da_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 17, is_vrrp);
    bv.set_bits(16, 16, mac_l2_lpts_lkup);
    bv.set_bits(15, 15, use_l2_lpts);
    bv.set_bits(14, 10, prefix);
    bv.set_bits(9, 8, compound_termination_control.pack());
    bv.set_bits(7, 7, is_mc);
    // PADDING -  bv.set_bits(6, 6, padding);
    bv.set_bits(5, 5, is_ipv4_mc);
    bv.set_bits(4, 4, is_ipv6_mc);
    bv.set_bits(3, 0, type);
    return bv;
}


void npl_mac_da_t::unpack(bit_vector64_t bv) 
{
    is_vrrp = bv.bits(17, 17).get_value();
    mac_l2_lpts_lkup = bv.bits(16, 16).get_value();
    use_l2_lpts = bv.bits(15, 15).get_value();
    prefix = bv.bits(14, 10).get_value();
    compound_termination_control.unpack(bv.bits(9, 8));
    is_mc = bv.bits(7, 7).get_value();
    // PADDING -  padding = bv.bits(6, 6).get_value();
    is_ipv4_mc = bv.bits(5, 5).get_value();
    is_ipv6_mc = bv.bits(4, 4).get_value();
    type = (npl_mac_da_type_e)bv.bits(3, 0).get_value();
}



field_structure npl_mac_da_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_da_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_vrrp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_vrrp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mac_l2_lpts_lkup);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_l2_lpts_lkup", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(use_l2_lpts);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("use_l2_lpts", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(prefix);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prefix", fs_subfield);
    
    fs_result.subfields.emplace_back("compound_termination_control", compound_termination_control.to_field_structure());
    fs_subfield.flat_value = to_hex_string(is_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_mc", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(is_ipv4_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_ipv4_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_ipv6_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_ipv6_mc", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_da_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_da_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mac_da_tos_pack_payload_t::pack(void) const 
{
    bit_vector128_t bv(0, 92);
    bv.set_bits(91, 76, eth_type);
    bv.set_bits(75, 28, mac_da);
    bv.set_bits(27, 20, v4_ttl);
    bv.set_bits(19, 12, v6_ttl);
    bv.set_bits(11, 8, hln);
    bv.set_bits(7, 0, tos);
    return bv;
}


void npl_mac_da_tos_pack_payload_t::unpack(bit_vector128_t bv) 
{
    eth_type = bv.bits(91, 76).get_value();
    mac_da = bv.bits(75, 28).get_value();
    v4_ttl = bv.bits(27, 20).get_value();
    v6_ttl = bv.bits(19, 12).get_value();
    hln = bv.bits(11, 8).get_value();
    tos = bv.bits(7, 0).get_value();
}



field_structure npl_mac_da_tos_pack_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_da_tos_pack_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(eth_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mac_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_da", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(v4_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("v4_ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(v6_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("v6_ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(hln);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hln", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tos", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_da_tos_pack_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_da_tos_pack_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_l2_relay_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 34);
    bv.set_bits(33, 26, bd_attributes.pack());
    bv.set_bits(25, 6, flood_destination.pack());
    bv.set_bits(5, 5, drop_unknown_bc);
    bv.set_bits(4, 4, drop_unknown_mc);
    bv.set_bits(3, 3, drop_unknown_uc);
    bv.set_bits(2, 2, mld_snooping);
    bv.set_bits(1, 1, igmp_snooping);
    bv.set_bits(0, 0, is_svi);
    return bv;
}


void npl_mac_l2_relay_attributes_t::unpack(bit_vector64_t bv) 
{
    bd_attributes.unpack(bv.bits(33, 26));
    flood_destination.unpack(bv.bits(25, 6));
    drop_unknown_bc = bv.bits(5, 5).get_value();
    drop_unknown_mc = bv.bits(4, 4).get_value();
    drop_unknown_uc = bv.bits(3, 3).get_value();
    mld_snooping = bv.bits(2, 2).get_value();
    igmp_snooping = bv.bits(1, 1).get_value();
    is_svi = bv.bits(0, 0).get_value();
}



field_structure npl_mac_l2_relay_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_l2_relay_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("bd_attributes", bd_attributes.to_field_structure());
    fs_result.subfields.emplace_back("flood_destination", flood_destination.to_field_structure());
    fs_subfield.flat_value = to_hex_string(drop_unknown_bc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_unknown_bc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop_unknown_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_unknown_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop_unknown_uc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_unknown_uc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mld_snooping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mld_snooping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(igmp_snooping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("igmp_snooping", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_svi);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_svi", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_l2_relay_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_l2_relay_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_l3_remark_pack_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 12, ipv6_tos);
    bv.set_bits(11, 4, ipv4_tos);
    bv.set_bits(3, 0, mpls_exp_bos);
    return bv;
}


void npl_mac_l3_remark_pack_payload_t::unpack(bit_vector64_t bv) 
{
    ipv6_tos = bv.bits(19, 12).get_value();
    ipv4_tos = bv.bits(11, 4).get_value();
    mpls_exp_bos = bv.bits(3, 0).get_value();
}



field_structure npl_mac_l3_remark_pack_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_l3_remark_pack_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ipv6_tos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv6_tos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ipv4_tos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv4_tos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mpls_exp_bos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_exp_bos", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_l3_remark_pack_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_l3_remark_pack_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_metadata_em_pad_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, pad);
    return bv;
}


void npl_mac_metadata_em_pad_t::unpack(bit_vector64_t bv) 
{
    pad = bv.bits(3, 0).get_value();
}



field_structure npl_mac_metadata_em_pad_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_metadata_em_pad_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(pad);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pad", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_metadata_em_pad_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_metadata_em_pad_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_metadata_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, class_id.pack());
    return bv;
}


void npl_mac_metadata_t::unpack(bit_vector64_t bv) 
{
    class_id.unpack(bv.bits(7, 0));
}



field_structure npl_mac_metadata_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_metadata_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("class_id", class_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_metadata_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_metadata_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_g_destination_pad_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 4, dest.pack());
    bv.set_bits(3, 0, pad);
    return bv;
}


void npl_mac_relay_g_destination_pad_t::unpack(bit_vector64_t bv) 
{
    dest.unpack(bv.bits(23, 4));
    pad = bv.bits(3, 0).get_value();
}



field_structure npl_mac_relay_g_destination_pad_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_g_destination_pad_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("dest", dest.to_field_structure());
    fs_subfield.flat_value = to_hex_string(pad);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pad", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_relay_g_destination_pad_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_g_destination_pad_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_g_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, destination.pack());
    return bv;
}


void npl_mac_relay_g_destination_t::unpack(bit_vector64_t bv) 
{
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_mac_relay_g_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_g_destination_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("destination", destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_relay_g_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_g_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mact_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 20, application_specific_fields);
    bv.set_bits(19, 0, destination.pack());
    return bv;
}


void npl_mact_result_t::unpack(bit_vector64_t bv) 
{
    application_specific_fields = bv.bits(31, 20).get_value();
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_mact_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mact_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(application_specific_fields);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("application_specific_fields", fs_subfield);
    
    fs_result.subfields.emplace_back("destination", destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mact_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mact_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mapping_qos_tag_packed_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 31, fwd_hdr_type_v6);
    bv.set_bits(30, 24, mapping_qos_tag);
    bv.set_bits(23, 16, eth_ene_macro_id.pack());
    bv.set_bits(15, 8, el_label_exp_bos_inner_label_bos_1);
    bv.set_bits(7, 0, el_label_exp_bos_inner_label_bos_0);
    return bv;
}


void npl_mapping_qos_tag_packed_result_t::unpack(bit_vector64_t bv) 
{
    fwd_hdr_type_v6 = bv.bits(31, 31).get_value();
    mapping_qos_tag = bv.bits(30, 24).get_value();
    eth_ene_macro_id.unpack(bv.bits(23, 16));
    el_label_exp_bos_inner_label_bos_1 = bv.bits(15, 8).get_value();
    el_label_exp_bos_inner_label_bos_0 = bv.bits(7, 0).get_value();
}



field_structure npl_mapping_qos_tag_packed_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mapping_qos_tag_packed_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(fwd_hdr_type_v6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_hdr_type_v6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mapping_qos_tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mapping_qos_tag", fs_subfield);
    
    fs_result.subfields.emplace_back("eth_ene_macro_id", eth_ene_macro_id.to_field_structure());
    fs_subfield.flat_value = to_hex_string(el_label_exp_bos_inner_label_bos_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("el_label_exp_bos_inner_label_bos_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(el_label_exp_bos_inner_label_bos_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("el_label_exp_bos_inner_label_bos_0", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mapping_qos_tag_packed_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mapping_qos_tag_packed_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_bitmap_base_voq_lookup_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 16, tc_map_profile);
    bv.set_bits(15, 0, base_voq);
    return bv;
}


void npl_mc_bitmap_base_voq_lookup_table_result_t::unpack(bit_vector64_t bv) 
{
    tc_map_profile = bv.bits(17, 16).get_value();
    base_voq = bv.bits(15, 0).get_value();
}



field_structure npl_mc_bitmap_base_voq_lookup_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_bitmap_base_voq_lookup_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tc_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_map_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(base_voq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("base_voq", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_bitmap_base_voq_lookup_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_bitmap_base_voq_lookup_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_bitmap_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 6, bitmap_indicator);
    bv.set_bits(5, 0, bitmap);
    return bv;
}


void npl_mc_bitmap_t::unpack(bit_vector64_t bv) 
{
    bitmap_indicator = bv.bits(10, 6).get_value();
    bitmap = bv.bits(5, 0).get_value();
}



field_structure npl_mc_bitmap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_bitmap_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bitmap_indicator);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bitmap_indicator", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bitmap);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bitmap", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_bitmap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_bitmap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_copy_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 0, val);
    return bv;
}


void npl_mc_copy_id_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(17, 0).get_value();
}



field_structure npl_mc_copy_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_copy_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_copy_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_copy_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_em_db__key_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 31, is_tx);
    bv.set_bits(30, 28, slice_or_is_fabric);
    bv.set_bits(27, 27, is_rcy);
    bv.set_bits(26, 11, mcid);
    bv.set_bits(10, 0, entry_index);
    return bv;
}


void npl_mc_em_db__key_t::unpack(bit_vector64_t bv) 
{
    is_tx = bv.bits(31, 31).get_value();
    slice_or_is_fabric = bv.bits(30, 28).get_value();
    is_rcy = bv.bits(27, 27).get_value();
    mcid = bv.bits(26, 11).get_value();
    entry_index = bv.bits(10, 0).get_value();
}



field_structure npl_mc_em_db__key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db__key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_tx);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_tx", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(slice_or_is_fabric);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slice_or_is_fabric", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_rcy);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_rcy", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mcid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mcid", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(entry_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("entry_index", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_em_db__key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db__key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mc_em_db_result_tx_format_1_t::pack(void) const 
{
    bit_vector128_t bv(0, 71);
    bv.set_bits(70, 23, copy_bitmap);
    bv.set_bits(22, 21, bmp_map_profile);
    bv.set_bits(20, 18, tc_map_profile);
    bv.set_bits(17, 0, mc_copy_id);
    return bv;
}


void npl_mc_em_db_result_tx_format_1_t::unpack(bit_vector128_t bv) 
{
    copy_bitmap = bv.bits(70, 23).get_value();
    bmp_map_profile = bv.bits(22, 21).get_value();
    tc_map_profile = bv.bits(20, 18).get_value();
    mc_copy_id = bv.bits(17, 0).get_value();
}



field_structure npl_mc_em_db_result_tx_format_1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_tx_format_1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(copy_bitmap);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("copy_bitmap", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bmp_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bmp_map_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_map_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mc_copy_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mc_copy_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_tx_format_1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_tx_format_1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mc_fe_links_bmp_db_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 109);
    bv.set_bits(108, 108, use_bitmap_directly);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 108 - 1;
        size_t msb = 0;
        const uint64_t * p = fe_links_bmp;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_mc_fe_links_bmp_db_result_t::unpack(bit_vector128_t bv) 
{
    use_bitmap_directly = bv.bits(108, 108).get_value();
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 108 - 1;
        size_t msb = 0;
        uint64_t * p = fe_links_bmp;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_mc_fe_links_bmp_db_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_fe_links_bmp_db_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(use_bitmap_directly);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("use_bitmap_directly", fs_subfield);
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 1;
        size_t max_msb = lsb + 108 - 1;
        size_t msb = 0;
        const uint64_t * p = fe_links_bmp;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_mc_fe_links_bmp_db_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_fe_links_bmp_db_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_macro_compressed_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    // PADDING -  bv.set_bits(7, 7, padding);
    bv.set_bits(6, 6, is_inject_up);
    bv.set_bits(5, 5, not_comp_single_src);
    bv.set_bits(4, 0, curr_proto_type);
    return bv;
}


void npl_mc_macro_compressed_fields_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(7, 7).get_value();
    is_inject_up = bv.bits(6, 6).get_value();
    not_comp_single_src = bv.bits(5, 5).get_value();
    curr_proto_type = (npl_protocol_type_e)bv.bits(4, 0).get_value();
}



field_structure npl_mc_macro_compressed_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_macro_compressed_fields_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(is_inject_up);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_inject_up", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(not_comp_single_src);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("not_comp_single_src", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(curr_proto_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("curr_proto_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_macro_compressed_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_macro_compressed_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_rx_tc_map_profile_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, val);
    return bv;
}


void npl_mc_rx_tc_map_profile_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(1, 0).get_value();
}



field_structure npl_mc_rx_tc_map_profile_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_rx_tc_map_profile_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_rx_tc_map_profile_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_rx_tc_map_profile_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_slice_bitmap_table_entry_t_anonymous_union_group_size_or_bitmap_t::pack(void) const // union
{
    bit_vector64_t bv(0, 11);
    if (group_size != 0) {  // union primitive field start
        bv.set_bits(10, 0, group_size);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = mc_bitmap.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(10, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mc_slice_bitmap_table_entry_t_anonymous_union_group_size_or_bitmap_t::unpack(bit_vector64_t bv) // union
{
    group_size = bv.bits(10, 0).get_value();
}



field_structure npl_mc_slice_bitmap_table_entry_t_anonymous_union_group_size_or_bitmap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_slice_bitmap_table_entry_t_anonymous_union_group_size_or_bitmap_t";
    field_structure fs_subfield;
    //add members to result
    if (group_size != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(group_size);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = mc_bitmap.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mc_bitmap", mc_bitmap.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mc_slice_bitmap_table_entry_t_anonymous_union_group_size_or_bitmap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_slice_bitmap_table_entry_t_anonymous_union_group_size_or_bitmap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_tx_tc_map_profile_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 0, val);
    return bv;
}


void npl_mc_tx_tc_map_profile_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(2, 0).get_value();
}



field_structure npl_mc_tx_tc_map_profile_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_tx_tc_map_profile_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_tx_tc_map_profile_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_tx_tc_map_profile_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mcid_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, id);
    return bv;
}


void npl_mcid_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(15, 0).get_value();
}



field_structure npl_mcid_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mcid_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mcid_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mcid_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_meg_id_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 120 - 1;
        size_t msb = 0;
        const uint64_t * p = id;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_meg_id_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 120 - 1;
        size_t msb = 0;
        uint64_t * p = id;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_meg_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_meg_id_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 120 - 1;
        size_t msb = 0;
        const uint64_t * p = id;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_meg_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_meg_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_meter_action_profile_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, value);
    return bv;
}


void npl_meter_action_profile_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(1, 0).get_value();
}



field_structure npl_meter_action_profile_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_meter_action_profile_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_meter_action_profile_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_meter_action_profile_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_meter_count_mode_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, value);
    return bv;
}


void npl_meter_count_mode_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(0, 0).get_value();
}



field_structure npl_meter_count_mode_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_meter_count_mode_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_meter_count_mode_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_meter_count_mode_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_meter_mode_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, value);
    return bv;
}


void npl_meter_mode_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(0, 0).get_value();
}



field_structure npl_meter_mode_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_meter_mode_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_meter_mode_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_meter_mode_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_meter_profile_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, value);
    return bv;
}


void npl_meter_profile_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(3, 0).get_value();
}



field_structure npl_meter_profile_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_meter_profile_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_meter_profile_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_meter_profile_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_meter_weight_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 5, weight_factor);
    bv.set_bits(4, 0, weight);
    return bv;
}


void npl_meter_weight_t::unpack(bit_vector64_t bv) 
{
    weight_factor = bv.bits(9, 5).get_value();
    weight = bv.bits(4, 0).get_value();
}



field_structure npl_meter_weight_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_meter_weight_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(weight_factor);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("weight_factor", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(weight);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("weight", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_meter_weight_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_meter_weight_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mii_loopback_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, mode);
    return bv;
}


void npl_mii_loopback_data_t::unpack(bit_vector64_t bv) 
{
    mode = (npl_loopback_mode_e)bv.bits(1, 0).get_value();
}



field_structure npl_mii_loopback_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mii_loopback_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mode", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mii_loopback_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mii_loopback_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_minimal_l3_lp_attributes_t_anonymous_union_disable_mpls_or_mc_tunnel_t::pack(void) const // union
{
    bit_vector64_t bv(0, 1);
    if (disable_mpls != 0) {  // union primitive field start
        bv.set_bits(0, 0, disable_mpls);
        return bv;
    }// union primitive field end
    
    if (disable_mc_tunnel_decap != 0) {  // union primitive field start
        bv.set_bits(0, 0, disable_mc_tunnel_decap);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_minimal_l3_lp_attributes_t_anonymous_union_disable_mpls_or_mc_tunnel_t::unpack(bit_vector64_t bv) // union
{
    disable_mpls = bv.bits(0, 0).get_value();
}



field_structure npl_minimal_l3_lp_attributes_t_anonymous_union_disable_mpls_or_mc_tunnel_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_minimal_l3_lp_attributes_t_anonymous_union_disable_mpls_or_mc_tunnel_t";
    field_structure fs_subfield;
    //add members to result
    if (disable_mpls != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(disable_mpls);
        return union_found;
    }// union primitive field end
    
    if (disable_mc_tunnel_decap != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(disable_mc_tunnel_decap);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_minimal_l3_lp_attributes_t_anonymous_union_disable_mpls_or_mc_tunnel_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_minimal_l3_lp_attributes_t_anonymous_union_disable_mpls_or_mc_tunnel_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mismatch_indications_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, issu_codespace);
    bv.set_bits(1, 1, first_packet_size);
    bv.set_bits(0, 0, is_single_fragment);
    return bv;
}


void npl_mismatch_indications_t::unpack(bit_vector64_t bv) 
{
    issu_codespace = bv.bits(2, 2).get_value();
    first_packet_size = bv.bits(1, 1).get_value();
    is_single_fragment = bv.bits(0, 0).get_value();
}



field_structure npl_mismatch_indications_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mismatch_indications_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(issu_codespace);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("issu_codespace", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(first_packet_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("first_packet_size", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_single_fragment);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_single_fragment", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mismatch_indications_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mismatch_indications_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mldp_protection_entry_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, drop_protect.pack());
    bv.set_bits(0, 0, drop_primary.pack());
    return bv;
}


void npl_mldp_protection_entry_t::unpack(bit_vector64_t bv) 
{
    drop_protect.unpack(bv.bits(1, 1));
    drop_primary.unpack(bv.bits(0, 0));
}



field_structure npl_mldp_protection_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mldp_protection_entry_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("drop_protect", drop_protect.to_field_structure());
    fs_result.subfields.emplace_back("drop_primary", drop_primary.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mldp_protection_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mldp_protection_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mldp_protection_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 0, id);
    return bv;
}


void npl_mldp_protection_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(8, 0).get_value();
}



field_structure npl_mldp_protection_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mldp_protection_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mldp_protection_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mldp_protection_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mldp_protection_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 1, id.pack());
    bv.set_bits(0, 0, sel);
    return bv;
}


void npl_mldp_protection_t::unpack(bit_vector64_t bv) 
{
    id.unpack(bv.bits(9, 1));
    sel = (npl_resolution_protection_selector_e)bv.bits(0, 0).get_value();
}



field_structure npl_mldp_protection_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mldp_protection_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("id", id.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sel", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mldp_protection_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mldp_protection_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_more_labels_index_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, more_labels_index);
    return bv;
}


void npl_more_labels_index_t::unpack(bit_vector64_t bv) 
{
    more_labels_index = bv.bits(11, 0).get_value();
}



field_structure npl_more_labels_index_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_more_labels_index_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(more_labels_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("more_labels_index", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_more_labels_index_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_more_labels_index_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mp_table_app_t_anonymous_union_mp2_data_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    { // union compound field start
        bit_vector64_t tbv = transmit_b.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = bfd2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = hw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mp_table_app_t_anonymous_union_mp2_data_union_t::unpack(bit_vector64_t bv) // union
{
    transmit_b.unpack(bv.bits(15, 0));
}



field_structure npl_mp_table_app_t_anonymous_union_mp2_data_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mp_table_app_t_anonymous_union_mp2_data_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = transmit_b.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("transmit_b", transmit_b.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = bfd2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("bfd2", bfd2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = hw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("hw", hw.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mp_table_app_t_anonymous_union_mp2_data_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mp_table_app_t_anonymous_union_mp2_data_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_encap_control_bits_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, is_midpoint);
    bv.set_bits(1, 1, mpls_labels_lookup);
    bv.set_bits(0, 0, is_asbr_or_ldpote);
    return bv;
}


void npl_mpls_encap_control_bits_t::unpack(bit_vector64_t bv) 
{
    is_midpoint = bv.bits(2, 2).get_value();
    mpls_labels_lookup = bv.bits(1, 1).get_value();
    is_asbr_or_ldpote = bv.bits(0, 0).get_value();
}



field_structure npl_mpls_encap_control_bits_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_encap_control_bits_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_midpoint);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_midpoint", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mpls_labels_lookup);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_labels_lookup", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_asbr_or_ldpote);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_asbr_or_ldpote", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_encap_control_bits_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_encap_control_bits_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_first_ene_macro_control_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 4, no_first_ene_macro);
    bv.set_bits(3, 3, vpn_label_lookup);
    bv.set_bits(2, 0, qos_first_macro_code);
    return bv;
}


void npl_mpls_first_ene_macro_control_t::unpack(bit_vector64_t bv) 
{
    no_first_ene_macro = bv.bits(4, 4).get_value();
    vpn_label_lookup = bv.bits(3, 3).get_value();
    qos_first_macro_code = (npl_qos_first_macro_code_e)bv.bits(2, 0).get_value();
}



field_structure npl_mpls_first_ene_macro_control_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_first_ene_macro_control_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(no_first_ene_macro);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_first_ene_macro", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_label_lookup);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_label_lookup", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(qos_first_macro_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_first_macro_code", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_first_ene_macro_control_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_first_ene_macro_control_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_header_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, illegal_ipv4);
    bv.set_bits(1, 1, is_null_labels);
    bv.set_bits(0, 0, is_bos);
    return bv;
}


void npl_mpls_header_flags_t::unpack(bit_vector64_t bv) 
{
    illegal_ipv4 = bv.bits(2, 2).get_value();
    is_null_labels = bv.bits(1, 1).get_value();
    is_bos = bv.bits(0, 0).get_value();
}



field_structure npl_mpls_header_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_header_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(illegal_ipv4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("illegal_ipv4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_null_labels);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_null_labels", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_bos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_bos", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_header_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_header_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 12, label);
    bv.set_bits(11, 9, exp);
    bv.set_bits(8, 8, bos);
    bv.set_bits(7, 0, ttl);
    return bv;
}


void npl_mpls_header_t::unpack(bit_vector64_t bv) 
{
    label = bv.bits(31, 12).get_value();
    exp = bv.bits(11, 9).get_value();
    bos = bv.bits(8, 8).get_value();
    ttl = bv.bits(7, 0).get_value();
}



field_structure npl_mpls_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(exp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("exp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_relay_packed_labels_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 48, adjust_next_hdr_offset);
    bv.set_bits(47, 16, label_above_null.pack());
    bv.set_bits(15, 0, next_label_above_null);
    return bv;
}


void npl_mpls_relay_packed_labels_t::unpack(bit_vector64_t bv) 
{
    adjust_next_hdr_offset = bv.bits(55, 48).get_value();
    label_above_null.unpack(bv.bits(47, 16));
    next_label_above_null = bv.bits(15, 0).get_value();
}



field_structure npl_mpls_relay_packed_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_relay_packed_labels_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(adjust_next_hdr_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("adjust_next_hdr_offset", fs_subfield);
    
    fs_result.subfields.emplace_back("label_above_null", label_above_null.to_field_structure());
    fs_subfield.flat_value = to_hex_string(next_label_above_null);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_label_above_null", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_relay_packed_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_relay_packed_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_mldp_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, rpf_id);
    return bv;
}


void npl_mpls_termination_mldp_t::unpack(bit_vector64_t bv) 
{
    rpf_id = bv.bits(15, 0).get_value();
}



field_structure npl_mpls_termination_mldp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_mldp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rpf_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rpf_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_termination_mldp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_mldp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_tp_em_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 0, dummy);
    return bv;
}


void npl_mpls_tp_em_t::unpack(bit_vector64_t bv) 
{
    dummy = bv.bits(39, 0).get_value();
}



field_structure npl_mpls_tp_em_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_tp_em_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dummy);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dummy", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_tp_em_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_tp_em_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 24, unknown_protocol_after_bos);
    bv.set_bits(23, 23, ttl_is_zero);
    bv.set_bits(22, 22, bfd_over_pwe_ttl);
    bv.set_bits(21, 21, bfd_over_pwe_raw);
    bv.set_bits(20, 20, bfd_over_pwe_ipv4);
    bv.set_bits(19, 19, bfd_over_pwe_ipv6);
    bv.set_bits(18, 18, unknown_bfd_g_ach_channel_type);
    bv.set_bits(17, 17, bfd_over_pwe_ra);
    bv.set_bits(16, 16, mpls_tp_over_pwe);
    bv.set_bits(15, 15, unknown_g_ach);
    bv.set_bits(14, 14, mpls_tp_over_lsp);
    bv.set_bits(13, 13, oam_alert_label);
    bv.set_bits(12, 12, extension_label);
    bv.set_bits(11, 11, router_alert_label);
    bv.set_bits(10, 10, unexpected_reserved_label);
    bv.set_bits(9, 9, forwarding_disabled);
    bv.set_bits(8, 8, ilm_miss);
    bv.set_bits(7, 7, ipv4_over_ipv6_explicit_null);
    bv.set_bits(6, 6, invalid_ttl);
    bv.set_bits(5, 5, te_midpopint_ldp_labels_miss);
    bv.set_bits(4, 4, asbr_label_miss);
    bv.set_bits(3, 3, ilm_vrf_label_miss);
    bv.set_bits(2, 2, pwe_pwach);
    bv.set_bits(1, 1, vpn_ttl_one);
    bv.set_bits(0, 0, missing_fwd_label_after_pop);
    return bv;
}


void npl_mpls_traps_t::unpack(bit_vector64_t bv) 
{
    unknown_protocol_after_bos = bv.bits(24, 24).get_value();
    ttl_is_zero = bv.bits(23, 23).get_value();
    bfd_over_pwe_ttl = bv.bits(22, 22).get_value();
    bfd_over_pwe_raw = bv.bits(21, 21).get_value();
    bfd_over_pwe_ipv4 = bv.bits(20, 20).get_value();
    bfd_over_pwe_ipv6 = bv.bits(19, 19).get_value();
    unknown_bfd_g_ach_channel_type = bv.bits(18, 18).get_value();
    bfd_over_pwe_ra = bv.bits(17, 17).get_value();
    mpls_tp_over_pwe = bv.bits(16, 16).get_value();
    unknown_g_ach = bv.bits(15, 15).get_value();
    mpls_tp_over_lsp = bv.bits(14, 14).get_value();
    oam_alert_label = bv.bits(13, 13).get_value();
    extension_label = bv.bits(12, 12).get_value();
    router_alert_label = bv.bits(11, 11).get_value();
    unexpected_reserved_label = bv.bits(10, 10).get_value();
    forwarding_disabled = bv.bits(9, 9).get_value();
    ilm_miss = bv.bits(8, 8).get_value();
    ipv4_over_ipv6_explicit_null = bv.bits(7, 7).get_value();
    invalid_ttl = bv.bits(6, 6).get_value();
    te_midpopint_ldp_labels_miss = bv.bits(5, 5).get_value();
    asbr_label_miss = bv.bits(4, 4).get_value();
    ilm_vrf_label_miss = bv.bits(3, 3).get_value();
    pwe_pwach = bv.bits(2, 2).get_value();
    vpn_ttl_one = bv.bits(1, 1).get_value();
    missing_fwd_label_after_pop = bv.bits(0, 0).get_value();
}



field_structure npl_mpls_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(unknown_protocol_after_bos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_protocol_after_bos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ttl_is_zero);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl_is_zero", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_over_pwe_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_over_pwe_ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_over_pwe_raw);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_over_pwe_raw", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_over_pwe_ipv4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_over_pwe_ipv4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_over_pwe_ipv6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_over_pwe_ipv6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_bfd_g_ach_channel_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_bfd_g_ach_channel_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_over_pwe_ra);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_over_pwe_ra", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mpls_tp_over_pwe);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_tp_over_pwe", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unknown_g_ach);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unknown_g_ach", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mpls_tp_over_lsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_tp_over_lsp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(oam_alert_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("oam_alert_label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(extension_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("extension_label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(router_alert_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("router_alert_label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unexpected_reserved_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unexpected_reserved_label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(forwarding_disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("forwarding_disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ilm_miss);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ilm_miss", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ipv4_over_ipv6_explicit_null);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ipv4_over_ipv6_explicit_null", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(invalid_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("invalid_ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(te_midpopint_ldp_labels_miss);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_midpopint_ldp_labels_miss", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(asbr_label_miss);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("asbr_label_miss", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ilm_vrf_label_miss);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ilm_vrf_label_miss", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pwe_pwach);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pwe_pwach", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_ttl_one);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_ttl_one", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(missing_fwd_label_after_pop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("missing_fwd_label_after_pop", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mpls_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ms_voq_fabric_context_offset_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, ms_voq_fabric_context_offset);
    return bv;
}


void npl_ms_voq_fabric_context_offset_table_result_t::unpack(bit_vector64_t bv) 
{
    ms_voq_fabric_context_offset = bv.bits(15, 0).get_value();
}



field_structure npl_ms_voq_fabric_context_offset_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ms_voq_fabric_context_offset_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ms_voq_fabric_context_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ms_voq_fabric_context_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ms_voq_fabric_context_offset_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ms_voq_fabric_context_offset_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_my_dummy_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, val);
    return bv;
}


void npl_my_dummy_result_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(7, 0).get_value();
}



field_structure npl_my_dummy_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_my_dummy_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_my_dummy_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_my_dummy_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_my_frag_max_result_128_t::pack(void) const 
{
    bit_vector128_t bv(0, 128);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 128 - 1;
        size_t msb = 0;
        const uint64_t * p = val;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_my_frag_max_result_128_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 128 - 1;
        size_t msb = 0;
        uint64_t * p = val;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_my_frag_max_result_128_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_my_frag_max_result_128_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 128 - 1;
        size_t msb = 0;
        const uint64_t * p = val;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_my_frag_max_result_128_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_my_frag_max_result_128_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_my_one_bit_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, val);
    return bv;
}


void npl_my_one_bit_result_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(0, 0).get_value();
}



field_structure npl_my_one_bit_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_my_one_bit_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_my_one_bit_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_my_one_bit_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_next_header_and_hop_limit_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, next_header);
    bv.set_bits(7, 0, hop_limit);
    return bv;
}


void npl_next_header_and_hop_limit_t::unpack(bit_vector64_t bv) 
{
    next_header = bv.bits(15, 8).get_value();
    hop_limit = bv.bits(7, 0).get_value();
}



field_structure npl_next_header_and_hop_limit_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_next_header_and_hop_limit_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(next_header);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_header", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(hop_limit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hop_limit", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_next_header_and_hop_limit_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_next_header_and_hop_limit_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_nhlfe_type_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 20, encap_type);
    bv.set_bits(19, 0, midpoint_nh_destination_encoding.pack());
    return bv;
}


void npl_nhlfe_type_attributes_t::unpack(bit_vector64_t bv) 
{
    encap_type = (npl_npu_encap_l3_header_type_e)bv.bits(23, 20).get_value();
    midpoint_nh_destination_encoding.unpack(bv.bits(19, 0));
}



field_structure npl_nhlfe_type_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_nhlfe_type_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("midpoint_nh_destination_encoding", midpoint_nh_destination_encoding.to_field_structure());
    return fs_result;
}
std::string to_string(npl_nhlfe_type_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_nhlfe_type_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npl_internal_info_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (tx_redirect_code != 0) {  // union primitive field start
        bv.set_bits(7, 0, tx_redirect_code);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_npl_internal_info_t::unpack(bit_vector64_t bv) // union
{
    tx_redirect_code = bv.bits(7, 0).get_value();
}



field_structure npl_npl_internal_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npl_internal_info_t";
    field_structure fs_subfield;
    //add members to result
    if (tx_redirect_code != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(tx_redirect_code);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_npl_internal_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npl_internal_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npp_sgt_map_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, security_group);
    return bv;
}


void npl_npp_sgt_map_header_t::unpack(bit_vector64_t bv) 
{
    security_group = bv.bits(15, 0).get_value();
}



field_structure npl_npp_sgt_map_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npp_sgt_map_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(security_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("security_group", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npp_sgt_map_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npp_sgt_map_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_app_pack_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 11, force_pipe_ttl);
    bv.set_bits(10, 8, is_inject_up_and_ip_first_fragment.pack());
    bv.set_bits(7, 0, ttl);
    return bv;
}


void npl_npu_app_pack_fields_t::unpack(bit_vector64_t bv) 
{
    force_pipe_ttl = bv.bits(11, 11).get_value();
    is_inject_up_and_ip_first_fragment.unpack(bv.bits(10, 8));
    ttl = bv.bits(7, 0).get_value();
}



field_structure npl_npu_app_pack_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_app_pack_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(force_pipe_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("force_pipe_ttl", fs_subfield);
    
    fs_result.subfields.emplace_back("is_inject_up_and_ip_first_fragment", is_inject_up_and_ip_first_fragment.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npu_app_pack_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_app_pack_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_encap_header_l2_dlp_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    // PADDING -  bv.set_bits(19, 18, padding);
    bv.set_bits(17, 0, l2_dlp.pack());
    return bv;
}


void npl_npu_encap_header_l2_dlp_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(19, 18).get_value();
    l2_dlp.unpack(bv.bits(17, 0));
}



field_structure npl_npu_encap_header_l2_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_encap_header_l2_dlp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("l2_dlp", l2_dlp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_encap_header_l2_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_encap_header_l2_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_npu_host_data_result_count_phase_t::pack(void) const 
{
    bit_vector192_t bv(0, 181);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 42;
        size_t max_msb = lsb + 139 - 1;
        size_t msb = 0;
        const uint64_t * p = mp_data;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    bv.set_bits(41, 30, dm_count_phase);
    bv.set_bits(29, 27, dm_period);
    bv.set_bits(26, 15, lm_count_phase);
    bv.set_bits(14, 12, lm_period);
    bv.set_bits(11, 0, ccm_count_phase);
    return bv;
}


void npl_npu_host_data_result_count_phase_t::unpack(bit_vector192_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 42;
        size_t max_msb = lsb + 139 - 1;
        size_t msb = 0;
        uint64_t * p = mp_data;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    dm_count_phase = bv.bits(41, 30).get_value();
    dm_period = bv.bits(29, 27).get_value();
    lm_count_phase = bv.bits(26, 15).get_value();
    lm_period = bv.bits(14, 12).get_value();
    ccm_count_phase = bv.bits(11, 0).get_value();
}



field_structure npl_npu_host_data_result_count_phase_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_host_data_result_count_phase_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 42;
        size_t max_msb = lsb + 139 - 1;
        size_t msb = 0;
        const uint64_t * p = mp_data;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    fs_subfield.flat_value = to_hex_string(dm_count_phase);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dm_count_phase", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dm_period);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dm_period", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lm_count_phase);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lm_count_phase", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lm_period);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lm_period", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ccm_count_phase);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ccm_count_phase", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npu_host_data_result_count_phase_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_host_data_result_count_phase_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_l3_mc_accounting_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, mcg_counter_ptr.pack());
    return bv;
}


void npl_npu_l3_mc_accounting_encap_data_t::unpack(bit_vector64_t bv) 
{
    mcg_counter_ptr.unpack(bv.bits(19, 0));
}



field_structure npl_npu_l3_mc_accounting_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_mc_accounting_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mcg_counter_ptr", mcg_counter_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_l3_mc_accounting_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_mc_accounting_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_num_labels_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    // PADDING -  bv.set_bits(19, 4, padding);
    bv.set_bits(3, 0, total_num_labels);
    return bv;
}


void npl_num_labels_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(19, 4).get_value();
    total_num_labels = bv.bits(3, 0).get_value();
}



field_structure npl_num_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_num_labels_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(total_num_labels);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("total_num_labels", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_num_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_num_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_num_outer_transport_labels_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 1, total_num_labels);
    bv.set_bits(0, 0, num_labels_is_3);
    return bv;
}


void npl_num_outer_transport_labels_t::unpack(bit_vector64_t bv) 
{
    total_num_labels = bv.bits(4, 1).get_value();
    num_labels_is_3 = bv.bits(0, 0).get_value();
}



field_structure npl_num_outer_transport_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_num_outer_transport_labels_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(total_num_labels);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("total_num_labels", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(num_labels_is_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_labels_is_3", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_num_outer_transport_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_num_outer_transport_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_oamp_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 24, eth_unknown_punt_reason);
    bv.set_bits(23, 23, eth_mep_mapping_failed);
    bv.set_bits(22, 22, eth_mp_type_mismatch);
    bv.set_bits(21, 21, eth_meg_level_mismatch);
    bv.set_bits(20, 20, eth_bad_md_name_format);
    bv.set_bits(19, 19, eth_unicast_da_no_match);
    bv.set_bits(18, 18, eth_multicast_da_no_match);
    bv.set_bits(17, 17, eth_wrong_meg_id_format);
    bv.set_bits(16, 16, eth_meg_id_no_match);
    bv.set_bits(15, 15, eth_ccm_period_no_match);
    bv.set_bits(14, 14, eth_ccm_tlv_no_match);
    bv.set_bits(13, 13, eth_lmm_tlv_no_match);
    bv.set_bits(12, 12, eth_not_supported_oam_opcode);
    bv.set_bits(11, 11, bfd_transport_not_supported);
    bv.set_bits(10, 10, bfd_session_lookup_failed);
    bv.set_bits(9, 9, bfd_incorrect_ttl);
    bv.set_bits(8, 8, bfd_invalid_protocol);
    bv.set_bits(7, 7, bfd_invalid_udp_port);
    bv.set_bits(6, 6, bfd_incorrect_version);
    bv.set_bits(5, 5, bfd_incorrect_address);
    bv.set_bits(4, 4, bfd_mismatch_discr);
    bv.set_bits(3, 3, bfd_state_flag_change);
    bv.set_bits(2, 2, bfd_session_received);
    bv.set_bits(1, 1, pfc_lookup_failed);
    bv.set_bits(0, 0, pfc_drop_invalid_rx);
    return bv;
}


void npl_oamp_traps_t::unpack(bit_vector64_t bv) 
{
    eth_unknown_punt_reason = bv.bits(24, 24).get_value();
    eth_mep_mapping_failed = bv.bits(23, 23).get_value();
    eth_mp_type_mismatch = bv.bits(22, 22).get_value();
    eth_meg_level_mismatch = bv.bits(21, 21).get_value();
    eth_bad_md_name_format = bv.bits(20, 20).get_value();
    eth_unicast_da_no_match = bv.bits(19, 19).get_value();
    eth_multicast_da_no_match = bv.bits(18, 18).get_value();
    eth_wrong_meg_id_format = bv.bits(17, 17).get_value();
    eth_meg_id_no_match = bv.bits(16, 16).get_value();
    eth_ccm_period_no_match = bv.bits(15, 15).get_value();
    eth_ccm_tlv_no_match = bv.bits(14, 14).get_value();
    eth_lmm_tlv_no_match = bv.bits(13, 13).get_value();
    eth_not_supported_oam_opcode = bv.bits(12, 12).get_value();
    bfd_transport_not_supported = bv.bits(11, 11).get_value();
    bfd_session_lookup_failed = bv.bits(10, 10).get_value();
    bfd_incorrect_ttl = bv.bits(9, 9).get_value();
    bfd_invalid_protocol = bv.bits(8, 8).get_value();
    bfd_invalid_udp_port = bv.bits(7, 7).get_value();
    bfd_incorrect_version = bv.bits(6, 6).get_value();
    bfd_incorrect_address = bv.bits(5, 5).get_value();
    bfd_mismatch_discr = bv.bits(4, 4).get_value();
    bfd_state_flag_change = bv.bits(3, 3).get_value();
    bfd_session_received = bv.bits(2, 2).get_value();
    pfc_lookup_failed = bv.bits(1, 1).get_value();
    pfc_drop_invalid_rx = bv.bits(0, 0).get_value();
}



field_structure npl_oamp_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_oamp_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(eth_unknown_punt_reason);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_unknown_punt_reason", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_mep_mapping_failed);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_mep_mapping_failed", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_mp_type_mismatch);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_mp_type_mismatch", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_meg_level_mismatch);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_meg_level_mismatch", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_bad_md_name_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_bad_md_name_format", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_unicast_da_no_match);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_unicast_da_no_match", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_multicast_da_no_match);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_multicast_da_no_match", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_wrong_meg_id_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_wrong_meg_id_format", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_meg_id_no_match);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_meg_id_no_match", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_ccm_period_no_match);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_ccm_period_no_match", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_ccm_tlv_no_match);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_ccm_tlv_no_match", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_lmm_tlv_no_match);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_lmm_tlv_no_match", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eth_not_supported_oam_opcode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_not_supported_oam_opcode", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_transport_not_supported);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_transport_not_supported", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_session_lookup_failed);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_session_lookup_failed", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_incorrect_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_incorrect_ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_invalid_protocol);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_invalid_protocol", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_invalid_udp_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_invalid_udp_port", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_incorrect_version);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_incorrect_version", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_incorrect_address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_incorrect_address", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_mismatch_discr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_mismatch_discr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_state_flag_change);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_state_flag_change", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bfd_session_received);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_session_received", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pfc_lookup_failed);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pfc_lookup_failed", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pfc_drop_invalid_rx);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pfc_drop_invalid_rx", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_oamp_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_oamp_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_obm_to_inject_packed_vars_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 20, redirect_code);
    bv.set_bits(19, 0, l2_slp);
    return bv;
}


void npl_obm_to_inject_packed_vars_t::unpack(bit_vector64_t bv) 
{
    redirect_code = bv.bits(27, 20).get_value();
    l2_slp = bv.bits(19, 0).get_value();
}



field_structure npl_obm_to_inject_packed_vars_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_obm_to_inject_packed_vars_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(redirect_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("redirect_code", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_slp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_slp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_obm_to_inject_packed_vars_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_obm_to_inject_packed_vars_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_lpm_compression_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 19, bits_n_18);
    bv.set_bits(18, 18, zero);
    bv.set_bits(17, 0, bits_17_0);
    return bv;
}


void npl_og_lpm_compression_code_t::unpack(bit_vector64_t bv) 
{
    bits_n_18 = bv.bits(24, 19).get_value();
    zero = bv.bits(18, 18).get_value();
    bits_17_0 = bv.bits(17, 0).get_value();
}



field_structure npl_og_lpm_compression_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_lpm_compression_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bits_n_18);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bits_n_18", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(zero);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("zero", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bits_17_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bits_17_0", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_og_lpm_compression_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_lpm_compression_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_lpts_compression_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, id);
    return bv;
}


void npl_og_lpts_compression_code_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(15, 0).get_value();
}



field_structure npl_og_lpts_compression_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_lpts_compression_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_og_lpts_compression_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_lpts_compression_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_pcl_compress_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, src_compress);
    bv.set_bits(0, 0, dest_compress);
    return bv;
}


void npl_og_pcl_compress_t::unpack(bit_vector64_t bv) 
{
    src_compress = bv.bits(1, 1).get_value();
    dest_compress = bv.bits(0, 0).get_value();
}



field_structure npl_og_pcl_compress_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_pcl_compress_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(src_compress);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("src_compress", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_compress);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_compress", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_og_pcl_compress_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_pcl_compress_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_pcl_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, val);
    return bv;
}


void npl_og_pcl_id_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(7, 0).get_value();
}



field_structure npl_og_pcl_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_pcl_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_og_pcl_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_pcl_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_pcl_ids_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, src_pcl_id.pack());
    bv.set_bits(7, 0, dest_pcl_id.pack());
    return bv;
}


void npl_og_pcl_ids_t::unpack(bit_vector64_t bv) 
{
    src_pcl_id.unpack(bv.bits(15, 8));
    dest_pcl_id.unpack(bv.bits(7, 0));
}



field_structure npl_og_pcl_ids_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_pcl_ids_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("src_pcl_id", src_pcl_id.to_field_structure());
    fs_result.subfields.emplace_back("dest_pcl_id", dest_pcl_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_og_pcl_ids_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_pcl_ids_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_pd_compression_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 18, bits_n_18);
    bv.set_bits(17, 0, bits_17_0);
    return bv;
}


void npl_og_pd_compression_code_t::unpack(bit_vector64_t bv) 
{
    bits_n_18 = bv.bits(23, 18).get_value();
    bits_17_0 = bv.bits(17, 0).get_value();
}



field_structure npl_og_pd_compression_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_pd_compression_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bits_n_18);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bits_n_18", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(bits_17_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bits_17_0", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_og_pd_compression_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_pd_compression_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_omd_txpp_parsed_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 6, oq_pair);
    bv.set_bits(5, 1, pif);
    bv.set_bits(0, 0, ifg);
    return bv;
}


void npl_omd_txpp_parsed_t::unpack(bit_vector64_t bv) 
{
    oq_pair = bv.bits(7, 6).get_value();
    pif = bv.bits(5, 1).get_value();
    ifg = bv.bits(0, 0).get_value();
}



field_structure npl_omd_txpp_parsed_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_omd_txpp_parsed_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(oq_pair);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("oq_pair", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pif);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pif", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ifg", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_omd_txpp_parsed_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_omd_txpp_parsed_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_oq_group_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, val);
    return bv;
}


void npl_oq_group_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(7, 0).get_value();
}



field_structure npl_oq_group_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_oq_group_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_oq_group_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_oq_group_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_oqse_pair_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, index);
    return bv;
}


void npl_oqse_pair_t::unpack(bit_vector64_t bv) 
{
    index = bv.bits(7, 0).get_value();
}



field_structure npl_oqse_pair_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_oqse_pair_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("index", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_oqse_pair_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_oqse_pair_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_oqse_topology_4p_t::pack(void) const // union
{
    bit_vector64_t bv(0, 2);
    if (lpse_tpse_4p != 0) {  // union primitive field start
        bv.set_bits(1, 0, lpse_tpse_4p);
        return bv;
    }// union primitive field end
    
    if (lpse_2p != 0) {  // union primitive field start
        bv.set_bits(1, 0, lpse_2p);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_oqse_topology_4p_t::unpack(bit_vector64_t bv) // union
{
    lpse_tpse_4p = (npl_oqse_topology_4p_e)bv.bits(1, 0).get_value();
}



field_structure npl_oqse_topology_4p_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_oqse_topology_4p_t";
    field_structure fs_subfield;
    //add members to result
    if (lpse_tpse_4p != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lpse_tpse_4p);
        return union_found;
    }// union primitive field end
    
    if (lpse_2p != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lpse_2p);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_oqse_topology_4p_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_oqse_topology_4p_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_overlay_nh_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 68);
    bv.set_bits(67, 20, mac_da);
    bv.set_bits(19, 16, sa_prefix_index);
    bv.set_bits(15, 0, sa_lsb);
    return bv;
}


void npl_overlay_nh_data_t::unpack(bit_vector128_t bv) 
{
    mac_da = bv.bits(67, 20).get_value();
    sa_prefix_index = bv.bits(19, 16).get_value();
    sa_lsb = bv.bits(15, 0).get_value();
}



field_structure npl_overlay_nh_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_overlay_nh_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mac_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_da", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_prefix_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_prefix_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sa_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_lsb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_overlay_nh_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_overlay_nh_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_override_enable_ipv4_ipv6_uc_bits_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, override_enable_ipv4_uc);
    bv.set_bits(0, 0, override_enable_ipv6_uc);
    return bv;
}


void npl_override_enable_ipv4_ipv6_uc_bits_t::unpack(bit_vector64_t bv) 
{
    override_enable_ipv4_uc = bv.bits(1, 1).get_value();
    override_enable_ipv6_uc = bv.bits(0, 0).get_value();
}



field_structure npl_override_enable_ipv4_ipv6_uc_bits_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_override_enable_ipv4_ipv6_uc_bits_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(override_enable_ipv4_uc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_enable_ipv4_uc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(override_enable_ipv6_uc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_enable_ipv6_uc", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_override_enable_ipv4_ipv6_uc_bits_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_override_enable_ipv4_ipv6_uc_bits_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_packed_ud_160_key_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        const uint64_t * p = key;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_packed_ud_160_key_t::unpack(bit_vector192_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        uint64_t * p = key;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_packed_ud_160_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_packed_ud_160_key_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 160 - 1;
        size_t msb = 0;
        const uint64_t * p = key;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_packed_ud_160_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_packed_ud_160_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_packed_ud_320_key_t::pack(void) const 
{
    bit_vector384_t bv(0, 320);
    bv.set_bits(319, 160, key_part0.pack());
    bv.set_bits(159, 0, key_part1.pack());
    return bv;
}


void npl_packed_ud_320_key_t::unpack(bit_vector384_t bv) 
{
    key_part0.unpack(bv.bits(319, 160));
    key_part1.unpack(bv.bits(159, 0));
}



field_structure npl_packed_ud_320_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_packed_ud_320_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("key_part0", key_part0.to_field_structure());
    fs_result.subfields.emplace_back("key_part1", key_part1.to_field_structure());
    return fs_result;
}
std::string to_string(npl_packed_ud_320_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_packed_ud_320_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_padding_for_sm_tcam_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = junk;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_padding_for_sm_tcam_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        uint64_t * p = junk;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_padding_for_sm_tcam_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_padding_for_sm_tcam_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = junk;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_padding_for_sm_tcam_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_padding_for_sm_tcam_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_padding_or_ipv6_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    // PADDING -  bv.set_bits(11, 0, padding);
    return bv;
}


void npl_padding_or_ipv6_len_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(11, 0).get_value();
}



field_structure npl_padding_or_ipv6_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_padding_or_ipv6_len_t";
    field_structure fs_subfield;
    //add members to result
    
    return fs_result;
}
std::string to_string(npl_padding_or_ipv6_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_padding_or_ipv6_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pbts_map_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 23);
    bv.set_bits(22, 20, pbts_offset);
    bv.set_bits(19, 18, destination_shift);
    bv.set_bits(17, 0, and_mask);
    return bv;
}


void npl_pbts_map_result_t::unpack(bit_vector64_t bv) 
{
    pbts_offset = bv.bits(22, 20).get_value();
    destination_shift = bv.bits(19, 18).get_value();
    and_mask = bv.bits(17, 0).get_value();
}



field_structure npl_pbts_map_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pbts_map_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(pbts_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pbts_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_shift);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_shift", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(and_mask);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("and_mask", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pbts_map_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pbts_map_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pcp_dei_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 1, pcp);
    bv.set_bits(0, 0, dei);
    return bv;
}


void npl_pcp_dei_t::unpack(bit_vector64_t bv) 
{
    pcp = bv.bits(3, 1).get_value();
    dei = bv.bits(0, 0).get_value();
}



field_structure npl_pcp_dei_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pcp_dei_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(pcp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pcp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dei);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dei", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pcp_dei_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pcp_dei_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_pd_lp_attributes_t::pack(void) const 
{
    bit_vector192_t bv(0, 142);
    // PADDING -  bv.set_bits(141, 120, padding);
    bv.set_bits(119, 0, update.pack());
    return bv;
}


void npl_pd_lp_attributes_t::unpack(bit_vector192_t bv) 
{
    // PADDING -  padding = bv.bits(141, 120).get_value();
    update.unpack(bv.bits(119, 0));
}



field_structure npl_pd_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pd_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("update", update.to_field_structure());
    return fs_result;
}
std::string to_string(npl_pd_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pd_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pd_rx_slb_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, eos);
    bv.set_bits(0, 0, close_prev_segment);
    return bv;
}


void npl_pd_rx_slb_t::unpack(bit_vector64_t bv) 
{
    eos = bv.bits(1, 1).get_value();
    close_prev_segment = bv.bits(0, 0).get_value();
}



field_structure npl_pd_rx_slb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pd_rx_slb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(eos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(close_prev_segment);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("close_prev_segment", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pd_rx_slb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pd_rx_slb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pd_svl_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 7, svl_dsp_remote_flag);
    bv.set_bits(6, 6, svl_encap_forward_flag);
    // PADDING -  bv.set_bits(5, 5, padding);
    bv.set_bits(4, 4, svl_bvn_flag);
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_pd_svl_attributes_t::unpack(bit_vector64_t bv) 
{
    svl_dsp_remote_flag = bv.bits(7, 7).get_value();
    svl_encap_forward_flag = bv.bits(6, 6).get_value();
    // PADDING -  padding = bv.bits(5, 5).get_value();
    svl_bvn_flag = bv.bits(4, 4).get_value();
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_pd_svl_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pd_svl_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(svl_dsp_remote_flag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svl_dsp_remote_flag", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(svl_encap_forward_flag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svl_encap_forward_flag", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(svl_bvn_flag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svl_bvn_flag", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_pd_svl_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pd_svl_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pdoq_oq_ifc_mapping_result_t_anonymous_union_txpp_map_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    { // union compound field start
        bit_vector64_t tbv = parsed.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (raw != 0) {  // union primitive field start
        bv.set_bits(7, 0, raw);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_pdoq_oq_ifc_mapping_result_t_anonymous_union_txpp_map_data_t::unpack(bit_vector64_t bv) // union
{
    parsed.unpack(bv.bits(7, 0));
}



field_structure npl_pdoq_oq_ifc_mapping_result_t_anonymous_union_txpp_map_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pdoq_oq_ifc_mapping_result_t_anonymous_union_txpp_map_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = parsed.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("parsed", parsed.to_field_structure());
        }
    } // union compound field end
    
    if (raw != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(raw);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_pdoq_oq_ifc_mapping_result_t_anonymous_union_txpp_map_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pdoq_oq_ifc_mapping_result_t_anonymous_union_txpp_map_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pdvoq_bank_pair_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, value);
    return bv;
}


void npl_pdvoq_bank_pair_offset_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(0, 0).get_value();
}



field_structure npl_pdvoq_bank_pair_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pdvoq_bank_pair_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pdvoq_bank_pair_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pdvoq_bank_pair_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_per_rtf_step_og_pcl_compress_bits_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 2, ipv4_compress_bits.pack());
    bv.set_bits(1, 0, ipv6_compress_bits.pack());
    return bv;
}


void npl_per_rtf_step_og_pcl_compress_bits_t::unpack(bit_vector64_t bv) 
{
    ipv4_compress_bits.unpack(bv.bits(3, 2));
    ipv6_compress_bits.unpack(bv.bits(1, 0));
}



field_structure npl_per_rtf_step_og_pcl_compress_bits_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_per_rtf_step_og_pcl_compress_bits_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ipv4_compress_bits", ipv4_compress_bits.to_field_structure());
    fs_result.subfields.emplace_back("ipv6_compress_bits", ipv6_compress_bits.to_field_structure());
    return fs_result;
}
std::string to_string(npl_per_rtf_step_og_pcl_compress_bits_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_per_rtf_step_og_pcl_compress_bits_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_per_rtf_step_og_pcl_ids_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, ipv4_og_pcl_ids.pack());
    bv.set_bits(15, 0, ipv6_og_pcl_ids.pack());
    return bv;
}


void npl_per_rtf_step_og_pcl_ids_t::unpack(bit_vector64_t bv) 
{
    ipv4_og_pcl_ids.unpack(bv.bits(31, 16));
    ipv6_og_pcl_ids.unpack(bv.bits(15, 0));
}



field_structure npl_per_rtf_step_og_pcl_ids_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_per_rtf_step_og_pcl_ids_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ipv4_og_pcl_ids", ipv4_og_pcl_ids.to_field_structure());
    fs_result.subfields.emplace_back("ipv6_og_pcl_ids", ipv6_og_pcl_ids.to_field_structure());
    return fs_result;
}
std::string to_string(npl_per_rtf_step_og_pcl_ids_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_per_rtf_step_og_pcl_ids_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_pfc_aux_payload_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 140, rx_counter.pack());
    return bv;
}


void npl_pfc_aux_payload_t::unpack(bit_vector192_t bv) 
{
    rx_counter.unpack(bv.bits(159, 140));
}



field_structure npl_pfc_aux_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_aux_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("rx_counter", rx_counter.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_pfc_aux_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_aux_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pfc_em_lookup_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 20, destination);
    bv.set_bits(19, 0, some_padding);
    return bv;
}


void npl_pfc_em_lookup_t::unpack(bit_vector64_t bv) 
{
    destination = bv.bits(39, 20).get_value();
    some_padding = bv.bits(19, 0).get_value();
}



field_structure npl_pfc_em_lookup_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_em_lookup_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(some_padding);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("some_padding", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pfc_em_lookup_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_em_lookup_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pfc_em_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    // PADDING -  bv.set_bits(39, 29, padding);
    bv.set_bits(28, 16, rmep_id);
    bv.set_bits(15, 3, mep_id);
    bv.set_bits(2, 2, access_rmep);
    bv.set_bits(1, 1, mp_data_select);
    bv.set_bits(0, 0, access_mp);
    return bv;
}


void npl_pfc_em_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(39, 29).get_value();
    rmep_id = bv.bits(28, 16).get_value();
    mep_id = bv.bits(15, 3).get_value();
    access_rmep = bv.bits(2, 2).get_value();
    mp_data_select = bv.bits(1, 1).get_value();
    access_mp = bv.bits(0, 0).get_value();
}



field_structure npl_pfc_em_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_em_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(rmep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mep_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(access_rmep);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_rmep", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mp_data_select);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_data_select", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(access_mp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("access_mp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pfc_em_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_em_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pfc_rx_counter_offset_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, value);
    return bv;
}


void npl_pfc_rx_counter_offset_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(3, 0).get_value();
}



field_structure npl_pfc_rx_counter_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_rx_counter_offset_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pfc_rx_counter_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_rx_counter_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pfc_ssp_info_table_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 13, slice);
    bv.set_bits(12, 0, mp_id);
    return bv;
}


void npl_pfc_ssp_info_table_t::unpack(bit_vector64_t bv) 
{
    slice = bv.bits(15, 13).get_value();
    mp_id = bv.bits(12, 0).get_value();
}



field_structure npl_pfc_ssp_info_table_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_ssp_info_table_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(slice);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slice", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mp_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pfc_ssp_info_table_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_ssp_info_table_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_phb_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 2, tc);
    bv.set_bits(1, 0, dp);
    return bv;
}


void npl_phb_t::unpack(bit_vector64_t bv) 
{
    tc = bv.bits(4, 2).get_value();
    dp = bv.bits(1, 0).get_value();
}



field_structure npl_phb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_phb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_phb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_phb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pif_ifg_base_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 1, pif);
    bv.set_bits(0, 0, ifg);
    return bv;
}


void npl_pif_ifg_base_t::unpack(bit_vector64_t bv) 
{
    pif = bv.bits(5, 1).get_value();
    ifg = bv.bits(0, 0).get_value();
}



field_structure npl_pif_ifg_base_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pif_ifg_base_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(pif);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pif", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ifg", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pif_ifg_base_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pif_ifg_base_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pma_loopback_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, mode);
    return bv;
}


void npl_pma_loopback_data_t::unpack(bit_vector64_t bv) 
{
    mode = (npl_loopback_mode_e)bv.bits(1, 0).get_value();
}



field_structure npl_pma_loopback_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pma_loopback_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mode", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pma_loopback_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pma_loopback_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_properties_t_anonymous_union_monitor_or_l3_dlp_ip_type_t::pack(void) const // union
{
    bit_vector64_t bv(0, 1);
    if (l3_dlp_ip_type != 0) {  // union primitive field start
        bv.set_bits(0, 0, l3_dlp_ip_type);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = enable_monitor.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(0, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_properties_t_anonymous_union_monitor_or_l3_dlp_ip_type_t::unpack(bit_vector64_t bv) // union
{
    l3_dlp_ip_type = (npl_l3_dlp_ip_type_e)bv.bits(0, 0).get_value();
}



field_structure npl_properties_t_anonymous_union_monitor_or_l3_dlp_ip_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_properties_t_anonymous_union_monitor_or_l3_dlp_ip_type_t";
    field_structure fs_subfield;
    //add members to result
    if (l3_dlp_ip_type != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(l3_dlp_ip_type);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = enable_monitor.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("enable_monitor", enable_monitor.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_properties_t_anonymous_union_monitor_or_l3_dlp_ip_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_properties_t_anonymous_union_monitor_or_l3_dlp_ip_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_protocol_type_padded_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, protocol_type);
    // PADDING -  bv.set_bits(7, 0, padding);
    return bv;
}


void npl_protocol_type_padded_t::unpack(bit_vector64_t bv) 
{
    protocol_type = bv.bits(15, 8).get_value();
    // PADDING -  padding = bv.bits(7, 0).get_value();
}



field_structure npl_protocol_type_padded_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_protocol_type_padded_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(protocol_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("protocol_type", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_protocol_type_padded_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_protocol_type_padded_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_controls_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 1, punt_format);
    bv.set_bits(0, 0, mirror_local_encap_format);
    return bv;
}


void npl_punt_controls_t::unpack(bit_vector64_t bv) 
{
    punt_format = (npl_punt_header_format_type_e)bv.bits(2, 1).get_value();
    mirror_local_encap_format = bv.bits(0, 0).get_value();
}



field_structure npl_punt_controls_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_controls_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(punt_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_format", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mirror_local_encap_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mirror_local_encap_format", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_controls_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_controls_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_encap_data_lsb_t_anonymous_union_extra_t::pack(void) const // union
{
    bit_vector64_t bv(0, 1);
    if (lpts_meter_index_msb != 0) {  // union primitive field start
        bv.set_bits(0, 0, lpts_meter_index_msb);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_punt_encap_data_lsb_t_anonymous_union_extra_t::unpack(bit_vector64_t bv) // union
{
    
}



field_structure npl_punt_encap_data_lsb_t_anonymous_union_extra_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_encap_data_lsb_t_anonymous_union_extra_t";
    field_structure fs_subfield;
    //add members to result
    if (lpts_meter_index_msb != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lpts_meter_index_msb);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_punt_encap_data_lsb_t_anonymous_union_extra_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_encap_data_lsb_t_anonymous_union_extra_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_punt_eth_transport_update_t::pack(void) const 
{
    bit_vector128_t bv(0, 92);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 92 - 1;
        size_t msb = 0;
        const uint64_t * p = update;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_punt_eth_transport_update_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 92 - 1;
        size_t msb = 0;
        uint64_t * p = update;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_punt_eth_transport_update_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_eth_transport_update_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 92 - 1;
        size_t msb = 0;
        const uint64_t * p = update;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_punt_eth_transport_update_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_eth_transport_update_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_header_t_anonymous_union_pl_header_offset_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (ingress_next_pl_offset != 0) {  // union primitive field start
        bv.set_bits(7, 0, ingress_next_pl_offset);
        return bv;
    }// union primitive field end
    
    if (egress_current_pl_offset != 0) {  // union primitive field start
        bv.set_bits(7, 0, egress_current_pl_offset);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_punt_header_t_anonymous_union_pl_header_offset_t::unpack(bit_vector64_t bv) // union
{
    ingress_next_pl_offset = bv.bits(7, 0).get_value();
}



field_structure npl_punt_header_t_anonymous_union_pl_header_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_header_t_anonymous_union_pl_header_offset_t";
    field_structure fs_subfield;
    //add members to result
    if (ingress_next_pl_offset != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(ingress_next_pl_offset);
        return union_found;
    }// union primitive field end
    
    if (egress_current_pl_offset != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(egress_current_pl_offset);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_punt_header_t_anonymous_union_pl_header_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_header_t_anonymous_union_pl_header_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_l2_lp_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 0, id);
    return bv;
}


void npl_punt_l2_lp_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(17, 0).get_value();
}



field_structure npl_punt_l2_lp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_l2_lp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_l2_lp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_l2_lp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_npu_host_macro_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, first_fi_macro_id);
    bv.set_bits(7, 0, first_npe_macro_id);
    return bv;
}


void npl_punt_npu_host_macro_data_t::unpack(bit_vector64_t bv) 
{
    first_fi_macro_id = bv.bits(15, 8).get_value();
    first_npe_macro_id = bv.bits(7, 0).get_value();
}



field_structure npl_punt_npu_host_macro_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_npu_host_macro_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(first_fi_macro_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("first_fi_macro_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(first_npe_macro_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("first_npe_macro_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_npu_host_macro_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_npu_host_macro_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_nw_encap_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, ptr);
    return bv;
}


void npl_punt_nw_encap_ptr_t::unpack(bit_vector64_t bv) 
{
    ptr = bv.bits(7, 0).get_value();
}



field_structure npl_punt_nw_encap_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_nw_encap_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ptr", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_nw_encap_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_nw_encap_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_rcy_pack_table_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 8, ive_reset);
    bv.set_bits(7, 0, redirect_code);
    return bv;
}


void npl_punt_rcy_pack_table_payload_t::unpack(bit_vector64_t bv) 
{
    ive_reset = bv.bits(23, 8).get_value();
    redirect_code = bv.bits(7, 0).get_value();
}



field_structure npl_punt_rcy_pack_table_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_rcy_pack_table_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ive_reset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ive_reset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(redirect_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("redirect_code", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_rcy_pack_table_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_rcy_pack_table_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_ssp_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 15, padding);
    bv.set_bits(14, 12, slice_id);
    bv.set_bits(11, 0, ssp_12);
    return bv;
}


void npl_punt_ssp_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 15).get_value();
    slice_id = bv.bits(14, 12).get_value();
    ssp_12 = bv.bits(11, 0).get_value();
}



field_structure npl_punt_ssp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_ssp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(slice_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slice_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ssp_12);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ssp_12", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_ssp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_ssp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_sub_code_t_anonymous_union_sub_code_t::pack(void) const // union
{
    bit_vector64_t bv(0, 4);
    { // union compound field start
        bit_vector64_t tbv = lpts_flow_type.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(3, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_punt_sub_code_t_anonymous_union_sub_code_t::unpack(bit_vector64_t bv) // union
{
    lpts_flow_type.unpack(bv.bits(3, 0));
}



field_structure npl_punt_sub_code_t_anonymous_union_sub_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_sub_code_t_anonymous_union_sub_code_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = lpts_flow_type.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lpts_flow_type", lpts_flow_type.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_punt_sub_code_t_anonymous_union_sub_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_sub_code_t_anonymous_union_sub_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pwe_to_l3_lookup_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, destination);
    return bv;
}


void npl_pwe_to_l3_lookup_result_t::unpack(bit_vector64_t bv) 
{
    destination = bv.bits(19, 0).get_value();
}



field_structure npl_pwe_to_l3_lookup_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pwe_to_l3_lookup_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pwe_to_l3_lookup_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pwe_to_l3_lookup_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_and_acl_ids_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, qos_id);
    bv.set_bits(3, 0, acl_id);
    return bv;
}


void npl_qos_and_acl_ids_t::unpack(bit_vector64_t bv) 
{
    qos_id = bv.bits(7, 4).get_value();
    acl_id = bv.bits(3, 0).get_value();
}



field_structure npl_qos_and_acl_ids_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_and_acl_ids_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(qos_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_qos_and_acl_ids_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_and_acl_ids_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 46);
    bv.set_bits(45, 45, demux_count);
    bv.set_bits(44, 44, is_group_qos);
    bv.set_bits(43, 24, q_counter.pack());
    bv.set_bits(23, 4, p_counter.pack());
    bv.set_bits(3, 0, qos_id);
    return bv;
}


void npl_qos_attributes_t::unpack(bit_vector64_t bv) 
{
    demux_count = bv.bits(45, 45).get_value();
    is_group_qos = bv.bits(44, 44).get_value();
    q_counter.unpack(bv.bits(43, 24));
    p_counter.unpack(bv.bits(23, 4));
    qos_id = bv.bits(3, 0).get_value();
}



field_structure npl_qos_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(demux_count);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("demux_count", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_group_qos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_group_qos", fs_subfield);
    
    fs_result.subfields.emplace_back("q_counter", q_counter.to_field_structure());
    fs_result.subfields.emplace_back("p_counter", p_counter.to_field_structure());
    fs_subfield.flat_value = to_hex_string(qos_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_qos_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, tos);
    bv.set_bits(7, 4, exp_no_bos.pack());
    bv.set_bits(3, 0, pcp_dei);
    return bv;
}


void npl_qos_encap_t::unpack(bit_vector64_t bv) 
{
    tos = bv.bits(15, 8).get_value();
    exp_no_bos.unpack(bv.bits(7, 4));
    pcp_dei = bv.bits(3, 0).get_value();
}



field_structure npl_qos_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tos", fs_subfield);
    
    fs_result.subfields.emplace_back("exp_no_bos", exp_no_bos.to_field_structure());
    fs_subfield.flat_value = to_hex_string(pcp_dei);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pcp_dei", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_qos_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 4, is_group_qos);
    bv.set_bits(3, 0, qos_id);
    return bv;
}


void npl_qos_info_t::unpack(bit_vector64_t bv) 
{
    is_group_qos = bv.bits(4, 4).get_value();
    qos_id = bv.bits(3, 0).get_value();
}



field_structure npl_qos_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_group_qos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_group_qos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(qos_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_qos_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_tag_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    // PADDING -  bv.set_bits(7, 7, padding);
    bv.set_bits(6, 0, val);
    return bv;
}


void npl_qos_tag_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(7, 7).get_value();
    val = bv.bits(6, 0).get_value();
}



field_structure npl_qos_tag_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_tag_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_qos_tag_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_tag_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_tags_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 16, mapping_key.pack());
    bv.set_bits(15, 8, outer.pack());
    bv.set_bits(7, 0, inner.pack());
    return bv;
}


void npl_qos_tags_t::unpack(bit_vector64_t bv) 
{
    mapping_key.unpack(bv.bits(23, 16));
    outer.unpack(bv.bits(15, 8));
    inner.unpack(bv.bits(7, 0));
}



field_structure npl_qos_tags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_tags_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mapping_key", mapping_key.to_field_structure());
    fs_result.subfields.emplace_back("outer", outer.to_field_structure());
    fs_result.subfields.emplace_back("inner", inner.to_field_structure());
    return fs_result;
}
std::string to_string(npl_qos_tags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_tags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_13b::pack(void) const 
{
    bit_vector64_t bv(0, 13);
    bv.set_bits(12, 0, value);
    return bv;
}


void npl_quan_13b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(12, 0).get_value();
}



field_structure npl_quan_13b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_13b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_13b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_13b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_14b::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 0, value);
    return bv;
}


void npl_quan_14b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(13, 0).get_value();
}



field_structure npl_quan_14b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_14b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_14b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_14b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_15b::pack(void) const 
{
    bit_vector64_t bv(0, 15);
    bv.set_bits(14, 0, value);
    return bv;
}


void npl_quan_15b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(14, 0).get_value();
}



field_structure npl_quan_15b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_15b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_15b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_15b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_17b::pack(void) const 
{
    bit_vector64_t bv(0, 17);
    bv.set_bits(16, 0, value);
    return bv;
}


void npl_quan_17b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(16, 0).get_value();
}



field_structure npl_quan_17b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_17b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_17b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_17b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_19b::pack(void) const 
{
    bit_vector64_t bv(0, 19);
    bv.set_bits(18, 0, value);
    return bv;
}


void npl_quan_19b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(18, 0).get_value();
}



field_structure npl_quan_19b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_19b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_19b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_19b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_1b::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, value);
    return bv;
}


void npl_quan_1b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(0, 0).get_value();
}



field_structure npl_quan_1b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_1b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_1b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_1b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_2b::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, value);
    return bv;
}


void npl_quan_2b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(1, 0).get_value();
}



field_structure npl_quan_2b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_2b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_2b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_2b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_3b::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 0, value);
    return bv;
}


void npl_quan_3b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(2, 0).get_value();
}



field_structure npl_quan_3b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_3b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_3b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_3b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_4b::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, value);
    return bv;
}


void npl_quan_4b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(3, 0).get_value();
}



field_structure npl_quan_4b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_4b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_4b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_4b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_5b::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, value);
    return bv;
}


void npl_quan_5b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(4, 0).get_value();
}



field_structure npl_quan_5b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_5b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_5b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_5b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_quan_8b::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, value);
    return bv;
}


void npl_quan_8b::unpack(bit_vector64_t bv) 
{
    value = bv.bits(7, 0).get_value();
}



field_structure npl_quan_8b::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_quan_8b";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_quan_8b element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_quan_8b element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_random_bc_bmp_entry_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 0, rnd_entry);
    return bv;
}


void npl_random_bc_bmp_entry_t::unpack(bit_vector64_t bv) 
{
    rnd_entry = bv.bits(6, 0).get_value();
}



field_structure npl_random_bc_bmp_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_random_bc_bmp_entry_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rnd_entry);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rnd_entry", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_random_bc_bmp_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_random_bc_bmp_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rate_limiters_port_packet_type_index_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, value);
    return bv;
}


void npl_rate_limiters_port_packet_type_index_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(7, 0).get_value();
}



field_structure npl_rate_limiters_port_packet_type_index_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rate_limiters_port_packet_type_index_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rate_limiters_port_packet_type_index_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rate_limiters_port_packet_type_index_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_raw_lp_over_lag_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 4, bvn_destination);
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_raw_lp_over_lag_result_t::unpack(bit_vector64_t bv) 
{
    bvn_destination = bv.bits(23, 4).get_value();
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_raw_lp_over_lag_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_raw_lp_over_lag_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(bvn_destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bvn_destination", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_raw_lp_over_lag_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_raw_lp_over_lag_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rcy_sm_vlans_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 12, vid1);
    bv.set_bits(11, 0, vid2);
    return bv;
}


void npl_rcy_sm_vlans_t::unpack(bit_vector64_t bv) 
{
    vid1 = bv.bits(23, 12).get_value();
    vid2 = bv.bits(11, 0).get_value();
}



field_structure npl_rcy_sm_vlans_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rcy_sm_vlans_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(vid1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vid1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vid2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vid2", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rcy_sm_vlans_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rcy_sm_vlans_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_reassembly_source_port_map_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 5, ifg);
    bv.set_bits(4, 0, pif);
    return bv;
}


void npl_reassembly_source_port_map_key_t::unpack(bit_vector64_t bv) 
{
    ifg = bv.bits(5, 5).get_value();
    pif = bv.bits(4, 0).get_value();
}



field_structure npl_reassembly_source_port_map_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_reassembly_source_port_map_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ifg", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pif);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pif", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_reassembly_source_port_map_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_reassembly_source_port_map_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_reassembly_source_port_map_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 0, tm_ifc);
    return bv;
}


void npl_reassembly_source_port_map_result_t::unpack(bit_vector64_t bv) 
{
    tm_ifc = bv.bits(5, 0).get_value();
}



field_structure npl_reassembly_source_port_map_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_reassembly_source_port_map_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tm_ifc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tm_ifc", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_reassembly_source_port_map_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_reassembly_source_port_map_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_redirect_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, val);
    return bv;
}


void npl_redirect_code_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(7, 0).get_value();
}



field_structure npl_redirect_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_redirect_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_redirect_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_redirect_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_redirect_destination_reg_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, port_reg);
    return bv;
}


void npl_redirect_destination_reg_t::unpack(bit_vector64_t bv) 
{
    port_reg = (npl_redirect_destination_e)bv.bits(1, 0).get_value();
}



field_structure npl_redirect_destination_reg_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_redirect_destination_reg_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(port_reg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("port_reg", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_redirect_destination_reg_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_redirect_destination_reg_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_relay_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 0, id);
    return bv;
}


void npl_relay_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(13, 0).get_value();
}



field_structure npl_relay_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_relay_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_relay_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_relay_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_dest_type_decoding_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 0, dest_type);
    return bv;
}


void npl_resolution_dest_type_decoding_key_t::unpack(bit_vector64_t bv) 
{
    dest_type = bv.bits(5, 0).get_value();
}



field_structure npl_resolution_dest_type_decoding_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_dest_type_decoding_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dest_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_dest_type_decoding_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_dest_type_decoding_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_dest_type_decoding_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 6, destination_source_for_enc_data);
    bv.set_bits(5, 5, is_pbts);
    bv.set_bits(4, 4, add_qos_mapping);
    bv.set_bits(3, 3, dest_type);
    bv.set_bits(2, 0, table_id);
    return bv;
}


void npl_resolution_dest_type_decoding_result_t::unpack(bit_vector64_t bv) 
{
    destination_source_for_enc_data = (npl_resolution_dest_src_to_encap_mode_e)bv.bits(6, 6).get_value();
    is_pbts = (npl_resolution_pbts_mode_e)bv.bits(5, 5).get_value();
    add_qos_mapping = (npl_resolution_add_qos_mapping_mode_e)bv.bits(4, 4).get_value();
    dest_type = (npl_resolution_em_selector_e)bv.bits(3, 3).get_value();
    table_id = (npl_resolution_table_e)bv.bits(2, 0).get_value();
}



field_structure npl_resolution_dest_type_decoding_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_dest_type_decoding_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(destination_source_for_enc_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_source_for_enc_data", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(is_pbts);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_pbts", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(add_qos_mapping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("add_qos_mapping", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(dest_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_type", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(table_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("table_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_dest_type_decoding_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_dest_type_decoding_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_dlp_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 6, pad);
    bv.set_bits(5, 5, monitor);
    bv.set_bits(4, 1, bvn_profile.pack());
    bv.set_bits(0, 0, never_use_npu_header_pif_ifg);
    return bv;
}


void npl_resolution_dlp_attributes_t::unpack(bit_vector64_t bv) 
{
    pad = bv.bits(7, 6).get_value();
    monitor = bv.bits(5, 5).get_value();
    bvn_profile.unpack(bv.bits(4, 1));
    never_use_npu_header_pif_ifg = bv.bits(0, 0).get_value();
}



field_structure npl_resolution_dlp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_dlp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(pad);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pad", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(monitor);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("monitor", fs_subfield);
    
    fs_result.subfields.emplace_back("bvn_profile", bvn_profile.to_field_structure());
    fs_subfield.flat_value = to_hex_string(never_use_npu_header_pif_ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("never_use_npu_header_pif_ifg", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_dlp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_dlp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_entry_type_decoding_table_field_t::pack(void) const 
{
    bit_vector64_t bv(0, 17);
    bv.set_bits(16, 12, destination_in_nibbles);
    bv.set_bits(11, 7, size_in_bits);
    bv.set_bits(6, 0, offset_in_bits);
    return bv;
}


void npl_resolution_entry_type_decoding_table_field_t::unpack(bit_vector64_t bv) 
{
    destination_in_nibbles = bv.bits(16, 12).get_value();
    size_in_bits = bv.bits(11, 7).get_value();
    offset_in_bits = bv.bits(6, 0).get_value();
}



field_structure npl_resolution_entry_type_decoding_table_field_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_entry_type_decoding_table_field_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(destination_in_nibbles);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_in_nibbles", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(size_in_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("size_in_bits", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(offset_in_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("offset_in_bits", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_entry_type_decoding_table_field_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_entry_type_decoding_table_field_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_resolution_entry_type_decoding_table_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 85);
    bv.set_bits(84, 84, do_lp_queuing);
    bv.set_bits(83, 79, dest_size_on_encap_data_in_bits);
    bv.set_bits(78, 74, dest_offset_on_encap_data_in_nibbles);
    bv.set_bits(73, 57, field_2.pack());
    bv.set_bits(56, 40, field_1.pack());
    bv.set_bits(39, 23, field_0.pack());
    bv.set_bits(22, 19, encapsulation_type);
    bv.set_bits(18, 18, encapsulation_start);
    bv.set_bits(17, 12, next_destination_type);
    bv.set_bits(11, 7, next_destination_size);
    bv.set_bits(6, 0, next_destination_offset);
    return bv;
}


void npl_resolution_entry_type_decoding_table_result_t::unpack(bit_vector128_t bv) 
{
    do_lp_queuing = bv.bits(84, 84).get_value();
    dest_size_on_encap_data_in_bits = bv.bits(83, 79).get_value();
    dest_offset_on_encap_data_in_nibbles = bv.bits(78, 74).get_value();
    field_2.unpack(bv.bits(73, 57));
    field_1.unpack(bv.bits(56, 40));
    field_0.unpack(bv.bits(39, 23));
    encapsulation_type = bv.bits(22, 19).get_value();
    encapsulation_start = bv.bits(18, 18).get_value();
    next_destination_type = bv.bits(17, 12).get_value();
    next_destination_size = bv.bits(11, 7).get_value();
    next_destination_offset = bv.bits(6, 0).get_value();
}



field_structure npl_resolution_entry_type_decoding_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_entry_type_decoding_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(do_lp_queuing);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("do_lp_queuing", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_size_on_encap_data_in_bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_size_on_encap_data_in_bits", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_offset_on_encap_data_in_nibbles);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_offset_on_encap_data_in_nibbles", fs_subfield);
    
    fs_result.subfields.emplace_back("field_2", field_2.to_field_structure());
    fs_result.subfields.emplace_back("field_1", field_1.to_field_structure());
    fs_result.subfields.emplace_back("field_0", field_0.to_field_structure());
    fs_subfield.flat_value = to_hex_string(encapsulation_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("encapsulation_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(encapsulation_start);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("encapsulation_start", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_destination_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_destination_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_destination_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_destination_size", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(next_destination_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_destination_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_entry_type_decoding_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_entry_type_decoding_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_fec_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 13);
    bv.set_bits(12, 0, id);
    return bv;
}


void npl_resolution_fec_key_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(12, 0).get_value();
}



field_structure npl_resolution_fec_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_fec_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_fec_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_fec_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_resolution_fec_result_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = fec_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = fec_dest1.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_resolution_fec_result_t::unpack(bit_vector128_t bv) // union
{
    fec_dest.unpack(bv.bits(79, 0));
}



field_structure npl_resolution_fec_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_fec_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = fec_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("fec_dest", fec_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = fec_dest1.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("fec_dest1", fec_dest1.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("raw", raw.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_resolution_fec_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_fec_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_fwd_class_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 0, tag);
    return bv;
}


void npl_resolution_fwd_class_t::unpack(bit_vector64_t bv) 
{
    tag = bv.bits(2, 0).get_value();
}



field_structure npl_resolution_fwd_class_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_fwd_class_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tag", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_fwd_class_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_fwd_class_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_lb_size_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 1, group_size);
    bv.set_bits(0, 0, consistency_mode);
    return bv;
}


void npl_resolution_lb_size_table_result_t::unpack(bit_vector64_t bv) 
{
    group_size = bv.bits(9, 1).get_value();
    consistency_mode = (npl_lb_consistency_mode_e)bv.bits(0, 0).get_value();
}



field_structure npl_resolution_lb_size_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_lb_size_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(group_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("group_size", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(consistency_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("consistency_mode", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_lb_size_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_lb_size_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_protection_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 1);
    bv.set_bits(0, 0, sel);
    return bv;
}


void npl_resolution_protection_result_t::unpack(bit_vector64_t bv) 
{
    sel = (npl_resolution_protection_selector_e)bv.bits(0, 0).get_value();
}



field_structure npl_resolution_protection_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_protection_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sel", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_protection_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_protection_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_resolution_result_dest_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    // PADDING -  bv.set_bits(79, 40, padding);
    bv.set_bits(39, 24, lb_key.pack());
    // PADDING -  bv.set_bits(23, 23, padding);
    bv.set_bits(22, 20, bvn_map_profile);
    bv.set_bits(19, 0, destination);
    return bv;
}


void npl_resolution_result_dest_data_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(79, 40).get_value();
    lb_key.unpack(bv.bits(39, 24));
    // PADDING -  padding = bv.bits(23, 23).get_value();
    bvn_map_profile = bv.bits(22, 20).get_value();
    destination = bv.bits(19, 0).get_value();
}



field_structure npl_resolution_result_dest_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_result_dest_data_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("lb_key", lb_key.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(bvn_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bvn_map_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_result_dest_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_result_dest_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_resolution_stage_assoc_data_narrow_protection_record_t::pack(void) const 
{
    bit_vector128_t bv(0, 65);
    bv.set_bits(64, 64, path);
    bv.set_bits(63, 38, primary_payload);
    bv.set_bits(37, 32, primary_entry_type);
    bv.set_bits(31, 6, protect_payload);
    bv.set_bits(5, 0, protect_entry_type);
    return bv;
}


void npl_resolution_stage_assoc_data_narrow_protection_record_t::unpack(bit_vector128_t bv) 
{
    path = bv.bits(64, 64).get_value();
    primary_payload = bv.bits(63, 38).get_value();
    primary_entry_type = bv.bits(37, 32).get_value();
    protect_payload = bv.bits(31, 6).get_value();
    protect_entry_type = bv.bits(5, 0).get_value();
}



field_structure npl_resolution_stage_assoc_data_narrow_protection_record_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_narrow_protection_record_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(path);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("path", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(primary_payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("primary_payload", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(primary_entry_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("primary_entry_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(protect_payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("protect_payload", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(protect_entry_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("protect_entry_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_narrow_protection_record_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_narrow_protection_record_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_raw_t::pack(void) const 
{
    bit_vector192_t bv(0, 145);
    bv.set_bits(144, 144, is_protection);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 144 - 1;
        size_t msb = 0;
        const uint64_t * p = payload;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_resolution_stage_assoc_data_raw_t::unpack(bit_vector192_t bv) 
{
    is_protection = bv.bits(144, 144).get_value();
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 144 - 1;
        size_t msb = 0;
        uint64_t * p = payload;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_resolution_stage_assoc_data_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_raw_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_protection);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_protection", fs_subfield);
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 1;
        size_t max_msb = lsb + 144 - 1;
        size_t msb = 0;
        const uint64_t * p = payload;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_stage_em_table_dest_map_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 23, dest_or_lb);
    bv.set_bits(22, 20, padd);
    bv.set_bits(19, 0, dest);
    return bv;
}


void npl_resolution_stage_em_table_dest_map_key_t::unpack(bit_vector64_t bv) 
{
    dest_or_lb = (npl_resolution_em_selector_e)bv.bits(23, 23).get_value();
    padd = bv.bits(22, 20).get_value();
    dest = bv.bits(19, 0).get_value();
}



field_structure npl_resolution_stage_em_table_dest_map_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_em_table_dest_map_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(dest_or_lb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_or_lb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(padd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("padd", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_em_table_dest_map_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_em_table_dest_map_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_stage_em_table_lb_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 23, dest_or_lb);
    bv.set_bits(22, 14, member_id);
    bv.set_bits(13, 0, group_id);
    return bv;
}


void npl_resolution_stage_em_table_lb_key_t::unpack(bit_vector64_t bv) 
{
    dest_or_lb = (npl_resolution_em_selector_e)bv.bits(23, 23).get_value();
    member_id = bv.bits(22, 14).get_value();
    group_id = bv.bits(13, 0).get_value();
}



field_structure npl_resolution_stage_em_table_lb_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_em_table_lb_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(dest_or_lb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_or_lb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(member_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("member_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(group_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("group_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_em_table_lb_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_em_table_lb_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_stage_em_table_raw_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 23, dest_or_lb);
    bv.set_bits(22, 0, key);
    return bv;
}


void npl_resolution_stage_em_table_raw_key_t::unpack(bit_vector64_t bv) 
{
    dest_or_lb = (npl_resolution_em_selector_e)bv.bits(23, 23).get_value();
    key = bv.bits(22, 0).get_value();
}



field_structure npl_resolution_stage_em_table_raw_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_em_table_raw_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(dest_or_lb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_or_lb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(key);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("key", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_em_table_raw_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_em_table_raw_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rmep_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 5, rmep_data);
    bv.set_bits(4, 1, rmep_profile);
    bv.set_bits(0, 0, rmep_valid);
    return bv;
}


void npl_rmep_data_t::unpack(bit_vector64_t bv) 
{
    rmep_data = bv.bits(15, 5).get_value();
    rmep_profile = bv.bits(4, 1).get_value();
    rmep_valid = bv.bits(0, 0).get_value();
}



field_structure npl_rmep_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rmep_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rmep_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_data", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(rmep_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(rmep_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_valid", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rmep_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rmep_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_compressed_fields_for_next_macro_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, acl_outer);
    bv.set_bits(2, 0, fwd_layer_and_rtf_stage_compressed_fields.pack());
    return bv;
}


void npl_rtf_compressed_fields_for_next_macro_t::unpack(bit_vector64_t bv) 
{
    acl_outer = bv.bits(3, 3).get_value();
    fwd_layer_and_rtf_stage_compressed_fields.unpack(bv.bits(2, 0));
}



field_structure npl_rtf_compressed_fields_for_next_macro_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_compressed_fields_for_next_macro_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(acl_outer);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_outer", fs_subfield);
    
    fs_result.subfields.emplace_back("fwd_layer_and_rtf_stage_compressed_fields", fwd_layer_and_rtf_stage_compressed_fields.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rtf_compressed_fields_for_next_macro_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_compressed_fields_for_next_macro_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_conf_set_and_stages_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 4, rtf_conf_set.pack());
    bv.set_bits(3, 0, ipv4_ipv6_init_rtf_stage.pack());
    return bv;
}


void npl_rtf_conf_set_and_stages_t::unpack(bit_vector64_t bv) 
{
    rtf_conf_set.unpack(bv.bits(11, 4));
    ipv4_ipv6_init_rtf_stage.unpack(bv.bits(3, 0));
}



field_structure npl_rtf_conf_set_and_stages_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_conf_set_and_stages_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("rtf_conf_set", rtf_conf_set.to_field_structure());
    fs_result.subfields.emplace_back("ipv4_ipv6_init_rtf_stage", ipv4_ipv6_init_rtf_stage.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rtf_conf_set_and_stages_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_conf_set_and_stages_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_iter_prop_over_fwd0_t::pack(void) const // union
{
    bit_vector64_t bv(0, 10);
    { // union compound field start
        bit_vector64_t tbv = ip_rtf.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(9, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = eth_rtf.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rtf_iter_prop_over_fwd0_t::unpack(bit_vector64_t bv) // union
{
    ip_rtf.unpack(bv.bits(9, 0));
}



field_structure npl_rtf_iter_prop_over_fwd0_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_iter_prop_over_fwd0_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ip_rtf.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ip_rtf", ip_rtf.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = eth_rtf.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("eth_rtf", eth_rtf.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rtf_iter_prop_over_fwd0_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_iter_prop_over_fwd0_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_iter_prop_over_fwd1_t::pack(void) const // union
{
    bit_vector64_t bv(0, 9);
    { // union compound field start
        bit_vector64_t tbv = ip_rtf.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(8, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = eth_rtf.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rtf_iter_prop_over_fwd1_t::unpack(bit_vector64_t bv) // union
{
    ip_rtf.unpack(bv.bits(8, 0));
}



field_structure npl_rtf_iter_prop_over_fwd1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_iter_prop_over_fwd1_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ip_rtf.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ip_rtf", ip_rtf.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = eth_rtf.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("eth_rtf", eth_rtf.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rtf_iter_prop_over_fwd1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_iter_prop_over_fwd1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_0_t_anonymous_union_force_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = drop_counter.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = permit_ace_cntr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = meter_ptr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rtf_result_profile_0_t_anonymous_union_force_t::unpack(bit_vector64_t bv) // union
{
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_rtf_result_profile_0_t_anonymous_union_force_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_0_t_anonymous_union_force_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("destination", destination.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = drop_counter.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("drop_counter", drop_counter.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = permit_ace_cntr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("permit_ace_cntr", permit_ace_cntr.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = meter_ptr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("meter_ptr", meter_ptr.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_0_t_anonymous_union_force_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_0_t_anonymous_union_force_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_0_t_anonymous_union_mirror_cmd_or_offset_t::pack(void) const // union
{
    bit_vector64_t bv(0, 5);
    if (mirror_cmd != 0) {  // union primitive field start
        bv.set_bits(4, 0, mirror_cmd);
        return bv;
    }// union primitive field end
    
    if (mirror_offset != 0) {  // union primitive field start
        bv.set_bits(4, 0, mirror_offset);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_rtf_result_profile_0_t_anonymous_union_mirror_cmd_or_offset_t::unpack(bit_vector64_t bv) // union
{
    mirror_cmd = bv.bits(4, 0).get_value();
}



field_structure npl_rtf_result_profile_0_t_anonymous_union_mirror_cmd_or_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_0_t_anonymous_union_mirror_cmd_or_offset_t";
    field_structure fs_subfield;
    //add members to result
    if (mirror_cmd != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mirror_cmd);
        return union_found;
    }// union primitive field end
    
    if (mirror_offset != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mirror_offset);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_0_t_anonymous_union_mirror_cmd_or_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_0_t_anonymous_union_mirror_cmd_or_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_1_t_anonymous_union_meter_or_counter_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = meter_ptr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = counter_ptr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rtf_result_profile_1_t_anonymous_union_meter_or_counter_t::unpack(bit_vector64_t bv) // union
{
    meter_ptr.unpack(bv.bits(19, 0));
}



field_structure npl_rtf_result_profile_1_t_anonymous_union_meter_or_counter_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_1_t_anonymous_union_meter_or_counter_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = meter_ptr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("meter_ptr", meter_ptr.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = counter_ptr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("counter_ptr", counter_ptr.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_1_t_anonymous_union_meter_or_counter_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_1_t_anonymous_union_meter_or_counter_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_2_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    // PADDING -  bv.set_bits(61, 0, padding);
    return bv;
}


void npl_rtf_result_profile_2_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(61, 0).get_value();
}



field_structure npl_rtf_result_profile_2_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_2_t";
    field_structure fs_subfield;
    //add members to result
    
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_2_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_2_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_3_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    // PADDING -  bv.set_bits(61, 0, padding);
    return bv;
}


void npl_rtf_result_profile_3_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(61, 0).get_value();
}



field_structure npl_rtf_result_profile_3_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_3_t";
    field_structure fs_subfield;
    //add members to result
    
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_3_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_3_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_step_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, val);
    return bv;
}


void npl_rtf_step_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(1, 0).get_value();
}



field_structure npl_rtf_step_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_step_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rtf_step_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_step_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_block_meter_attribute_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 4, meter_decision_mapping_profile.pack());
    bv.set_bits(3, 0, profile.pack());
    return bv;
}


void npl_rx_meter_block_meter_attribute_result_t::unpack(bit_vector64_t bv) 
{
    meter_decision_mapping_profile.unpack(bv.bits(5, 4));
    profile.unpack(bv.bits(3, 0));
}



field_structure npl_rx_meter_block_meter_attribute_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_block_meter_attribute_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("meter_decision_mapping_profile", meter_decision_mapping_profile.to_field_structure());
    fs_result.subfields.emplace_back("profile", profile.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_block_meter_attribute_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_block_meter_attribute_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_block_meter_profile_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 39);
    bv.set_bits(38, 21, ebs.pack());
    bv.set_bits(20, 3, cbs.pack());
    bv.set_bits(2, 2, color_aware_mode.pack());
    bv.set_bits(1, 1, meter_mode.pack());
    bv.set_bits(0, 0, meter_count_mode.pack());
    return bv;
}


void npl_rx_meter_block_meter_profile_result_t::unpack(bit_vector64_t bv) 
{
    ebs.unpack(bv.bits(38, 21));
    cbs.unpack(bv.bits(20, 3));
    color_aware_mode.unpack(bv.bits(2, 2));
    meter_mode.unpack(bv.bits(1, 1));
    meter_count_mode.unpack(bv.bits(0, 0));
}



field_structure npl_rx_meter_block_meter_profile_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_block_meter_profile_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ebs", ebs.to_field_structure());
    fs_result.subfields.emplace_back("cbs", cbs.to_field_structure());
    fs_result.subfields.emplace_back("color_aware_mode", color_aware_mode.to_field_structure());
    fs_result.subfields.emplace_back("meter_mode", meter_mode.to_field_structure());
    fs_result.subfields.emplace_back("meter_count_mode", meter_count_mode.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_block_meter_profile_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_block_meter_profile_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_block_meter_shaper_configuration_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 10, eir_weight.pack());
    bv.set_bits(9, 0, cir_weight.pack());
    return bv;
}


void npl_rx_meter_block_meter_shaper_configuration_result_t::unpack(bit_vector64_t bv) 
{
    eir_weight.unpack(bv.bits(19, 10));
    cir_weight.unpack(bv.bits(9, 0));
}



field_structure npl_rx_meter_block_meter_shaper_configuration_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_block_meter_shaper_configuration_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("eir_weight", eir_weight.to_field_structure());
    fs_result.subfields.emplace_back("cir_weight", cir_weight.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_block_meter_shaper_configuration_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_block_meter_shaper_configuration_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_rx_meter_distributed_meter_profile_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 74);
    bv.set_bits(73, 73, is_distributed_meter);
    bv.set_bits(72, 55, excess_token_release_thr);
    bv.set_bits(54, 37, excess_token_grant_thr);
    bv.set_bits(36, 19, committed_token_release_thr);
    bv.set_bits(18, 1, committed_token_grant_thr);
    bv.set_bits(0, 0, is_cascade);
    return bv;
}


void npl_rx_meter_distributed_meter_profile_result_t::unpack(bit_vector128_t bv) 
{
    is_distributed_meter = bv.bits(73, 73).get_value();
    excess_token_release_thr = bv.bits(72, 55).get_value();
    excess_token_grant_thr = bv.bits(54, 37).get_value();
    committed_token_release_thr = bv.bits(36, 19).get_value();
    committed_token_grant_thr = bv.bits(18, 1).get_value();
    is_cascade = bv.bits(0, 0).get_value();
}



field_structure npl_rx_meter_distributed_meter_profile_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_distributed_meter_profile_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_distributed_meter);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_distributed_meter", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(excess_token_release_thr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("excess_token_release_thr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(excess_token_grant_thr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("excess_token_grant_thr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(committed_token_release_thr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("committed_token_release_thr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(committed_token_grant_thr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("committed_token_grant_thr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_cascade);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_cascade", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rx_meter_distributed_meter_profile_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_distributed_meter_profile_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_exact_meter_decision_mapping_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 6, congestion_experienced);
    bv.set_bits(5, 4, rx_counter_color.pack());
    bv.set_bits(3, 2, outgoing_color.pack());
    bv.set_bits(1, 1, cgm_rx_dp);
    bv.set_bits(0, 0, meter_drop);
    return bv;
}


void npl_rx_meter_exact_meter_decision_mapping_result_t::unpack(bit_vector64_t bv) 
{
    congestion_experienced = bv.bits(6, 6).get_value();
    rx_counter_color.unpack(bv.bits(5, 4));
    outgoing_color.unpack(bv.bits(3, 2));
    cgm_rx_dp = bv.bits(1, 1).get_value();
    meter_drop = bv.bits(0, 0).get_value();
}



field_structure npl_rx_meter_exact_meter_decision_mapping_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_exact_meter_decision_mapping_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(congestion_experienced);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("congestion_experienced", fs_subfield);
    
    fs_result.subfields.emplace_back("rx_counter_color", rx_counter_color.to_field_structure());
    fs_result.subfields.emplace_back("outgoing_color", outgoing_color.to_field_structure());
    fs_subfield.flat_value = to_hex_string(cgm_rx_dp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cgm_rx_dp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(meter_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter_drop", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rx_meter_exact_meter_decision_mapping_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_exact_meter_decision_mapping_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_meter_profile_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 39);
    bv.set_bits(38, 21, ebs.pack());
    bv.set_bits(20, 3, cbs.pack());
    bv.set_bits(2, 2, color_aware_mode.pack());
    bv.set_bits(1, 1, meter_mode.pack());
    bv.set_bits(0, 0, meter_count_mode.pack());
    return bv;
}


void npl_rx_meter_meter_profile_result_t::unpack(bit_vector64_t bv) 
{
    ebs.unpack(bv.bits(38, 21));
    cbs.unpack(bv.bits(20, 3));
    color_aware_mode.unpack(bv.bits(2, 2));
    meter_mode.unpack(bv.bits(1, 1));
    meter_count_mode.unpack(bv.bits(0, 0));
}



field_structure npl_rx_meter_meter_profile_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_meter_profile_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ebs", ebs.to_field_structure());
    fs_result.subfields.emplace_back("cbs", cbs.to_field_structure());
    fs_result.subfields.emplace_back("color_aware_mode", color_aware_mode.to_field_structure());
    fs_result.subfields.emplace_back("meter_mode", meter_mode.to_field_structure());
    fs_result.subfields.emplace_back("meter_count_mode", meter_count_mode.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_meter_profile_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_meter_profile_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_meter_shaper_configuration_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 10, eir_weight.pack());
    bv.set_bits(9, 0, cir_weight.pack());
    return bv;
}


void npl_rx_meter_meter_shaper_configuration_result_t::unpack(bit_vector64_t bv) 
{
    eir_weight.unpack(bv.bits(19, 10));
    cir_weight.unpack(bv.bits(9, 0));
}



field_structure npl_rx_meter_meter_shaper_configuration_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_meter_shaper_configuration_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("eir_weight", eir_weight.to_field_structure());
    fs_result.subfields.emplace_back("cir_weight", cir_weight.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_meter_shaper_configuration_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_meter_shaper_configuration_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_meters_attribute_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 4, meter_decision_mapping_profile.pack());
    bv.set_bits(3, 0, profile.pack());
    return bv;
}


void npl_rx_meter_meters_attribute_result_t::unpack(bit_vector64_t bv) 
{
    meter_decision_mapping_profile.unpack(bv.bits(5, 4));
    profile.unpack(bv.bits(3, 0));
}



field_structure npl_rx_meter_meters_attribute_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_meters_attribute_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("meter_decision_mapping_profile", meter_decision_mapping_profile.to_field_structure());
    fs_result.subfields.emplace_back("profile", profile.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_meters_attribute_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_meters_attribute_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_rate_limiter_shaper_configuration_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 0, cir_weight.pack());
    return bv;
}


void npl_rx_meter_rate_limiter_shaper_configuration_result_t::unpack(bit_vector64_t bv) 
{
    cir_weight.unpack(bv.bits(9, 0));
}



field_structure npl_rx_meter_rate_limiter_shaper_configuration_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_rate_limiter_shaper_configuration_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("cir_weight", cir_weight.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_meter_rate_limiter_shaper_configuration_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_rate_limiter_shaper_configuration_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_meter_stat_meter_decision_mapping_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 6, congestion_experienced);
    bv.set_bits(5, 4, rx_counter_color.pack());
    bv.set_bits(3, 2, outgoing_color.pack());
    bv.set_bits(1, 1, cgm_rx_dp);
    bv.set_bits(0, 0, meter_drop);
    return bv;
}


void npl_rx_meter_stat_meter_decision_mapping_result_t::unpack(bit_vector64_t bv) 
{
    congestion_experienced = bv.bits(6, 6).get_value();
    rx_counter_color.unpack(bv.bits(5, 4));
    outgoing_color.unpack(bv.bits(3, 2));
    cgm_rx_dp = bv.bits(1, 1).get_value();
    meter_drop = bv.bits(0, 0).get_value();
}



field_structure npl_rx_meter_stat_meter_decision_mapping_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_meter_stat_meter_decision_mapping_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(congestion_experienced);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("congestion_experienced", fs_subfield);
    
    fs_result.subfields.emplace_back("rx_counter_color", rx_counter_color.to_field_structure());
    fs_result.subfields.emplace_back("outgoing_color", outgoing_color.to_field_structure());
    fs_subfield.flat_value = to_hex_string(cgm_rx_dp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cgm_rx_dp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(meter_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter_drop", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rx_meter_stat_meter_decision_mapping_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_meter_stat_meter_decision_mapping_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_nw_app_on_lb_key_t::pack(void) const // union
{
    bit_vector64_t bv(0, 12);
    if (nhlfe_mid_point_nh != 0) {  // union primitive field start
        bv.set_bits(11, 0, nhlfe_mid_point_nh);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_rx_nw_app_on_lb_key_t::unpack(bit_vector64_t bv) // union
{
    nhlfe_mid_point_nh = bv.bits(11, 0).get_value();
}



field_structure npl_rx_nw_app_on_lb_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_nw_app_on_lb_key_t";
    field_structure fs_subfield;
    //add members to result
    if (nhlfe_mid_point_nh != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(nhlfe_mid_point_nh);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_rx_nw_app_on_lb_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_nw_app_on_lb_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rx_nw_app_or_lb_key_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (lb_key != 0) {  // union primitive field start
        bv.set_bits(15, 0, lb_key);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = rx_nw_app_on_lb_key.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 4, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rx_nw_app_or_lb_key_t::unpack(bit_vector64_t bv) // union
{
    lb_key = bv.bits(15, 0).get_value();
}



field_structure npl_rx_nw_app_or_lb_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_nw_app_or_lb_key_t";
    field_structure fs_subfield;
    //add members to result
    if (lb_key != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lb_key);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = rx_nw_app_on_lb_key.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rx_nw_app_on_lb_key", rx_nw_app_on_lb_key.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rx_nw_app_or_lb_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_nw_app_or_lb_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_rx_obm_punt_src_and_code_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 65);
    bv.set_bits(64, 60, phb.pack());
    bv.set_bits(59, 40, meter_ptr.pack());
    bv.set_bits(39, 20, cntr_ptr.pack());
    bv.set_bits(19, 0, punt_bvn_dest.pack());
    return bv;
}


void npl_rx_obm_punt_src_and_code_data_t::unpack(bit_vector128_t bv) 
{
    phb.unpack(bv.bits(64, 60));
    meter_ptr.unpack(bv.bits(59, 40));
    cntr_ptr.unpack(bv.bits(39, 20));
    punt_bvn_dest.unpack(bv.bits(19, 0));
}



field_structure npl_rx_obm_punt_src_and_code_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rx_obm_punt_src_and_code_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("phb", phb.to_field_structure());
    fs_result.subfields.emplace_back("meter_ptr", meter_ptr.to_field_structure());
    fs_result.subfields.emplace_back("cntr_ptr", cntr_ptr.to_field_structure());
    fs_result.subfields.emplace_back("punt_bvn_dest", punt_bvn_dest.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rx_obm_punt_src_and_code_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rx_obm_punt_src_and_code_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rxpdr_dsp_lookup_table_entry_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 25, tc_map_profile);
    bv.set_bits(24, 9, base_voq_num);
    bv.set_bits(8, 0, dest_device);
    return bv;
}


void npl_rxpdr_dsp_lookup_table_entry_t::unpack(bit_vector64_t bv) 
{
    tc_map_profile = bv.bits(27, 25).get_value();
    base_voq_num = bv.bits(24, 9).get_value();
    dest_device = bv.bits(8, 0).get_value();
}



field_structure npl_rxpdr_dsp_lookup_table_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpdr_dsp_lookup_table_entry_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(tc_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_map_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(base_voq_num);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("base_voq_num", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest_device);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_device", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rxpdr_dsp_lookup_table_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpdr_dsp_lookup_table_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rxpdr_dsp_tc_map_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, is_flb);
    bv.set_bits(2, 0, tc_offset);
    return bv;
}


void npl_rxpdr_dsp_tc_map_result_t::unpack(bit_vector64_t bv) 
{
    is_flb = bv.bits(3, 3).get_value();
    tc_offset = bv.bits(2, 0).get_value();
}



field_structure npl_rxpdr_dsp_tc_map_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpdr_dsp_tc_map_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_flb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_flb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rxpdr_dsp_tc_map_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpdr_dsp_tc_map_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rxpdr_ibm_tc_map_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, is_flb);
    bv.set_bits(2, 0, tc_offset);
    return bv;
}


void npl_rxpdr_ibm_tc_map_result_t::unpack(bit_vector64_t bv) 
{
    is_flb = bv.bits(3, 3).get_value();
    tc_offset = bv.bits(2, 0).get_value();
}



field_structure npl_rxpdr_ibm_tc_map_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpdr_ibm_tc_map_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_flb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_flb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rxpdr_ibm_tc_map_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpdr_ibm_tc_map_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rxpp_pd_forward_destination_doq_ds_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 13, prefix);
    // PADDING -  bv.set_bits(12, 12, padding);
    bv.set_bits(11, 3, doq);
    bv.set_bits(2, 0, ds);
    return bv;
}


void npl_rxpp_pd_forward_destination_doq_ds_t::unpack(bit_vector64_t bv) 
{
    prefix = bv.bits(19, 13).get_value();
    // PADDING -  padding = bv.bits(12, 12).get_value();
    doq = bv.bits(11, 3).get_value();
    ds = bv.bits(2, 0).get_value();
}



field_structure npl_rxpp_pd_forward_destination_doq_ds_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_forward_destination_doq_ds_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(prefix);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prefix", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(doq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("doq", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ds);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ds", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rxpp_pd_forward_destination_doq_ds_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_forward_destination_doq_ds_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rxpp_pd_forward_destination_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    if (raw != 0) {  // union primitive field start
        bv.set_bits(19, 0, raw);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = doq_ds.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rxpp_pd_forward_destination_t::unpack(bit_vector64_t bv) // union
{
    raw = bv.bits(19, 0).get_value();
}



field_structure npl_rxpp_pd_forward_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_forward_destination_t";
    field_structure fs_subfield;
    //add members to result
    if (raw != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(raw);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = doq_ds.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("doq_ds", doq_ds.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rxpp_pd_forward_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_forward_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_rxpp_pd_rxf_t::pack(void) const 
{
    bit_vector128_t bv(0, 106);
    bv.set_bits(105, 82, fabric_ts_sn);
    bv.set_bits(81, 80, vmd_fabric_ctxt);
    bv.set_bits(79, 74, first_packet_size_round_up_in_8_bytes_granularity);
    bv.set_bits(73, 73, is_keepalive);
    bv.set_bits(72, 72, plb_header_type);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 72 - 1;
        size_t msb = 0;
        const uint64_t * p = plb_ctxt_ts;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_rxpp_pd_rxf_t::unpack(bit_vector128_t bv) 
{
    fabric_ts_sn = bv.bits(105, 82).get_value();
    vmd_fabric_ctxt = (npl_fabric_context_e)bv.bits(81, 80).get_value();
    first_packet_size_round_up_in_8_bytes_granularity = bv.bits(79, 74).get_value();
    is_keepalive = bv.bits(73, 73).get_value();
    plb_header_type = bv.bits(72, 72).get_value();
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 72 - 1;
        size_t msb = 0;
        uint64_t * p = plb_ctxt_ts;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_rxpp_pd_rxf_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_rxf_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(fabric_ts_sn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fabric_ts_sn", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(vmd_fabric_ctxt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vmd_fabric_ctxt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(first_packet_size_round_up_in_8_bytes_granularity);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("first_packet_size_round_up_in_8_bytes_granularity", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_keepalive);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_keepalive", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(plb_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("plb_header_type", fs_subfield);
    
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 34;
        size_t max_msb = lsb + 72 - 1;
        size_t msb = 0;
        const uint64_t * p = plb_ctxt_ts;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_rxpp_pd_rxf_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_rxf_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_rxpp_pd_rxn_t::pack(void) const 
{
    bit_vector192_t bv(0, 137);
    bv.set_bits(136, 101, flow_sign);
    bv.set_bits(100, 94, sch_compensation);
    bv.set_bits(93, 89, in_mirror_cmd1);
    bv.set_bits(88, 84, in_mirror_cmd2);
    bv.set_bits(83, 65, counter_meter_ptr_1);
    bv.set_bits(64, 58, counter_meter_comp_1);
    bv.set_bits(57, 57, counter_lm_read_only_1);
    bv.set_bits(56, 38, counter_meter_ptr_2);
    bv.set_bits(37, 31, counter_meter_comp_2);
    bv.set_bits(30, 30, counter_lm_read_only_2);
    bv.set_bits(29, 11, counter_meter_ptr_3);
    bv.set_bits(10, 4, counter_meter_comp_3);
    bv.set_bits(3, 3, counter_lm_read_only_3);
    bv.set_bits(2, 0, fllb_control_code);
    return bv;
}


void npl_rxpp_pd_rxn_t::unpack(bit_vector192_t bv) 
{
    flow_sign = bv.bits(136, 101).get_value();
    sch_compensation = bv.bits(100, 94).get_value();
    in_mirror_cmd1 = bv.bits(93, 89).get_value();
    in_mirror_cmd2 = bv.bits(88, 84).get_value();
    counter_meter_ptr_1 = bv.bits(83, 65).get_value();
    counter_meter_comp_1 = bv.bits(64, 58).get_value();
    counter_lm_read_only_1 = bv.bits(57, 57).get_value();
    counter_meter_ptr_2 = bv.bits(56, 38).get_value();
    counter_meter_comp_2 = bv.bits(37, 31).get_value();
    counter_lm_read_only_2 = bv.bits(30, 30).get_value();
    counter_meter_ptr_3 = bv.bits(29, 11).get_value();
    counter_meter_comp_3 = bv.bits(10, 4).get_value();
    counter_lm_read_only_3 = bv.bits(3, 3).get_value();
    fllb_control_code = bv.bits(2, 0).get_value();
}



field_structure npl_rxpp_pd_rxn_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_rxn_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(flow_sign);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("flow_sign", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sch_compensation);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sch_compensation", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(in_mirror_cmd1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("in_mirror_cmd1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(in_mirror_cmd2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("in_mirror_cmd2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_ptr_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_ptr_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_comp_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_comp_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_lm_read_only_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_lm_read_only_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_ptr_2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_ptr_2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_comp_2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_comp_2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_lm_read_only_2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_lm_read_only_2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_ptr_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_ptr_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_comp_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_comp_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_lm_read_only_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_lm_read_only_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fllb_control_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fllb_control_code", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_rxpp_pd_rxn_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_rxn_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rxpp_pd_t_anonymous_union_lb_or_slb_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (lb_key != 0) {  // union primitive field start
        bv.set_bits(15, 0, lb_key);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = slb.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 14, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rxpp_pd_t_anonymous_union_lb_or_slb_t::unpack(bit_vector64_t bv) // union
{
    lb_key = bv.bits(15, 0).get_value();
}



field_structure npl_rxpp_pd_t_anonymous_union_lb_or_slb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_t_anonymous_union_lb_or_slb_t";
    field_structure fs_subfield;
    //add members to result
    if (lb_key != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lb_key);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = slb.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("slb", slb.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rxpp_pd_t_anonymous_union_lb_or_slb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_t_anonymous_union_lb_or_slb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_rxpp_pd_t_anonymous_union_slice_mode_data_t::pack(void) const // union
{
    bit_vector192_t bv(0, 137);
    { // union compound field start
        bit_vector128_t tbv = rxf.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(136, 31, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = rxn.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(136, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rxpp_pd_t_anonymous_union_slice_mode_data_t::unpack(bit_vector192_t bv) // union
{
    rxf.unpack(bv.bits(136, 31));
}



field_structure npl_rxpp_pd_t_anonymous_union_slice_mode_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_t_anonymous_union_slice_mode_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = rxf.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rxf", rxf.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = rxn.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rxn", rxn.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rxpp_pd_t_anonymous_union_slice_mode_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_t_anonymous_union_slice_mode_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sa_msb_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 0, msb);
    return bv;
}


void npl_sa_msb_t::unpack(bit_vector64_t bv) 
{
    msb = bv.bits(31, 0).get_value();
}



field_structure npl_sa_msb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sa_msb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(msb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("msb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_sa_msb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sa_msb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_scanner_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 13);
    bv.set_bits(12, 0, id);
    return bv;
}


void npl_scanner_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(12, 0).get_value();
}



field_structure npl_scanner_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_scanner_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_scanner_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_scanner_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sda_fabric_feature_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, enable);
    bv.set_bits(2, 2, l2_enforcement);
    // PADDING -  bv.set_bits(1, 0, padding);
    return bv;
}


void npl_sda_fabric_feature_t::unpack(bit_vector64_t bv) 
{
    enable = bv.bits(3, 3).get_value();
    l2_enforcement = bv.bits(2, 2).get_value();
    // PADDING -  padding = bv.bits(1, 0).get_value();
}



field_structure npl_sda_fabric_feature_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sda_fabric_feature_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_enforcement);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_enforcement", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_sda_fabric_feature_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sda_fabric_feature_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sec_acl_attributes_t_anonymous_union_slp_dlp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    if (global_dlp_id != 0) {  // union primitive field start
        bv.set_bits(19, 0, global_dlp_id);
        return bv;
    }// union primitive field end
    
    if (global_slp_id != 0) {  // union primitive field start
        bv.set_bits(19, 0, global_slp_id);
        return bv;
    }// union primitive field end
    
    if (is_l2 != 0) {  // union primitive field start
        bv.set_bits(19, 19, is_l2);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_sec_acl_attributes_t_anonymous_union_slp_dlp_t::unpack(bit_vector64_t bv) // union
{
    global_dlp_id = bv.bits(19, 0).get_value();
}



field_structure npl_sec_acl_attributes_t_anonymous_union_slp_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sec_acl_attributes_t_anonymous_union_slp_dlp_t";
    field_structure fs_subfield;
    //add members to result
    if (global_dlp_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(global_dlp_id);
        return union_found;
    }// union primitive field end
    
    if (global_slp_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(global_slp_id);
        return union_found;
    }// union primitive field end
    
    if (is_l2 != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(is_l2);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_sec_acl_attributes_t_anonymous_union_slp_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sec_acl_attributes_t_anonymous_union_slp_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sec_acl_ids_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, acl_v4_id);
    bv.set_bits(3, 0, acl_v6_id);
    return bv;
}


void npl_sec_acl_ids_t::unpack(bit_vector64_t bv) 
{
    acl_v4_id = bv.bits(7, 4).get_value();
    acl_v6_id = bv.bits(3, 0).get_value();
}



field_structure npl_sec_acl_ids_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sec_acl_ids_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(acl_v4_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_v4_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(acl_v6_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_v6_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_sec_acl_ids_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sec_acl_ids_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_select_macros_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 2, npe_macro_offset);
    bv.set_bits(1, 0, fi_macro_offset);
    return bv;
}


void npl_select_macros_t::unpack(bit_vector64_t bv) 
{
    npe_macro_offset = bv.bits(3, 2).get_value();
    fi_macro_offset = bv.bits(1, 0).get_value();
}



field_structure npl_select_macros_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_select_macros_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(npe_macro_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("npe_macro_offset", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fi_macro_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fi_macro_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_select_macros_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_select_macros_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_service_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, push_entropy_label);
    bv.set_bits(0, 0, add_ipv6_explicit_null);
    return bv;
}


void npl_service_flags_t::unpack(bit_vector64_t bv) 
{
    push_entropy_label = bv.bits(1, 1).get_value();
    add_ipv6_explicit_null = bv.bits(0, 0).get_value();
}



field_structure npl_service_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_service_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(push_entropy_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("push_entropy_label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(add_ipv6_explicit_null);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("add_ipv6_explicit_null", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_service_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_service_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sgacl_counter_metadata_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 4, sgacl_counter_lsb);
    bv.set_bits(3, 1, sgacl_bank_idx);
    // PADDING -  bv.set_bits(0, 0, padding);
    return bv;
}


void npl_sgacl_counter_metadata_t::unpack(bit_vector64_t bv) 
{
    sgacl_counter_lsb = bv.bits(19, 4).get_value();
    sgacl_bank_idx = bv.bits(3, 1).get_value();
    // PADDING -  padding = bv.bits(0, 0).get_value();
}



field_structure npl_sgacl_counter_metadata_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sgacl_counter_metadata_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sgacl_counter_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sgacl_counter_lsb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(sgacl_bank_idx);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sgacl_bank_idx", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_sgacl_counter_metadata_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sgacl_counter_metadata_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sgacl_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    // PADDING -  bv.set_bits(63, 2, padding);
    bv.set_bits(1, 1, log);
    bv.set_bits(0, 0, drop);
    return bv;
}


void npl_sgacl_payload_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(63, 2).get_value();
    log = bv.bits(1, 1).get_value();
    drop = bv.bits(0, 0).get_value();
}



field_structure npl_sgacl_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sgacl_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(log);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("log", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_sgacl_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sgacl_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sgt_matrix_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 53);
    bv.set_bits(52, 52, group_policy_allow_drop);
    bv.set_bits(51, 20, group_policy_acl_id);
    bv.set_bits(19, 0, group_policy_counter_metadata.pack());
    return bv;
}


void npl_sgt_matrix_result_t::unpack(bit_vector64_t bv) 
{
    group_policy_allow_drop = bv.bits(52, 52).get_value();
    group_policy_acl_id = bv.bits(51, 20).get_value();
    group_policy_counter_metadata.unpack(bv.bits(19, 0));
}



field_structure npl_sgt_matrix_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sgt_matrix_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(group_policy_allow_drop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("group_policy_allow_drop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(group_policy_acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("group_policy_acl_id", fs_subfield);
    
    fs_result.subfields.emplace_back("group_policy_counter_metadata", group_policy_counter_metadata.to_field_structure());
    return fs_result;
}
std::string to_string(npl_sgt_matrix_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sgt_matrix_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sip_ip_tunnel_termination_attr_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 10, padding);
    bv.set_bits(9, 4, my_dip_index);
    bv.set_bits(3, 0, vxlan_tunnel_loopback);
    return bv;
}


void npl_sip_ip_tunnel_termination_attr_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 10).get_value();
    my_dip_index = bv.bits(9, 4).get_value();
    vxlan_tunnel_loopback = bv.bits(3, 0).get_value();
}



field_structure npl_sip_ip_tunnel_termination_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sip_ip_tunnel_termination_attr_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(my_dip_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("my_dip_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vxlan_tunnel_loopback);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vxlan_tunnel_loopback", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_sip_ip_tunnel_termination_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sip_ip_tunnel_termination_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_slp_based_fwd_and_per_vrf_mpls_fwd_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, slp_based_forwarding);
    bv.set_bits(0, 0, per_vrf_mpls_fwd);
    return bv;
}


void npl_slp_based_fwd_and_per_vrf_mpls_fwd_t::unpack(bit_vector64_t bv) 
{
    slp_based_forwarding = bv.bits(1, 1).get_value();
    per_vrf_mpls_fwd = bv.bits(0, 0).get_value();
}



field_structure npl_slp_based_fwd_and_per_vrf_mpls_fwd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_slp_based_fwd_and_per_vrf_mpls_fwd_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(slp_based_forwarding);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slp_based_forwarding", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(per_vrf_mpls_fwd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("per_vrf_mpls_fwd", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_slp_based_fwd_and_per_vrf_mpls_fwd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_slp_based_fwd_and_per_vrf_mpls_fwd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_slp_fwd_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 44);
    // PADDING -  bv.set_bits(43, 41, padding);
    bv.set_bits(40, 40, mpls_label_present);
    bv.set_bits(39, 20, mpls_label);
    bv.set_bits(19, 0, destination);
    return bv;
}


void npl_slp_fwd_result_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(43, 41).get_value();
    mpls_label_present = bv.bits(40, 40).get_value();
    mpls_label = bv.bits(39, 20).get_value();
    destination = bv.bits(19, 0).get_value();
}



field_structure npl_slp_fwd_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_slp_fwd_result_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(mpls_label_present);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_label_present", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mpls_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_label", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_slp_fwd_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_slp_fwd_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_snoop_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, val);
    return bv;
}


void npl_snoop_code_t::unpack(bit_vector64_t bv) 
{
    val = bv.bits(7, 0).get_value();
}



field_structure npl_snoop_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_snoop_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("val", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_snoop_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_snoop_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_soft_lb_wa_enable_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, is_next_header_gre);
    bv.set_bits(0, 0, soft_lb_enable);
    return bv;
}


void npl_soft_lb_wa_enable_t::unpack(bit_vector64_t bv) 
{
    is_next_header_gre = bv.bits(1, 1).get_value();
    soft_lb_enable = bv.bits(0, 0).get_value();
}



field_structure npl_soft_lb_wa_enable_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_soft_lb_wa_enable_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_next_header_gre);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_next_header_gre", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(soft_lb_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("soft_lb_enable", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_soft_lb_wa_enable_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_soft_lb_wa_enable_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_source_if_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 7, ifg);
    bv.set_bits(6, 2, pif);
    // PADDING -  bv.set_bits(1, 0, padding);
    return bv;
}


void npl_source_if_t::unpack(bit_vector64_t bv) 
{
    ifg = bv.bits(7, 7).get_value();
    pif = bv.bits(6, 2).get_value();
    // PADDING -  padding = bv.bits(1, 0).get_value();
}



field_structure npl_source_if_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_source_if_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ifg", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pif);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pif", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_source_if_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_source_if_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_split_voq_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 10, split_voq_enabled);
    bv.set_bits(9, 0, source_group_offset);
    return bv;
}


void npl_split_voq_t::unpack(bit_vector64_t bv) 
{
    split_voq_enabled = bv.bits(10, 10).get_value();
    source_group_offset = bv.bits(9, 0).get_value();
}



field_structure npl_split_voq_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_split_voq_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(split_voq_enabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("split_voq_enabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(source_group_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("source_group_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_split_voq_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_split_voq_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sport_or_l4_protocol_t_anonymous_union_sport_or_l4_protocol_type_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (src_port != 0) {  // union primitive field start
        bv.set_bits(15, 0, src_port);
        return bv;
    }// union primitive field end
    
    if (ipv4_protocol != 0) {  // union primitive field start
        bv.set_bits(7, 0, ipv4_protocol);
        return bv;
    }// union primitive field end
    
    if (ipv6_next_header != 0) {  // union primitive field start
        bv.set_bits(15, 8, ipv6_next_header);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = icmp_type_code.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_sport_or_l4_protocol_t_anonymous_union_sport_or_l4_protocol_type_t::unpack(bit_vector64_t bv) // union
{
    src_port = bv.bits(15, 0).get_value();
}



field_structure npl_sport_or_l4_protocol_t_anonymous_union_sport_or_l4_protocol_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sport_or_l4_protocol_t_anonymous_union_sport_or_l4_protocol_type_t";
    field_structure fs_subfield;
    //add members to result
    if (src_port != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(src_port);
        return union_found;
    }// union primitive field end
    
    if (ipv4_protocol != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(ipv4_protocol);
        return union_found;
    }// union primitive field end
    
    if (ipv6_next_header != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(ipv6_next_header);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = icmp_type_code.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("icmp_type_code", icmp_type_code.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_sport_or_l4_protocol_t_anonymous_union_sport_or_l4_protocol_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sport_or_l4_protocol_t_anonymous_union_sport_or_l4_protocol_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage0_ce_ptr_destination_vpn_inter_as_ce_ptr_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    // PADDING -  bv.set_bits(71, 44, padding);
    bv.set_bits(43, 28, ce_ptr);
    bv.set_bits(27, 26, vpn_inter_as);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_destination_vpn_inter_as_ce_ptr_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(71, 44).get_value();
    ce_ptr = bv.bits(43, 28).get_value();
    vpn_inter_as = bv.bits(27, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_destination_vpn_inter_as_ce_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_destination_vpn_inter_as_ce_ptr_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_destination_vpn_inter_as_ce_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_destination_vpn_inter_as_ce_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ce_ptr_l3_nh_ip_tunnel_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 34, padding);
    bv.set_bits(33, 18, ip_tunnel);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_l3_nh_ip_tunnel_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 34).get_value();
    ip_tunnel = bv.bits(33, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_l3_nh_ip_tunnel_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_l3_nh_ip_tunnel_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(ip_tunnel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_tunnel", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_l3_nh_ip_tunnel_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_l3_nh_ip_tunnel_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, ce_ptr);
    bv.set_bits(19, 18, vpn_inter_as);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_t::unpack(bit_vector64_t bv) 
{
    ce_ptr = bv.bits(35, 20).get_value();
    vpn_inter_as = bv.bits(19, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, ce_ptr);
    bv.set_bits(19, 18, vpn_inter_as);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t::unpack(bit_vector64_t bv) 
{
    ce_ptr = bv.bits(35, 20).get_value();
    vpn_inter_as = bv.bits(19, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ce_ptr_level2_ecmp_ip_tunnel_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 35, padding);
    bv.set_bits(34, 19, ip_tunnel);
    bv.set_bits(18, 6, level2_ecmp);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_level2_ecmp_ip_tunnel_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 35).get_value();
    ip_tunnel = bv.bits(34, 19).get_value();
    level2_ecmp = bv.bits(18, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_level2_ecmp_ip_tunnel_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_level2_ecmp_ip_tunnel_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(ip_tunnel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_tunnel", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(level2_ecmp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("level2_ecmp", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_level2_ecmp_ip_tunnel_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_level2_ecmp_ip_tunnel_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, ce_ptr);
    bv.set_bits(19, 18, vpn_inter_as);
    bv.set_bits(17, 6, p_l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_t::unpack(bit_vector64_t bv) 
{
    ce_ptr = bv.bits(35, 20).get_value();
    vpn_inter_as = bv.bits(19, 18).get_value();
    p_l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(p_l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("p_l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, ce_ptr);
    bv.set_bits(19, 18, vpn_inter_as);
    bv.set_bits(17, 6, p_l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t::unpack(bit_vector64_t bv) 
{
    ce_ptr = bv.bits(35, 20).get_value();
    vpn_inter_as = bv.bits(19, 18).get_value();
    p_l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(p_l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("p_l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ce_ptr_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_destination1_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 32, enc_type);
    // PADDING -  bv.set_bits(31, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_destination1_t::unpack(bit_vector64_t bv) 
{
    enc_type = bv.bits(35, 32).get_value();
    // PADDING -  padding = bv.bits(31, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_destination1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_destination1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_destination1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_destination1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_ecmp_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_ecmp_destination_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_ecmp_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_ecmp_destination_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_ecmp_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_ecmp_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage0_l2_dlp_destination_l2_dlp_t::pack(void) const 
{
    bit_vector128_t bv(0, 65);
    bv.set_bits(64, 61, enc_type);
    // PADDING -  bv.set_bits(60, 44, padding);
    bv.set_bits(43, 26, l2_dlp);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_l2_dlp_destination_l2_dlp_t::unpack(bit_vector128_t bv) 
{
    enc_type = bv.bits(64, 61).get_value();
    // PADDING -  padding = bv.bits(60, 44).get_value();
    l2_dlp = bv.bits(43, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_l2_dlp_destination_l2_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_l2_dlp_destination_l2_dlp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(l2_dlp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_dlp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_l2_dlp_destination_l2_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_l2_dlp_destination_l2_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_l2_dlp_destination_overlay_nh_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 26, overlay_nh);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_l2_dlp_destination_overlay_nh_t::unpack(bit_vector64_t bv) 
{
    overlay_nh = bv.bits(35, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_l2_dlp_destination_overlay_nh_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_l2_dlp_destination_overlay_nh_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(overlay_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("overlay_nh", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_l2_dlp_destination_overlay_nh_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_l2_dlp_destination_overlay_nh_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_l2_dlp_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 32, enc_type);
    // PADDING -  bv.set_bits(31, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_l2_dlp_destination_t::unpack(bit_vector64_t bv) 
{
    enc_type = bv.bits(35, 32).get_value();
    // PADDING -  padding = bv.bits(31, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_l2_dlp_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_l2_dlp_destination_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_l2_dlp_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_l2_dlp_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, ce_ptr);
    bv.set_bits(19, 18, vpn_inter_as);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t::unpack(bit_vector64_t bv) 
{
    ce_ptr = bv.bits(35, 20).get_value();
    vpn_inter_as = bv.bits(19, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_narrow_raw_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 6, payload);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_narrow_raw_t::unpack(bit_vector64_t bv) 
{
    payload = bv.bits(35, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_narrow_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_narrow_raw_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("payload", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_narrow_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_narrow_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage0_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, ce_ptr);
    bv.set_bits(19, 18, vpn_inter_as);
    bv.set_bits(17, 6, p_l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage0_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t::unpack(bit_vector64_t bv) 
{
    ce_ptr = bv.bits(35, 20).get_value();
    vpn_inter_as = bv.bits(19, 18).get_value();
    p_l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage0_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage0_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage0_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ce_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ce_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vpn_inter_as);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vpn_inter_as", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(p_l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("p_l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage0_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage0_p_l3_nh_vpn_inter_as_ce_ptr_with_common_data1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage1_destination1_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 32, enc_type);
    // PADDING -  bv.set_bits(31, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_destination1_t::unpack(bit_vector64_t bv) 
{
    enc_type = bv.bits(35, 32).get_value();
    // PADDING -  padding = bv.bits(31, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_destination1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_destination1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_destination1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_destination1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage1_l3_nh_te_tunnel14b_or_asbr1_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 34, padding);
    bv.set_bits(33, 18, te_tunnel14b_or_asbr);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_l3_nh_te_tunnel14b_or_asbr1_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 34).get_value();
    te_tunnel14b_or_asbr = bv.bits(33, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_l3_nh_te_tunnel14b_or_asbr1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_l3_nh_te_tunnel14b_or_asbr1_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(te_tunnel14b_or_asbr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_tunnel14b_or_asbr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_l3_nh_te_tunnel14b_or_asbr1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_l3_nh_te_tunnel14b_or_asbr1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage1_l3_nh_te_tunnel14b_or_asbr2_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 34, padding);
    bv.set_bits(33, 18, te_tunnel14b_or_asbr);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_l3_nh_te_tunnel14b_or_asbr2_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 34).get_value();
    te_tunnel14b_or_asbr = bv.bits(33, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_l3_nh_te_tunnel14b_or_asbr2_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_l3_nh_te_tunnel14b_or_asbr2_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(te_tunnel14b_or_asbr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_tunnel14b_or_asbr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_l3_nh_te_tunnel14b_or_asbr2_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_l3_nh_te_tunnel14b_or_asbr2_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage1_l3_nh_te_tunnel16b1_t::pack(void) const 
{
    bit_vector128_t bv(0, 65);
    bv.set_bits(64, 61, enc_type);
    // PADDING -  bv.set_bits(60, 34, padding);
    bv.set_bits(33, 18, te_tunnel16b);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_l3_nh_te_tunnel16b1_t::unpack(bit_vector128_t bv) 
{
    enc_type = bv.bits(64, 61).get_value();
    // PADDING -  padding = bv.bits(60, 34).get_value();
    te_tunnel16b = bv.bits(33, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_l3_nh_te_tunnel16b1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_l3_nh_te_tunnel16b1_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enc_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enc_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(te_tunnel16b);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_tunnel16b", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_l3_nh_te_tunnel16b1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_l3_nh_te_tunnel16b1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage1_level2_ecmp_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_level2_ecmp_destination_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_level2_ecmp_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_level2_ecmp_destination_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_level2_ecmp_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_level2_ecmp_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage1_level2_ecmp_l3_nh_te_tunnel14b_or_asbr_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 34, padding);
    bv.set_bits(33, 18, te_tunnel14b_or_asbr);
    bv.set_bits(17, 6, l3_nh);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_level2_ecmp_l3_nh_te_tunnel14b_or_asbr_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 34).get_value();
    te_tunnel14b_or_asbr = bv.bits(33, 18).get_value();
    l3_nh = bv.bits(17, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_level2_ecmp_l3_nh_te_tunnel14b_or_asbr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_level2_ecmp_l3_nh_te_tunnel14b_or_asbr_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(te_tunnel14b_or_asbr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("te_tunnel14b_or_asbr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_nh", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_level2_ecmp_l3_nh_te_tunnel14b_or_asbr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_level2_ecmp_l3_nh_te_tunnel14b_or_asbr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage1_p_l3_nh_destination_with_common_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 65);
    // PADDING -  bv.set_bits(64, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_p_l3_nh_destination_with_common_data_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(64, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_p_l3_nh_destination_with_common_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_p_l3_nh_destination_with_common_data_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_p_l3_nh_destination_with_common_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_p_l3_nh_destination_with_common_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage1_protected_raw_t::pack(void) const 
{
    bit_vector128_t bv(0, 65);
    bv.set_bits(64, 6, payload);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage1_protected_raw_t::unpack(bit_vector128_t bv) 
{
    payload = bv.bits(64, 6).get_value();
    type = (npl_stage1_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage1_protected_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage1_protected_raw_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("payload", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage1_protected_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage1_protected_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage2_l3_nh_destination_l3_dlp_dlp_attr_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    // PADDING -  bv.set_bits(71, 50, padding);
    bv.set_bits(49, 42, dlp_attr);
    bv.set_bits(41, 26, l3_dlp);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage2_l3_nh_destination_l3_dlp_dlp_attr_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(71, 50).get_value();
    dlp_attr = bv.bits(49, 42).get_value();
    l3_dlp = bv.bits(41, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage2_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage2_l3_nh_destination_l3_dlp_dlp_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage2_l3_nh_destination_l3_dlp_dlp_attr_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(dlp_attr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dlp_attr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_dlp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_dlp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage2_l3_nh_destination_l3_dlp_dlp_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage2_l3_nh_destination_l3_dlp_dlp_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage2_l3_nh_destination_l3_dlp_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    // PADDING -  bv.set_bits(71, 42, padding);
    bv.set_bits(41, 26, l3_dlp);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage2_l3_nh_destination_l3_dlp_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(71, 42).get_value();
    l3_dlp = bv.bits(41, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage2_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage2_l3_nh_destination_l3_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage2_l3_nh_destination_l3_dlp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(l3_dlp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_dlp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage2_l3_nh_destination_l3_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage2_l3_nh_destination_l3_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_stage2_wide_raw_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 6;
        size_t max_msb = lsb + 66 - 1;
        size_t msb = 0;
        const uint64_t * p = payload;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage2_wide_raw_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 6;
        size_t max_msb = lsb + 66 - 1;
        size_t msb = 0;
        uint64_t * p = payload;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    type = (npl_stage2_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage2_wide_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage2_wide_raw_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 6;
        size_t max_msb = lsb + 66 - 1;
        size_t msb = 0;
        const uint64_t * p = payload;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage2_wide_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage2_wide_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage3_dspa_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    // PADDING -  bv.set_bits(35, 26, padding);
    bv.set_bits(25, 6, destination);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage3_dspa_destination_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(35, 26).get_value();
    destination = bv.bits(25, 6).get_value();
    type = (npl_stage3_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage3_dspa_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage3_dspa_destination_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage3_dspa_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage3_dspa_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stage3_narrow_raw_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 6, payload);
    bv.set_bits(5, 0, type);
    return bv;
}


void npl_stage3_narrow_raw_t::unpack(bit_vector64_t bv) 
{
    payload = bv.bits(35, 6).get_value();
    type = (npl_stage3_entry_type_e)bv.bits(5, 0).get_value();
}



field_structure npl_stage3_narrow_raw_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stage3_narrow_raw_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("payload", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stage3_narrow_raw_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stage3_narrow_raw_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stat_bank_index_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 0, value);
    return bv;
}


void npl_stat_bank_index_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(1, 0).get_value();
}



field_structure npl_stat_bank_index_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stat_bank_index_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stat_bank_index_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stat_bank_index_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stat_meter_index_len_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 0, value);
    return bv;
}


void npl_stat_meter_index_len_t::unpack(bit_vector64_t bv) 
{
    value = bv.bits(10, 0).get_value();
}



field_structure npl_stat_meter_index_len_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stat_meter_index_len_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stat_meter_index_len_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stat_meter_index_len_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_std_ip_em_lpm_result_destination_with_default_t::pack(void) const 
{
    bit_vector128_t bv(0, 84);
    // PADDING -  bv.set_bits(83, 20, padding);
    bv.set_bits(19, 19, is_default);
    bv.set_bits(18, 0, destination);
    return bv;
}


void npl_std_ip_em_lpm_result_destination_with_default_t::unpack(bit_vector128_t bv) 
{
    // PADDING -  padding = bv.bits(83, 20).get_value();
    is_default = bv.bits(19, 19).get_value();
    destination = bv.bits(18, 0).get_value();
}



field_structure npl_std_ip_em_lpm_result_destination_with_default_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_std_ip_em_lpm_result_destination_with_default_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(is_default);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_default", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_std_ip_em_lpm_result_destination_with_default_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_std_ip_em_lpm_result_destination_with_default_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_std_ip_em_lpm_result_host_and_l3_dlp_t_anonymous_union_dest_or_dest_with_class_id_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = dest_with_class_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_std_ip_em_lpm_result_host_and_l3_dlp_t_anonymous_union_dest_or_dest_with_class_id_t::unpack(bit_vector64_t bv) // union
{
    dest_with_class_id.unpack(bv.bits(19, 0));
}



field_structure npl_std_ip_em_lpm_result_host_and_l3_dlp_t_anonymous_union_dest_or_dest_with_class_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_std_ip_em_lpm_result_host_and_l3_dlp_t_anonymous_union_dest_or_dest_with_class_id_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = dest_with_class_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("dest_with_class_id", dest_with_class_id.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("destination", destination.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_std_ip_em_lpm_result_host_and_l3_dlp_t_anonymous_union_dest_or_dest_with_class_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_std_ip_em_lpm_result_host_and_l3_dlp_t_anonymous_union_dest_or_dest_with_class_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_stop_on_step_and_next_stage_compressed_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 1, next_rtf_stage);
    bv.set_bits(0, 0, stop_on_step);
    return bv;
}


void npl_stop_on_step_and_next_stage_compressed_fields_t::unpack(bit_vector64_t bv) 
{
    next_rtf_stage = (npl_rtf_stage_and_type_e)bv.bits(3, 1).get_value();
    stop_on_step = bv.bits(0, 0).get_value();
}



field_structure npl_stop_on_step_and_next_stage_compressed_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_stop_on_step_and_next_stage_compressed_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(next_rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_rtf_stage", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(stop_on_step);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("stop_on_step", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_stop_on_step_and_next_stage_compressed_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_stop_on_step_and_next_stage_compressed_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svi_eve_sub_type_plus_prf_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 2, sub_type);
    bv.set_bits(1, 0, prf);
    return bv;
}


void npl_svi_eve_sub_type_plus_prf_t::unpack(bit_vector64_t bv) 
{
    sub_type = (npl_vlan_edit_command_secondary_type_e)bv.bits(4, 2).get_value();
    prf = bv.bits(1, 0).get_value();
}



field_structure npl_svi_eve_sub_type_plus_prf_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svi_eve_sub_type_plus_prf_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(sub_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sub_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(prf);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prf", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svi_eve_sub_type_plus_prf_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svi_eve_sub_type_plus_prf_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svi_eve_vid2_plus_prf_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 2, vid2);
    bv.set_bits(1, 0, prf);
    return bv;
}


void npl_svi_eve_vid2_plus_prf_t::unpack(bit_vector64_t bv) 
{
    vid2 = bv.bits(13, 2).get_value();
    prf = bv.bits(1, 0).get_value();
}



field_structure npl_svi_eve_vid2_plus_prf_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svi_eve_vid2_plus_prf_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(vid2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vid2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(prf);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prf", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svi_eve_vid2_plus_prf_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svi_eve_vid2_plus_prf_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svl_mc_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, mcid);
    return bv;
}


void npl_svl_mc_data_t::unpack(bit_vector64_t bv) 
{
    mcid = bv.bits(15, 0).get_value();
}



field_structure npl_svl_mc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svl_mc_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mcid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mcid", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svl_mc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svl_mc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svl_mirror_remote_dsp_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 0, dsp);
    return bv;
}


void npl_svl_mirror_remote_dsp_t::unpack(bit_vector64_t bv) 
{
    dsp = bv.bits(10, 0).get_value();
}



field_structure npl_svl_mirror_remote_dsp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svl_mirror_remote_dsp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svl_mirror_remote_dsp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svl_mirror_remote_dsp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svl_traps_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 2, control_protocol);
    bv.set_bits(1, 1, control_ipc);
    bv.set_bits(0, 0, svl_mc_prune);
    return bv;
}


void npl_svl_traps_t::unpack(bit_vector64_t bv) 
{
    control_protocol = bv.bits(2, 2).get_value();
    control_ipc = bv.bits(1, 1).get_value();
    svl_mc_prune = bv.bits(0, 0).get_value();
}



field_structure npl_svl_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svl_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(control_protocol);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("control_protocol", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(control_ipc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("control_ipc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(svl_mc_prune);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svl_mc_prune", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svl_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svl_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svl_uc_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 15, padding);
    bv.set_bits(14, 11, fwd_hdr_type);
    bv.set_bits(10, 0, dsp);
    return bv;
}


void npl_svl_uc_data_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 15).get_value();
    fwd_hdr_type = (npl_fwd_header_type_e)bv.bits(14, 11).get_value();
    dsp = bv.bits(10, 0).get_value();
}



field_structure npl_svl_uc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svl_uc_data_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = npl_enum_to_string(fwd_hdr_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_hdr_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svl_uc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svl_uc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_system_mcid_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 0, id);
    return bv;
}


void npl_system_mcid_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(17, 0).get_value();
}



field_structure npl_system_mcid_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_system_mcid_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_system_mcid_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_system_mcid_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_te_headend_nhlfe_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 8, lsp_destination.pack());
    bv.set_bits(7, 0, counter_offset.pack());
    return bv;
}


void npl_te_headend_nhlfe_t::unpack(bit_vector64_t bv) 
{
    lsp_destination.unpack(bv.bits(27, 8));
    counter_offset.unpack(bv.bits(7, 0));
}



field_structure npl_te_headend_nhlfe_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_te_headend_nhlfe_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lsp_destination", lsp_destination.to_field_structure());
    fs_result.subfields.emplace_back("counter_offset", counter_offset.to_field_structure());
    return fs_result;
}
std::string to_string(npl_te_headend_nhlfe_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_te_headend_nhlfe_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_te_midpoint_nhlfe_t_anonymous_union_lsp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    if (swap_label != 0) {  // union primitive field start
        bv.set_bits(19, 0, swap_label);
        return bv;
    }// union primitive field end
    
    if (lsp_id != 0) {  // union primitive field start
        bv.set_bits(19, 0, lsp_id);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_te_midpoint_nhlfe_t_anonymous_union_lsp_t::unpack(bit_vector64_t bv) // union
{
    swap_label = bv.bits(19, 0).get_value();
}



field_structure npl_te_midpoint_nhlfe_t_anonymous_union_lsp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_te_midpoint_nhlfe_t_anonymous_union_lsp_t";
    field_structure fs_subfield;
    //add members to result
    if (swap_label != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(swap_label);
        return union_found;
    }// union primitive field end
    
    if (lsp_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lsp_id);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_te_midpoint_nhlfe_t_anonymous_union_lsp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_te_midpoint_nhlfe_t_anonymous_union_lsp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tm_header_base_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 6, hdr_type);
    bv.set_bits(5, 5, vce);
    bv.set_bits(4, 2, tc);
    bv.set_bits(1, 0, dp);
    return bv;
}


void npl_tm_header_base_t::unpack(bit_vector64_t bv) 
{
    hdr_type = (npl_tm_header_type_e)bv.bits(7, 6).get_value();
    vce = bv.bits(5, 5).get_value();
    tc = bv.bits(4, 2).get_value();
    dp = bv.bits(1, 0).get_value();
}



field_structure npl_tm_header_base_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tm_header_base_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(hdr_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("hdr_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vce);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vce", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tm_header_base_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tm_header_base_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tos_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 2, dscp);
    bv.set_bits(1, 0, ecn);
    return bv;
}


void npl_tos_t::unpack(bit_vector64_t bv) 
{
    dscp = bv.bits(7, 2).get_value();
    ecn = bv.bits(1, 0).get_value();
}



field_structure npl_tos_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tos_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dscp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dscp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ecn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ecn", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tos_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tos_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tpid_sa_lsb_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, sa_lsb);
    bv.set_bits(15, 0, tpid);
    return bv;
}


void npl_tpid_sa_lsb_t::unpack(bit_vector64_t bv) 
{
    sa_lsb = bv.bits(31, 16).get_value();
    tpid = bv.bits(15, 0).get_value();
}



field_structure npl_tpid_sa_lsb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tpid_sa_lsb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sa_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_lsb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tpid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tpid", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tpid_sa_lsb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tpid_sa_lsb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_trap_conditions_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, non_inject_up);
    bv.set_bits(0, 0, skip_p2p);
    return bv;
}


void npl_trap_conditions_t::unpack(bit_vector64_t bv) 
{
    non_inject_up = bv.bits(1, 1).get_value();
    skip_p2p = bv.bits(0, 0).get_value();
}



field_structure npl_trap_conditions_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_trap_conditions_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(non_inject_up);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("non_inject_up", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(skip_p2p);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("skip_p2p", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_trap_conditions_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_trap_conditions_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_traps_t::pack(void) const 
{
    bit_vector384_t bv(0, 197);
    bv.set_bits(196, 142, ethernet.pack());
    bv.set_bits(141, 135, ipv4.pack());
    bv.set_bits(134, 126, ipv6.pack());
    bv.set_bits(125, 101, mpls.pack());
    bv.set_bits(100, 48, l3.pack());
    bv.set_bits(47, 23, oamp.pack());
    bv.set_bits(22, 20, app.pack());
    bv.set_bits(19, 17, svl.pack());
    bv.set_bits(16, 5, l2_lpts.pack());
    bv.set_bits(4, 0, internal.pack());
    return bv;
}


void npl_traps_t::unpack(bit_vector384_t bv) 
{
    ethernet.unpack(bv.bits(196, 142));
    ipv4.unpack(bv.bits(141, 135));
    ipv6.unpack(bv.bits(134, 126));
    mpls.unpack(bv.bits(125, 101));
    l3.unpack(bv.bits(100, 48));
    oamp.unpack(bv.bits(47, 23));
    app.unpack(bv.bits(22, 20));
    svl.unpack(bv.bits(19, 17));
    l2_lpts.unpack(bv.bits(16, 5));
    internal.unpack(bv.bits(4, 0));
}



field_structure npl_traps_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_traps_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ethernet", ethernet.to_field_structure());
    fs_result.subfields.emplace_back("ipv4", ipv4.to_field_structure());
    fs_result.subfields.emplace_back("ipv6", ipv6.to_field_structure());
    fs_result.subfields.emplace_back("mpls", mpls.to_field_structure());
    fs_result.subfields.emplace_back("l3", l3.to_field_structure());
    fs_result.subfields.emplace_back("oamp", oamp.to_field_structure());
    fs_result.subfields.emplace_back("app", app.to_field_structure());
    fs_result.subfields.emplace_back("svl", svl.to_field_structure());
    fs_result.subfields.emplace_back("l2_lpts", l2_lpts.to_field_structure());
    fs_result.subfields.emplace_back("internal", internal.to_field_structure());
    return fs_result;
}
std::string to_string(npl_traps_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_traps_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ts_cmd_trans_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 5, op);
    bv.set_bits(4, 4, udp_offset_sel);
    bv.set_bits(3, 3, update_udp_cs);
    bv.set_bits(2, 2, reset_udp_cs);
    bv.set_bits(1, 0, ifg_ts_cmd);
    return bv;
}


void npl_ts_cmd_trans_t::unpack(bit_vector64_t bv) 
{
    op = (npl_txpp_ts_cmd_e)bv.bits(8, 5).get_value();
    udp_offset_sel = bv.bits(4, 4).get_value();
    update_udp_cs = bv.bits(3, 3).get_value();
    reset_udp_cs = bv.bits(2, 2).get_value();
    ifg_ts_cmd = (npl_ifg_ts_cmd_e)bv.bits(1, 0).get_value();
}



field_structure npl_ts_cmd_trans_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ts_cmd_trans_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(op);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("op", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(udp_offset_sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("udp_offset_sel", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(update_udp_cs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("update_udp_cs", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(reset_udp_cs);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reset_udp_cs", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ifg_ts_cmd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ifg_ts_cmd", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ts_cmd_trans_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ts_cmd_trans_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ts_command_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 8, op);
    // PADDING -  bv.set_bits(7, 7, padding);
    bv.set_bits(6, 0, offset);
    return bv;
}


void npl_ts_command_t::unpack(bit_vector64_t bv) 
{
    op = bv.bits(11, 8).get_value();
    // PADDING -  padding = bv.bits(7, 7).get_value();
    offset = bv.bits(6, 0).get_value();
}



field_structure npl_ts_command_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ts_command_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(op);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("op", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ts_command_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ts_command_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ttl_and_protocol_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, ttl);
    bv.set_bits(7, 0, protocol);
    return bv;
}


void npl_ttl_and_protocol_t::unpack(bit_vector64_t bv) 
{
    ttl = bv.bits(15, 8).get_value();
    protocol = bv.bits(7, 0).get_value();
}



field_structure npl_ttl_and_protocol_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ttl_and_protocol_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(protocol);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("protocol", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ttl_and_protocol_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ttl_and_protocol_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tunnel_control_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, decrement_inner_ttl);
    bv.set_bits(2, 2, ttl_mode);
    bv.set_bits(1, 1, is_tos_from_tunnel);
    bv.set_bits(0, 0, lp_set);
    return bv;
}


void npl_tunnel_control_t::unpack(bit_vector64_t bv) 
{
    decrement_inner_ttl = bv.bits(3, 3).get_value();
    ttl_mode = (npl_ttl_mode_e)bv.bits(2, 2).get_value();
    is_tos_from_tunnel = bv.bits(1, 1).get_value();
    lp_set = bv.bits(0, 0).get_value();
}



field_structure npl_tunnel_control_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tunnel_control_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(decrement_inner_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("decrement_inner_ttl", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ttl_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl_mode", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_tos_from_tunnel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_tos_from_tunnel", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lp_set);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_set", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tunnel_control_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tunnel_control_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tunnel_headend_encap_t_anonymous_union_te_asbr_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (te_tunnel != 0) {  // union primitive field start
        bv.set_bits(15, 0, te_tunnel);
        return bv;
    }// union primitive field end
    
    if (asbr != 0) {  // union primitive field start
        bv.set_bits(15, 0, asbr);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_tunnel_headend_encap_t_anonymous_union_te_asbr_t::unpack(bit_vector64_t bv) // union
{
    te_tunnel = bv.bits(15, 0).get_value();
}



field_structure npl_tunnel_headend_encap_t_anonymous_union_te_asbr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tunnel_headend_encap_t_anonymous_union_te_asbr_t";
    field_structure fs_subfield;
    //add members to result
    if (te_tunnel != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(te_tunnel);
        return union_found;
    }// union primitive field end
    
    if (asbr != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(asbr);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_tunnel_headend_encap_t_anonymous_union_te_asbr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tunnel_headend_encap_t_anonymous_union_te_asbr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tunnel_type_q_counter_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 19, tunnel_type);
    bv.set_bits(18, 0, q_counter);
    return bv;
}


void npl_tunnel_type_q_counter_t::unpack(bit_vector64_t bv) 
{
    tunnel_type = (npl_ip_tunnel_encap_type_e)bv.bits(19, 19).get_value();
    q_counter = bv.bits(18, 0).get_value();
}



field_structure npl_tunnel_type_q_counter_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tunnel_type_q_counter_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(tunnel_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tunnel_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(q_counter);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("q_counter", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tunnel_type_q_counter_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tunnel_type_q_counter_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tunnel_underlay_mc_da_qos_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 16, nh_encap_da);
    // PADDING -  bv.set_bits(15, 15, padding);
    bv.set_bits(14, 8, muxed_qos_group.pack());
    // PADDING -  bv.set_bits(7, 7, padding);
    bv.set_bits(6, 0, local_mapping_qos_tag.pack());
    return bv;
}


void npl_tunnel_underlay_mc_da_qos_payload_t::unpack(bit_vector64_t bv) 
{
    nh_encap_da = bv.bits(63, 16).get_value();
    // PADDING -  padding = bv.bits(15, 15).get_value();
    muxed_qos_group.unpack(bv.bits(14, 8));
    // PADDING -  padding = bv.bits(7, 7).get_value();
    local_mapping_qos_tag.unpack(bv.bits(6, 0));
}



field_structure npl_tunnel_underlay_mc_da_qos_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tunnel_underlay_mc_da_qos_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(nh_encap_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh_encap_da", fs_subfield);
    
    
    fs_result.subfields.emplace_back("muxed_qos_group", muxed_qos_group.to_field_structure());
    
    fs_result.subfields.emplace_back("local_mapping_qos_tag", local_mapping_qos_tag.to_field_structure());
    return fs_result;
}
std::string to_string(npl_tunnel_underlay_mc_da_qos_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tunnel_underlay_mc_da_qos_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tx_punt_nw_encap_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 8, punt_nw_encap_type);
    bv.set_bits(7, 0, punt_nw_encap_ptr.pack());
    return bv;
}


void npl_tx_punt_nw_encap_ptr_t::unpack(bit_vector64_t bv) 
{
    punt_nw_encap_type = (npl_punt_nw_encap_type_e)bv.bits(11, 8).get_value();
    punt_nw_encap_ptr.unpack(bv.bits(7, 0));
}



field_structure npl_tx_punt_nw_encap_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tx_punt_nw_encap_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(punt_nw_encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_nw_encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("punt_nw_encap_ptr", punt_nw_encap_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_tx_punt_nw_encap_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tx_punt_nw_encap_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_txpp_em_dlp_profile_mapping_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 18, dlp_type);
    bv.set_bits(17, 0, dlp_id);
    return bv;
}


void npl_txpp_em_dlp_profile_mapping_key_t::unpack(bit_vector64_t bv) 
{
    dlp_type = bv.bits(19, 18).get_value();
    dlp_id = bv.bits(17, 0).get_value();
}



field_structure npl_txpp_em_dlp_profile_mapping_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_txpp_em_dlp_profile_mapping_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dlp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dlp_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dlp_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dlp_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_txpp_em_dlp_profile_mapping_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_txpp_em_dlp_profile_mapping_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_txpp_first_macro_table_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 24, is_mc);
    bv.set_bits(23, 20, fwd_type);
    bv.set_bits(19, 16, encap_type);
    bv.set_bits(15, 8, field_a);
    bv.set_bits(7, 0, field_b);
    return bv;
}


void npl_txpp_first_macro_table_key_t::unpack(bit_vector64_t bv) 
{
    is_mc = bv.bits(24, 24).get_value();
    fwd_type = bv.bits(23, 20).get_value();
    encap_type = bv.bits(19, 16).get_value();
    field_a = bv.bits(15, 8).get_value();
    field_b = bv.bits(7, 0).get_value();
}



field_structure npl_txpp_first_macro_table_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_txpp_first_macro_table_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fwd_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("encap_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(field_a);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("field_a", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(field_b);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("field_b", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_txpp_first_macro_table_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_txpp_first_macro_table_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_udf_t::pack(void) const 
{
    bit_vector128_t bv(0, 128);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 128 - 1;
        size_t msb = 0;
        const uint64_t * p = value;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_udf_t::unpack(bit_vector128_t bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 128 - 1;
        size_t msb = 0;
        uint64_t * p = value;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_udf_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_udf_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 128 - 1;
        size_t msb = 0;
        const uint64_t * p = value;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_udf_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_udf_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_udp_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, sport);
    bv.set_bits(15, 0, dport);
    return bv;
}


void npl_udp_encap_data_t::unpack(bit_vector64_t bv) 
{
    sport = bv.bits(31, 16).get_value();
    dport = bv.bits(15, 0).get_value();
}



field_structure npl_udp_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_udp_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sport);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sport", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dport);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dport", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_udp_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_udp_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_unicast_flb_tm_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 16, base.pack());
    bv.set_bits(15, 13, reserved);
    bv.set_bits(12, 0, dsp);
    return bv;
}


void npl_unicast_flb_tm_header_t::unpack(bit_vector64_t bv) 
{
    base.unpack(bv.bits(23, 16));
    reserved = bv.bits(15, 13).get_value();
    dsp = bv.bits(12, 0).get_value();
}



field_structure npl_unicast_flb_tm_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_unicast_flb_tm_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("base", base.to_field_structure());
    fs_subfield.flat_value = to_hex_string(reserved);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reserved", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_unicast_flb_tm_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_unicast_flb_tm_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_unicast_plb_tm_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 24, base.pack());
    bv.set_bits(23, 21, reserved);
    bv.set_bits(20, 12, destination_device);
    bv.set_bits(11, 9, destination_slice);
    bv.set_bits(8, 0, destination_oq);
    return bv;
}


void npl_unicast_plb_tm_header_t::unpack(bit_vector64_t bv) 
{
    base.unpack(bv.bits(31, 24));
    reserved = bv.bits(23, 21).get_value();
    destination_device = bv.bits(20, 12).get_value();
    destination_slice = bv.bits(11, 9).get_value();
    destination_oq = bv.bits(8, 0).get_value();
}



field_structure npl_unicast_plb_tm_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_unicast_plb_tm_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("base", base.to_field_structure());
    fs_subfield.flat_value = to_hex_string(reserved);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reserved", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_device);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_device", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_slice);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_slice", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_oq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_oq", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_unicast_plb_tm_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_unicast_plb_tm_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_unscheduled_recycle_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, recycle_pkt);
    bv.set_bits(0, 0, unscheduled_recycle_code_lsb);
    return bv;
}


void npl_unscheduled_recycle_code_t::unpack(bit_vector64_t bv) 
{
    recycle_pkt = bv.bits(1, 1).get_value();
    unscheduled_recycle_code_lsb = bv.bits(0, 0).get_value();
}



field_structure npl_unscheduled_recycle_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_unscheduled_recycle_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(recycle_pkt);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("recycle_pkt", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(unscheduled_recycle_code_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unscheduled_recycle_code_lsb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_unscheduled_recycle_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_unscheduled_recycle_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_use_metedata_table_per_packet_format_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, use_metadata_table_for_ip_packet.pack());
    bv.set_bits(0, 0, use_metadata_table_for_non_ip_packet.pack());
    return bv;
}


void npl_use_metedata_table_per_packet_format_t::unpack(bit_vector64_t bv) 
{
    use_metadata_table_for_ip_packet.unpack(bv.bits(1, 1));
    use_metadata_table_for_non_ip_packet.unpack(bv.bits(0, 0));
}



field_structure npl_use_metedata_table_per_packet_format_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_use_metedata_table_per_packet_format_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("use_metadata_table_for_ip_packet", use_metadata_table_for_ip_packet.to_field_structure());
    fs_result.subfields.emplace_back("use_metadata_table_for_non_ip_packet", use_metadata_table_for_non_ip_packet.to_field_structure());
    return fs_result;
}
std::string to_string(npl_use_metedata_table_per_packet_format_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_use_metedata_table_per_packet_format_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vid2_or_flood_rcy_sm_vlans_t::pack(void) const // union
{
    bit_vector64_t bv(0, 24);
    if (vid2 != 0) {  // union primitive field start
        bv.set_bits(11, 0, vid2);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = flood_rcy_sm_vlans.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_vid2_or_flood_rcy_sm_vlans_t::unpack(bit_vector64_t bv) // union
{
    vid2 = bv.bits(11, 0).get_value();
}



field_structure npl_vid2_or_flood_rcy_sm_vlans_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vid2_or_flood_rcy_sm_vlans_t";
    field_structure fs_subfield;
    //add members to result
    if (vid2 != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(vid2);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = flood_rcy_sm_vlans.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("flood_rcy_sm_vlans", flood_rcy_sm_vlans.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_vid2_or_flood_rcy_sm_vlans_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vid2_or_flood_rcy_sm_vlans_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vlan_and_sa_lsb_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 44);
    bv.set_bits(43, 32, vlan_id);
    bv.set_bits(31, 0, tpid_sa_lsb.pack());
    return bv;
}


void npl_vlan_and_sa_lsb_encap_t::unpack(bit_vector64_t bv) 
{
    vlan_id = bv.bits(43, 32).get_value();
    tpid_sa_lsb.unpack(bv.bits(31, 0));
}



field_structure npl_vlan_and_sa_lsb_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vlan_and_sa_lsb_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(vlan_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vlan_id", fs_subfield);
    
    fs_result.subfields.emplace_back("tpid_sa_lsb", tpid_sa_lsb.to_field_structure());
    return fs_result;
}
std::string to_string(npl_vlan_and_sa_lsb_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vlan_and_sa_lsb_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vlan_edit_secondary_type_with_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    // PADDING -  bv.set_bits(11, 3, padding);
    bv.set_bits(2, 0, secondary_type);
    return bv;
}


void npl_vlan_edit_secondary_type_with_padding_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(11, 3).get_value();
    secondary_type = (npl_vlan_edit_command_secondary_type_e)bv.bits(2, 0).get_value();
}



field_structure npl_vlan_edit_secondary_type_with_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vlan_edit_secondary_type_with_padding_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = npl_enum_to_string(secondary_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("secondary_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_vlan_edit_secondary_type_with_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vlan_edit_secondary_type_with_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vlan_header_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    // PADDING -  bv.set_bits(2, 1, padding);
    bv.set_bits(0, 0, is_priority);
    return bv;
}


void npl_vlan_header_flags_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(2, 1).get_value();
    is_priority = bv.bits(0, 0).get_value();
}



field_structure npl_vlan_header_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vlan_header_flags_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(is_priority);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_priority", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_vlan_header_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vlan_header_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vlan_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 0, id);
    return bv;
}


void npl_vlan_id_t::unpack(bit_vector64_t bv) 
{
    id = bv.bits(11, 0).get_value();
}



field_structure npl_vlan_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vlan_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_vlan_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vlan_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vlan_profile_and_lp_type_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 4, l2_lp_type);
    bv.set_bits(3, 0, vlan_profile);
    return bv;
}


void npl_vlan_profile_and_lp_type_t::unpack(bit_vector64_t bv) 
{
    l2_lp_type = (npl_l2_lp_type_e)bv.bits(7, 4).get_value();
    vlan_profile = bv.bits(3, 0).get_value();
}



field_structure npl_vlan_profile_and_lp_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vlan_profile_and_lp_type_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(l2_lp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_lp_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vlan_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vlan_profile", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_vlan_profile_and_lp_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vlan_profile_and_lp_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vlan_tag_tci_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 12, pcp_dei.pack());
    bv.set_bits(11, 0, vid.pack());
    return bv;
}


void npl_vlan_tag_tci_t::unpack(bit_vector64_t bv) 
{
    pcp_dei.unpack(bv.bits(15, 12));
    vid.unpack(bv.bits(11, 0));
}



field_structure npl_vlan_tag_tci_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vlan_tag_tci_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("pcp_dei", pcp_dei.to_field_structure());
    fs_result.subfields.emplace_back("vid", vid.to_field_structure());
    return fs_result;
}
std::string to_string(npl_vlan_tag_tci_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vlan_tag_tci_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vni_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 38);
    bv.set_bits(37, 34, vlan_profile);
    bv.set_bits(33, 20, l2_relay_attributes_id.pack());
    bv.set_bits(19, 0, vni_counter.pack());
    return bv;
}


void npl_vni_table_result_t::unpack(bit_vector64_t bv) 
{
    vlan_profile = bv.bits(37, 34).get_value();
    l2_relay_attributes_id.unpack(bv.bits(33, 20));
    vni_counter.unpack(bv.bits(19, 0));
}



field_structure npl_vni_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vni_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(vlan_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vlan_profile", fs_subfield);
    
    fs_result.subfields.emplace_back("l2_relay_attributes_id", l2_relay_attributes_id.to_field_structure());
    fs_result.subfields.emplace_back("vni_counter", vni_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_vni_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vni_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_buffers_consumption_lut_for_deq_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 60, congestion_level[15].pack());
    bv.set_bits(59, 56, congestion_level[14].pack());
    bv.set_bits(55, 52, congestion_level[13].pack());
    bv.set_bits(51, 48, congestion_level[12].pack());
    bv.set_bits(47, 44, congestion_level[11].pack());
    bv.set_bits(43, 40, congestion_level[10].pack());
    bv.set_bits(39, 36, congestion_level[9].pack());
    bv.set_bits(35, 32, congestion_level[8].pack());
    bv.set_bits(31, 28, congestion_level[7].pack());
    bv.set_bits(27, 24, congestion_level[6].pack());
    bv.set_bits(23, 20, congestion_level[5].pack());
    bv.set_bits(19, 16, congestion_level[4].pack());
    bv.set_bits(15, 12, congestion_level[3].pack());
    bv.set_bits(11, 8, congestion_level[2].pack());
    bv.set_bits(7, 4, congestion_level[1].pack());
    bv.set_bits(3, 0, congestion_level[0].pack());
    return bv;
}


void npl_voq_cgm_slice_buffers_consumption_lut_for_deq_results_t::unpack(bit_vector64_t bv) 
{
    congestion_level[15].unpack(bv.bits(63, 60));
    congestion_level[14].unpack(bv.bits(59, 56));
    congestion_level[13].unpack(bv.bits(55, 52));
    congestion_level[12].unpack(bv.bits(51, 48));
    congestion_level[11].unpack(bv.bits(47, 44));
    congestion_level[10].unpack(bv.bits(43, 40));
    congestion_level[9].unpack(bv.bits(39, 36));
    congestion_level[8].unpack(bv.bits(35, 32));
    congestion_level[7].unpack(bv.bits(31, 28));
    congestion_level[6].unpack(bv.bits(27, 24));
    congestion_level[5].unpack(bv.bits(23, 20));
    congestion_level[4].unpack(bv.bits(19, 16));
    congestion_level[3].unpack(bv.bits(15, 12));
    congestion_level[2].unpack(bv.bits(11, 8));
    congestion_level[1].unpack(bv.bits(7, 4));
    congestion_level[0].unpack(bv.bits(3, 0));
}



field_structure npl_voq_cgm_slice_buffers_consumption_lut_for_deq_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_buffers_consumption_lut_for_deq_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("congestion_level[15]", congestion_level[15].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[14]", congestion_level[14].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[13]", congestion_level[13].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[12]", congestion_level[12].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[11]", congestion_level[11].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[10]", congestion_level[10].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[9]", congestion_level[9].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[8]", congestion_level[8].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[7]", congestion_level[7].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[6]", congestion_level[6].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[5]", congestion_level[5].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[4]", congestion_level[4].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[3]", congestion_level[3].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[2]", congestion_level[2].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[1]", congestion_level[1].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[0]", congestion_level[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_buffers_consumption_lut_for_deq_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_buffers_consumption_lut_for_deq_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_dram_consumption_lut_for_deq_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 28, congestion_level[7].pack());
    bv.set_bits(27, 24, congestion_level[6].pack());
    bv.set_bits(23, 20, congestion_level[5].pack());
    bv.set_bits(19, 16, congestion_level[4].pack());
    bv.set_bits(15, 12, congestion_level[3].pack());
    bv.set_bits(11, 8, congestion_level[2].pack());
    bv.set_bits(7, 4, congestion_level[1].pack());
    bv.set_bits(3, 0, congestion_level[0].pack());
    return bv;
}


void npl_voq_cgm_slice_dram_consumption_lut_for_deq_results_t::unpack(bit_vector64_t bv) 
{
    congestion_level[7].unpack(bv.bits(31, 28));
    congestion_level[6].unpack(bv.bits(27, 24));
    congestion_level[5].unpack(bv.bits(23, 20));
    congestion_level[4].unpack(bv.bits(19, 16));
    congestion_level[3].unpack(bv.bits(15, 12));
    congestion_level[2].unpack(bv.bits(11, 8));
    congestion_level[1].unpack(bv.bits(7, 4));
    congestion_level[0].unpack(bv.bits(3, 0));
}



field_structure npl_voq_cgm_slice_dram_consumption_lut_for_deq_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_dram_consumption_lut_for_deq_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("congestion_level[7]", congestion_level[7].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[6]", congestion_level[6].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[5]", congestion_level[5].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[4]", congestion_level[4].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[3]", congestion_level[3].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[2]", congestion_level[2].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[1]", congestion_level[1].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[0]", congestion_level[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_dram_consumption_lut_for_deq_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_dram_consumption_lut_for_deq_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_drop_color_probability_selector_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 30);
    bv.set_bits(29, 25, drop_prob[5].pack());
    bv.set_bits(24, 20, drop_prob[4].pack());
    bv.set_bits(19, 15, drop_prob[3].pack());
    bv.set_bits(14, 10, drop_prob[2].pack());
    bv.set_bits(9, 5, drop_prob[1].pack());
    bv.set_bits(4, 0, drop_prob[0].pack());
    return bv;
}


void npl_voq_cgm_slice_drop_color_probability_selector_results_t::unpack(bit_vector64_t bv) 
{
    drop_prob[5].unpack(bv.bits(29, 25));
    drop_prob[4].unpack(bv.bits(24, 20));
    drop_prob[3].unpack(bv.bits(19, 15));
    drop_prob[2].unpack(bv.bits(14, 10));
    drop_prob[1].unpack(bv.bits(9, 5));
    drop_prob[0].unpack(bv.bits(4, 0));
}



field_structure npl_voq_cgm_slice_drop_color_probability_selector_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_drop_color_probability_selector_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("drop_prob[5]", drop_prob[5].to_field_structure());
    fs_result.subfields.emplace_back("drop_prob[4]", drop_prob[4].to_field_structure());
    fs_result.subfields.emplace_back("drop_prob[3]", drop_prob[3].to_field_structure());
    fs_result.subfields.emplace_back("drop_prob[2]", drop_prob[2].to_field_structure());
    fs_result.subfields.emplace_back("drop_prob[1]", drop_prob[1].to_field_structure());
    fs_result.subfields.emplace_back("drop_prob[0]", drop_prob[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_drop_color_probability_selector_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_drop_color_probability_selector_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_evicted_buffers_consumption_lut_for_enq_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, drop_yellow);
    bv.set_bits(0, 0, drop_green);
    return bv;
}


void npl_voq_cgm_slice_evicted_buffers_consumption_lut_for_enq_table_result_t::unpack(bit_vector64_t bv) 
{
    drop_yellow = bv.bits(1, 1).get_value();
    drop_green = bv.bits(0, 0).get_value();
}



field_structure npl_voq_cgm_slice_evicted_buffers_consumption_lut_for_enq_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_evicted_buffers_consumption_lut_for_enq_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(drop_yellow);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_yellow", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop_green);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_green", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_evicted_buffers_consumption_lut_for_enq_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_evicted_buffers_consumption_lut_for_enq_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_eviction_ok_lut_for_enq_table_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 2);
    bv.set_bits(1, 1, drop_on_eviction);
    bv.set_bits(0, 0, eviction_ok);
    return bv;
}


void npl_voq_cgm_slice_eviction_ok_lut_for_enq_table_results_t::unpack(bit_vector64_t bv) 
{
    drop_on_eviction = bv.bits(1, 1).get_value();
    eviction_ok = bv.bits(0, 0).get_value();
}



field_structure npl_voq_cgm_slice_eviction_ok_lut_for_enq_table_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_eviction_ok_lut_for_enq_table_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(drop_on_eviction);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_on_eviction", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eviction_ok);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eviction_ok", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_eviction_ok_lut_for_enq_table_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_eviction_ok_lut_for_enq_table_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_mark_color_probability_selector_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 30);
    bv.set_bits(29, 25, mark_yellow_prob[2].pack());
    bv.set_bits(24, 20, mark_yellow_prob[1].pack());
    bv.set_bits(19, 15, mark_yellow_prob[0].pack());
    bv.set_bits(14, 10, mark_green_prob[2].pack());
    bv.set_bits(9, 5, mark_green_prob[1].pack());
    bv.set_bits(4, 0, mark_green_prob[0].pack());
    return bv;
}


void npl_voq_cgm_slice_mark_color_probability_selector_results_t::unpack(bit_vector64_t bv) 
{
    mark_yellow_prob[2].unpack(bv.bits(29, 25));
    mark_yellow_prob[1].unpack(bv.bits(24, 20));
    mark_yellow_prob[0].unpack(bv.bits(19, 15));
    mark_green_prob[2].unpack(bv.bits(14, 10));
    mark_green_prob[1].unpack(bv.bits(9, 5));
    mark_green_prob[0].unpack(bv.bits(4, 0));
}



field_structure npl_voq_cgm_slice_mark_color_probability_selector_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_mark_color_probability_selector_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mark_yellow_prob[2]", mark_yellow_prob[2].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow_prob[1]", mark_yellow_prob[1].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow_prob[0]", mark_yellow_prob[0].to_field_structure());
    fs_result.subfields.emplace_back("mark_green_prob[2]", mark_green_prob[2].to_field_structure());
    fs_result.subfields.emplace_back("mark_green_prob[1]", mark_green_prob[1].to_field_structure());
    fs_result.subfields.emplace_back("mark_green_prob[0]", mark_green_prob[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_mark_color_probability_selector_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_mark_color_probability_selector_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_pd_consumption_lut_for_deq_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 60, congestion_level[15].pack());
    bv.set_bits(59, 56, congestion_level[14].pack());
    bv.set_bits(55, 52, congestion_level[13].pack());
    bv.set_bits(51, 48, congestion_level[12].pack());
    bv.set_bits(47, 44, congestion_level[11].pack());
    bv.set_bits(43, 40, congestion_level[10].pack());
    bv.set_bits(39, 36, congestion_level[9].pack());
    bv.set_bits(35, 32, congestion_level[8].pack());
    bv.set_bits(31, 28, congestion_level[7].pack());
    bv.set_bits(27, 24, congestion_level[6].pack());
    bv.set_bits(23, 20, congestion_level[5].pack());
    bv.set_bits(19, 16, congestion_level[4].pack());
    bv.set_bits(15, 12, congestion_level[3].pack());
    bv.set_bits(11, 8, congestion_level[2].pack());
    bv.set_bits(7, 4, congestion_level[1].pack());
    bv.set_bits(3, 0, congestion_level[0].pack());
    return bv;
}


void npl_voq_cgm_slice_pd_consumption_lut_for_deq_results_t::unpack(bit_vector64_t bv) 
{
    congestion_level[15].unpack(bv.bits(63, 60));
    congestion_level[14].unpack(bv.bits(59, 56));
    congestion_level[13].unpack(bv.bits(55, 52));
    congestion_level[12].unpack(bv.bits(51, 48));
    congestion_level[11].unpack(bv.bits(47, 44));
    congestion_level[10].unpack(bv.bits(43, 40));
    congestion_level[9].unpack(bv.bits(39, 36));
    congestion_level[8].unpack(bv.bits(35, 32));
    congestion_level[7].unpack(bv.bits(31, 28));
    congestion_level[6].unpack(bv.bits(27, 24));
    congestion_level[5].unpack(bv.bits(23, 20));
    congestion_level[4].unpack(bv.bits(19, 16));
    congestion_level[3].unpack(bv.bits(15, 12));
    congestion_level[2].unpack(bv.bits(11, 8));
    congestion_level[1].unpack(bv.bits(7, 4));
    congestion_level[0].unpack(bv.bits(3, 0));
}



field_structure npl_voq_cgm_slice_pd_consumption_lut_for_deq_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_pd_consumption_lut_for_deq_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("congestion_level[15]", congestion_level[15].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[14]", congestion_level[14].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[13]", congestion_level[13].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[12]", congestion_level[12].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[11]", congestion_level[11].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[10]", congestion_level[10].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[9]", congestion_level[9].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[8]", congestion_level[8].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[7]", congestion_level[7].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[6]", congestion_level[6].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[5]", congestion_level[5].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[4]", congestion_level[4].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[3]", congestion_level[3].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[2]", congestion_level[2].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[1]", congestion_level[1].to_field_structure());
    fs_result.subfields.emplace_back("congestion_level[0]", congestion_level[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_pd_consumption_lut_for_deq_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_pd_consumption_lut_for_deq_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_voq_cgm_slice_pd_consumption_lut_for_enq_results_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 79, mark_yellow[15].pack());
    bv.set_bits(78, 78, mark_yellow[14].pack());
    bv.set_bits(77, 77, mark_yellow[13].pack());
    bv.set_bits(76, 76, mark_yellow[12].pack());
    bv.set_bits(75, 75, mark_yellow[11].pack());
    bv.set_bits(74, 74, mark_yellow[10].pack());
    bv.set_bits(73, 73, mark_yellow[9].pack());
    bv.set_bits(72, 72, mark_yellow[8].pack());
    bv.set_bits(71, 71, mark_yellow[7].pack());
    bv.set_bits(70, 70, mark_yellow[6].pack());
    bv.set_bits(69, 69, mark_yellow[5].pack());
    bv.set_bits(68, 68, mark_yellow[4].pack());
    bv.set_bits(67, 67, mark_yellow[3].pack());
    bv.set_bits(66, 66, mark_yellow[2].pack());
    bv.set_bits(65, 65, mark_yellow[1].pack());
    bv.set_bits(64, 64, mark_yellow[0].pack());
    bv.set_bits(63, 63, mark_green[15].pack());
    bv.set_bits(62, 62, mark_green[14].pack());
    bv.set_bits(61, 61, mark_green[13].pack());
    bv.set_bits(60, 60, mark_green[12].pack());
    bv.set_bits(59, 59, mark_green[11].pack());
    bv.set_bits(58, 58, mark_green[10].pack());
    bv.set_bits(57, 57, mark_green[9].pack());
    bv.set_bits(56, 56, mark_green[8].pack());
    bv.set_bits(55, 55, mark_green[7].pack());
    bv.set_bits(54, 54, mark_green[6].pack());
    bv.set_bits(53, 53, mark_green[5].pack());
    bv.set_bits(52, 52, mark_green[4].pack());
    bv.set_bits(51, 51, mark_green[3].pack());
    bv.set_bits(50, 50, mark_green[2].pack());
    bv.set_bits(49, 49, mark_green[1].pack());
    bv.set_bits(48, 48, mark_green[0].pack());
    bv.set_bits(47, 47, evict_to_dram[15].pack());
    bv.set_bits(46, 46, evict_to_dram[14].pack());
    bv.set_bits(45, 45, evict_to_dram[13].pack());
    bv.set_bits(44, 44, evict_to_dram[12].pack());
    bv.set_bits(43, 43, evict_to_dram[11].pack());
    bv.set_bits(42, 42, evict_to_dram[10].pack());
    bv.set_bits(41, 41, evict_to_dram[9].pack());
    bv.set_bits(40, 40, evict_to_dram[8].pack());
    bv.set_bits(39, 39, evict_to_dram[7].pack());
    bv.set_bits(38, 38, evict_to_dram[6].pack());
    bv.set_bits(37, 37, evict_to_dram[5].pack());
    bv.set_bits(36, 36, evict_to_dram[4].pack());
    bv.set_bits(35, 35, evict_to_dram[3].pack());
    bv.set_bits(34, 34, evict_to_dram[2].pack());
    bv.set_bits(33, 33, evict_to_dram[1].pack());
    bv.set_bits(32, 32, evict_to_dram[0].pack());
    bv.set_bits(31, 31, drop_yellow[15].pack());
    bv.set_bits(30, 30, drop_yellow[14].pack());
    bv.set_bits(29, 29, drop_yellow[13].pack());
    bv.set_bits(28, 28, drop_yellow[12].pack());
    bv.set_bits(27, 27, drop_yellow[11].pack());
    bv.set_bits(26, 26, drop_yellow[10].pack());
    bv.set_bits(25, 25, drop_yellow[9].pack());
    bv.set_bits(24, 24, drop_yellow[8].pack());
    bv.set_bits(23, 23, drop_yellow[7].pack());
    bv.set_bits(22, 22, drop_yellow[6].pack());
    bv.set_bits(21, 21, drop_yellow[5].pack());
    bv.set_bits(20, 20, drop_yellow[4].pack());
    bv.set_bits(19, 19, drop_yellow[3].pack());
    bv.set_bits(18, 18, drop_yellow[2].pack());
    bv.set_bits(17, 17, drop_yellow[1].pack());
    bv.set_bits(16, 16, drop_yellow[0].pack());
    bv.set_bits(15, 15, drop_green[15].pack());
    bv.set_bits(14, 14, drop_green[14].pack());
    bv.set_bits(13, 13, drop_green[13].pack());
    bv.set_bits(12, 12, drop_green[12].pack());
    bv.set_bits(11, 11, drop_green[11].pack());
    bv.set_bits(10, 10, drop_green[10].pack());
    bv.set_bits(9, 9, drop_green[9].pack());
    bv.set_bits(8, 8, drop_green[8].pack());
    bv.set_bits(7, 7, drop_green[7].pack());
    bv.set_bits(6, 6, drop_green[6].pack());
    bv.set_bits(5, 5, drop_green[5].pack());
    bv.set_bits(4, 4, drop_green[4].pack());
    bv.set_bits(3, 3, drop_green[3].pack());
    bv.set_bits(2, 2, drop_green[2].pack());
    bv.set_bits(1, 1, drop_green[1].pack());
    bv.set_bits(0, 0, drop_green[0].pack());
    return bv;
}


void npl_voq_cgm_slice_pd_consumption_lut_for_enq_results_t::unpack(bit_vector128_t bv) 
{
    mark_yellow[15].unpack(bv.bits(79, 79));
    mark_yellow[14].unpack(bv.bits(78, 78));
    mark_yellow[13].unpack(bv.bits(77, 77));
    mark_yellow[12].unpack(bv.bits(76, 76));
    mark_yellow[11].unpack(bv.bits(75, 75));
    mark_yellow[10].unpack(bv.bits(74, 74));
    mark_yellow[9].unpack(bv.bits(73, 73));
    mark_yellow[8].unpack(bv.bits(72, 72));
    mark_yellow[7].unpack(bv.bits(71, 71));
    mark_yellow[6].unpack(bv.bits(70, 70));
    mark_yellow[5].unpack(bv.bits(69, 69));
    mark_yellow[4].unpack(bv.bits(68, 68));
    mark_yellow[3].unpack(bv.bits(67, 67));
    mark_yellow[2].unpack(bv.bits(66, 66));
    mark_yellow[1].unpack(bv.bits(65, 65));
    mark_yellow[0].unpack(bv.bits(64, 64));
    mark_green[15].unpack(bv.bits(63, 63));
    mark_green[14].unpack(bv.bits(62, 62));
    mark_green[13].unpack(bv.bits(61, 61));
    mark_green[12].unpack(bv.bits(60, 60));
    mark_green[11].unpack(bv.bits(59, 59));
    mark_green[10].unpack(bv.bits(58, 58));
    mark_green[9].unpack(bv.bits(57, 57));
    mark_green[8].unpack(bv.bits(56, 56));
    mark_green[7].unpack(bv.bits(55, 55));
    mark_green[6].unpack(bv.bits(54, 54));
    mark_green[5].unpack(bv.bits(53, 53));
    mark_green[4].unpack(bv.bits(52, 52));
    mark_green[3].unpack(bv.bits(51, 51));
    mark_green[2].unpack(bv.bits(50, 50));
    mark_green[1].unpack(bv.bits(49, 49));
    mark_green[0].unpack(bv.bits(48, 48));
    evict_to_dram[15].unpack(bv.bits(47, 47));
    evict_to_dram[14].unpack(bv.bits(46, 46));
    evict_to_dram[13].unpack(bv.bits(45, 45));
    evict_to_dram[12].unpack(bv.bits(44, 44));
    evict_to_dram[11].unpack(bv.bits(43, 43));
    evict_to_dram[10].unpack(bv.bits(42, 42));
    evict_to_dram[9].unpack(bv.bits(41, 41));
    evict_to_dram[8].unpack(bv.bits(40, 40));
    evict_to_dram[7].unpack(bv.bits(39, 39));
    evict_to_dram[6].unpack(bv.bits(38, 38));
    evict_to_dram[5].unpack(bv.bits(37, 37));
    evict_to_dram[4].unpack(bv.bits(36, 36));
    evict_to_dram[3].unpack(bv.bits(35, 35));
    evict_to_dram[2].unpack(bv.bits(34, 34));
    evict_to_dram[1].unpack(bv.bits(33, 33));
    evict_to_dram[0].unpack(bv.bits(32, 32));
    drop_yellow[15].unpack(bv.bits(31, 31));
    drop_yellow[14].unpack(bv.bits(30, 30));
    drop_yellow[13].unpack(bv.bits(29, 29));
    drop_yellow[12].unpack(bv.bits(28, 28));
    drop_yellow[11].unpack(bv.bits(27, 27));
    drop_yellow[10].unpack(bv.bits(26, 26));
    drop_yellow[9].unpack(bv.bits(25, 25));
    drop_yellow[8].unpack(bv.bits(24, 24));
    drop_yellow[7].unpack(bv.bits(23, 23));
    drop_yellow[6].unpack(bv.bits(22, 22));
    drop_yellow[5].unpack(bv.bits(21, 21));
    drop_yellow[4].unpack(bv.bits(20, 20));
    drop_yellow[3].unpack(bv.bits(19, 19));
    drop_yellow[2].unpack(bv.bits(18, 18));
    drop_yellow[1].unpack(bv.bits(17, 17));
    drop_yellow[0].unpack(bv.bits(16, 16));
    drop_green[15].unpack(bv.bits(15, 15));
    drop_green[14].unpack(bv.bits(14, 14));
    drop_green[13].unpack(bv.bits(13, 13));
    drop_green[12].unpack(bv.bits(12, 12));
    drop_green[11].unpack(bv.bits(11, 11));
    drop_green[10].unpack(bv.bits(10, 10));
    drop_green[9].unpack(bv.bits(9, 9));
    drop_green[8].unpack(bv.bits(8, 8));
    drop_green[7].unpack(bv.bits(7, 7));
    drop_green[6].unpack(bv.bits(6, 6));
    drop_green[5].unpack(bv.bits(5, 5));
    drop_green[4].unpack(bv.bits(4, 4));
    drop_green[3].unpack(bv.bits(3, 3));
    drop_green[2].unpack(bv.bits(2, 2));
    drop_green[1].unpack(bv.bits(1, 1));
    drop_green[0].unpack(bv.bits(0, 0));
}



field_structure npl_voq_cgm_slice_pd_consumption_lut_for_enq_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_pd_consumption_lut_for_enq_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mark_yellow[15]", mark_yellow[15].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[14]", mark_yellow[14].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[13]", mark_yellow[13].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[12]", mark_yellow[12].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[11]", mark_yellow[11].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[10]", mark_yellow[10].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[9]", mark_yellow[9].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[8]", mark_yellow[8].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[7]", mark_yellow[7].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[6]", mark_yellow[6].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[5]", mark_yellow[5].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[4]", mark_yellow[4].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[3]", mark_yellow[3].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[2]", mark_yellow[2].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[1]", mark_yellow[1].to_field_structure());
    fs_result.subfields.emplace_back("mark_yellow[0]", mark_yellow[0].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[15]", mark_green[15].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[14]", mark_green[14].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[13]", mark_green[13].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[12]", mark_green[12].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[11]", mark_green[11].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[10]", mark_green[10].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[9]", mark_green[9].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[8]", mark_green[8].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[7]", mark_green[7].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[6]", mark_green[6].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[5]", mark_green[5].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[4]", mark_green[4].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[3]", mark_green[3].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[2]", mark_green[2].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[1]", mark_green[1].to_field_structure());
    fs_result.subfields.emplace_back("mark_green[0]", mark_green[0].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[15]", evict_to_dram[15].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[14]", evict_to_dram[14].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[13]", evict_to_dram[13].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[12]", evict_to_dram[12].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[11]", evict_to_dram[11].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[10]", evict_to_dram[10].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[9]", evict_to_dram[9].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[8]", evict_to_dram[8].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[7]", evict_to_dram[7].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[6]", evict_to_dram[6].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[5]", evict_to_dram[5].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[4]", evict_to_dram[4].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[3]", evict_to_dram[3].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[2]", evict_to_dram[2].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[1]", evict_to_dram[1].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[0]", evict_to_dram[0].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[15]", drop_yellow[15].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[14]", drop_yellow[14].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[13]", drop_yellow[13].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[12]", drop_yellow[12].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[11]", drop_yellow[11].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[10]", drop_yellow[10].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[9]", drop_yellow[9].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[8]", drop_yellow[8].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[7]", drop_yellow[7].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[6]", drop_yellow[6].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[5]", drop_yellow[5].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[4]", drop_yellow[4].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[3]", drop_yellow[3].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[2]", drop_yellow[2].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[1]", drop_yellow[1].to_field_structure());
    fs_result.subfields.emplace_back("drop_yellow[0]", drop_yellow[0].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[15]", drop_green[15].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[14]", drop_green[14].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[13]", drop_green[13].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[12]", drop_green[12].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[11]", drop_green[11].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[10]", drop_green[10].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[9]", drop_green[9].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[8]", drop_green[8].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[7]", drop_green[7].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[6]", drop_green[6].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[5]", drop_green[5].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[4]", drop_green[4].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[3]", drop_green[3].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[2]", drop_green[2].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[1]", drop_green[1].to_field_structure());
    fs_result.subfields.emplace_back("drop_green[0]", drop_green[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_pd_consumption_lut_for_enq_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_pd_consumption_lut_for_enq_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_voq_cgm_slice_profile_buff_region_thresholds_results_t::pack(void) const 
{
    bit_vector384_t bv(0, 210);
    bv.set_bits(209, 196, q_size_buff_region[14].pack());
    bv.set_bits(195, 182, q_size_buff_region[13].pack());
    bv.set_bits(181, 168, q_size_buff_region[12].pack());
    bv.set_bits(167, 154, q_size_buff_region[11].pack());
    bv.set_bits(153, 140, q_size_buff_region[10].pack());
    bv.set_bits(139, 126, q_size_buff_region[9].pack());
    bv.set_bits(125, 112, q_size_buff_region[8].pack());
    bv.set_bits(111, 98, q_size_buff_region[7].pack());
    bv.set_bits(97, 84, q_size_buff_region[6].pack());
    bv.set_bits(83, 70, q_size_buff_region[5].pack());
    bv.set_bits(69, 56, q_size_buff_region[4].pack());
    bv.set_bits(55, 42, q_size_buff_region[3].pack());
    bv.set_bits(41, 28, q_size_buff_region[2].pack());
    bv.set_bits(27, 14, q_size_buff_region[1].pack());
    bv.set_bits(13, 0, q_size_buff_region[0].pack());
    return bv;
}


void npl_voq_cgm_slice_profile_buff_region_thresholds_results_t::unpack(bit_vector384_t bv) 
{
    q_size_buff_region[14].unpack(bv.bits(209, 196));
    q_size_buff_region[13].unpack(bv.bits(195, 182));
    q_size_buff_region[12].unpack(bv.bits(181, 168));
    q_size_buff_region[11].unpack(bv.bits(167, 154));
    q_size_buff_region[10].unpack(bv.bits(153, 140));
    q_size_buff_region[9].unpack(bv.bits(139, 126));
    q_size_buff_region[8].unpack(bv.bits(125, 112));
    q_size_buff_region[7].unpack(bv.bits(111, 98));
    q_size_buff_region[6].unpack(bv.bits(97, 84));
    q_size_buff_region[5].unpack(bv.bits(83, 70));
    q_size_buff_region[4].unpack(bv.bits(69, 56));
    q_size_buff_region[3].unpack(bv.bits(55, 42));
    q_size_buff_region[2].unpack(bv.bits(41, 28));
    q_size_buff_region[1].unpack(bv.bits(27, 14));
    q_size_buff_region[0].unpack(bv.bits(13, 0));
}



field_structure npl_voq_cgm_slice_profile_buff_region_thresholds_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_profile_buff_region_thresholds_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("q_size_buff_region[14]", q_size_buff_region[14].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[13]", q_size_buff_region[13].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[12]", q_size_buff_region[12].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[11]", q_size_buff_region[11].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[10]", q_size_buff_region[10].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[9]", q_size_buff_region[9].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[8]", q_size_buff_region[8].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[7]", q_size_buff_region[7].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[6]", q_size_buff_region[6].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[5]", q_size_buff_region[5].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[4]", q_size_buff_region[4].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[3]", q_size_buff_region[3].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[2]", q_size_buff_region[2].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[1]", q_size_buff_region[1].to_field_structure());
    fs_result.subfields.emplace_back("q_size_buff_region[0]", q_size_buff_region[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_profile_buff_region_thresholds_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_profile_buff_region_thresholds_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_voq_cgm_slice_profile_pkt_enq_time_region_thresholds_results_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 112, pkt_enq_time_region[14].pack());
    bv.set_bits(111, 104, pkt_enq_time_region[13].pack());
    bv.set_bits(103, 96, pkt_enq_time_region[12].pack());
    bv.set_bits(95, 88, pkt_enq_time_region[11].pack());
    bv.set_bits(87, 80, pkt_enq_time_region[10].pack());
    bv.set_bits(79, 72, pkt_enq_time_region[9].pack());
    bv.set_bits(71, 64, pkt_enq_time_region[8].pack());
    bv.set_bits(63, 56, pkt_enq_time_region[7].pack());
    bv.set_bits(55, 48, pkt_enq_time_region[6].pack());
    bv.set_bits(47, 40, pkt_enq_time_region[5].pack());
    bv.set_bits(39, 32, pkt_enq_time_region[4].pack());
    bv.set_bits(31, 24, pkt_enq_time_region[3].pack());
    bv.set_bits(23, 16, pkt_enq_time_region[2].pack());
    bv.set_bits(15, 8, pkt_enq_time_region[1].pack());
    bv.set_bits(7, 0, pkt_enq_time_region[0].pack());
    return bv;
}


void npl_voq_cgm_slice_profile_pkt_enq_time_region_thresholds_results_t::unpack(bit_vector128_t bv) 
{
    pkt_enq_time_region[14].unpack(bv.bits(119, 112));
    pkt_enq_time_region[13].unpack(bv.bits(111, 104));
    pkt_enq_time_region[12].unpack(bv.bits(103, 96));
    pkt_enq_time_region[11].unpack(bv.bits(95, 88));
    pkt_enq_time_region[10].unpack(bv.bits(87, 80));
    pkt_enq_time_region[9].unpack(bv.bits(79, 72));
    pkt_enq_time_region[8].unpack(bv.bits(71, 64));
    pkt_enq_time_region[7].unpack(bv.bits(63, 56));
    pkt_enq_time_region[6].unpack(bv.bits(55, 48));
    pkt_enq_time_region[5].unpack(bv.bits(47, 40));
    pkt_enq_time_region[4].unpack(bv.bits(39, 32));
    pkt_enq_time_region[3].unpack(bv.bits(31, 24));
    pkt_enq_time_region[2].unpack(bv.bits(23, 16));
    pkt_enq_time_region[1].unpack(bv.bits(15, 8));
    pkt_enq_time_region[0].unpack(bv.bits(7, 0));
}



field_structure npl_voq_cgm_slice_profile_pkt_enq_time_region_thresholds_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_profile_pkt_enq_time_region_thresholds_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("pkt_enq_time_region[14]", pkt_enq_time_region[14].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[13]", pkt_enq_time_region[13].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[12]", pkt_enq_time_region[12].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[11]", pkt_enq_time_region[11].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[10]", pkt_enq_time_region[10].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[9]", pkt_enq_time_region[9].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[8]", pkt_enq_time_region[8].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[7]", pkt_enq_time_region[7].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[6]", pkt_enq_time_region[6].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[5]", pkt_enq_time_region[5].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[4]", pkt_enq_time_region[4].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[3]", pkt_enq_time_region[3].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[2]", pkt_enq_time_region[2].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[1]", pkt_enq_time_region[1].to_field_structure());
    fs_result.subfields.emplace_back("pkt_enq_time_region[0]", pkt_enq_time_region[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_profile_pkt_enq_time_region_thresholds_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_profile_pkt_enq_time_region_thresholds_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_voq_cgm_slice_profile_pkt_region_thresholds_results_t::pack(void) const 
{
    bit_vector128_t bv(0, 98);
    bv.set_bits(97, 84, q_size_pkt_region[6].pack());
    bv.set_bits(83, 70, q_size_pkt_region[5].pack());
    bv.set_bits(69, 56, q_size_pkt_region[4].pack());
    bv.set_bits(55, 42, q_size_pkt_region[3].pack());
    bv.set_bits(41, 28, q_size_pkt_region[2].pack());
    bv.set_bits(27, 14, q_size_pkt_region[1].pack());
    bv.set_bits(13, 0, q_size_pkt_region[0].pack());
    return bv;
}


void npl_voq_cgm_slice_profile_pkt_region_thresholds_results_t::unpack(bit_vector128_t bv) 
{
    q_size_pkt_region[6].unpack(bv.bits(97, 84));
    q_size_pkt_region[5].unpack(bv.bits(83, 70));
    q_size_pkt_region[4].unpack(bv.bits(69, 56));
    q_size_pkt_region[3].unpack(bv.bits(55, 42));
    q_size_pkt_region[2].unpack(bv.bits(41, 28));
    q_size_pkt_region[1].unpack(bv.bits(27, 14));
    q_size_pkt_region[0].unpack(bv.bits(13, 0));
}



field_structure npl_voq_cgm_slice_profile_pkt_region_thresholds_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_profile_pkt_region_thresholds_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("q_size_pkt_region[6]", q_size_pkt_region[6].to_field_structure());
    fs_result.subfields.emplace_back("q_size_pkt_region[5]", q_size_pkt_region[5].to_field_structure());
    fs_result.subfields.emplace_back("q_size_pkt_region[4]", q_size_pkt_region[4].to_field_structure());
    fs_result.subfields.emplace_back("q_size_pkt_region[3]", q_size_pkt_region[3].to_field_structure());
    fs_result.subfields.emplace_back("q_size_pkt_region[2]", q_size_pkt_region[2].to_field_structure());
    fs_result.subfields.emplace_back("q_size_pkt_region[1]", q_size_pkt_region[1].to_field_structure());
    fs_result.subfields.emplace_back("q_size_pkt_region[0]", q_size_pkt_region[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_profile_pkt_region_thresholds_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_profile_pkt_region_thresholds_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_slice_cgm_profile_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 3);
    bv.set_bits(2, 0, counter_id);
    return bv;
}


void npl_voq_cgm_slice_slice_cgm_profile_result_t::unpack(bit_vector64_t bv) 
{
    counter_id = (npl_voq_cgm_pd_counter_e)bv.bits(2, 0).get_value();
}



field_structure npl_voq_cgm_slice_slice_cgm_profile_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_slice_cgm_profile_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(counter_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_slice_cgm_profile_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_slice_cgm_profile_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_wred_probability_region_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, region_id);
    return bv;
}


void npl_voq_cgm_wred_probability_region_id_t::unpack(bit_vector64_t bv) 
{
    region_id = bv.bits(4, 0).get_value();
}



field_structure npl_voq_cgm_wred_probability_region_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_wred_probability_region_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(region_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("region_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_wred_probability_region_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_wred_probability_region_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_wred_probability_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 17);
    bv.set_bits(16, 0, probability.pack());
    return bv;
}


void npl_voq_cgm_wred_probability_results_t::unpack(bit_vector64_t bv) 
{
    probability.unpack(bv.bits(16, 0));
}



field_structure npl_voq_cgm_wred_probability_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_wred_probability_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("probability", probability.to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_wred_probability_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_wred_probability_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_profile_len::pack(void) const 
{
    bit_vector64_t bv(0, 5);
    bv.set_bits(4, 0, value);
    return bv;
}


void npl_voq_profile_len::unpack(bit_vector64_t bv) 
{
    value = bv.bits(4, 0).get_value();
}



field_structure npl_voq_profile_len::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_profile_len";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(value);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("value", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_voq_profile_len element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_profile_len element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vpl_label_and_valid_t::pack(void) const 
{
    bit_vector64_t bv(0, 26);
    bv.set_bits(25, 25, v6_label_vld);
    bv.set_bits(24, 24, v4_label_vld);
    bv.set_bits(23, 0, label_encap.pack());
    return bv;
}


void npl_vpl_label_and_valid_t::unpack(bit_vector64_t bv) 
{
    v6_label_vld = bv.bits(25, 25).get_value();
    v4_label_vld = bv.bits(24, 24).get_value();
    label_encap.unpack(bv.bits(23, 0));
}



field_structure npl_vpl_label_and_valid_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vpl_label_and_valid_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(v6_label_vld);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("v6_label_vld", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(v4_label_vld);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("v4_label_vld", fs_subfield);
    
    fs_result.subfields.emplace_back("label_encap", label_encap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_vpl_label_and_valid_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vpl_label_and_valid_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_vxlan_dlp_specific_t::pack(void) const 
{
    bit_vector128_t bv(0, 76);
    bv.set_bits(75, 75, group_policy_encap);
    bv.set_bits(74, 74, stp_state_is_block);
    bv.set_bits(73, 72, lp_profile);
    bv.set_bits(71, 71, ttl_mode);
    bv.set_bits(70, 70, disabled);
    bv.set_bits(69, 69, lp_set);
    bv.set_bits(68, 64, qos_info.pack());
    bv.set_bits(63, 44, p_counter.pack());
    bv.set_bits(43, 40, sip_index);
    bv.set_bits(39, 8, dip.pack());
    bv.set_bits(7, 0, ttl);
    return bv;
}


void npl_vxlan_dlp_specific_t::unpack(bit_vector128_t bv) 
{
    group_policy_encap = bv.bits(75, 75).get_value();
    stp_state_is_block = bv.bits(74, 74).get_value();
    lp_profile = bv.bits(73, 72).get_value();
    ttl_mode = (npl_ttl_mode_e)bv.bits(71, 71).get_value();
    disabled = bv.bits(70, 70).get_value();
    lp_set = bv.bits(69, 69).get_value();
    qos_info.unpack(bv.bits(68, 64));
    p_counter.unpack(bv.bits(63, 44));
    sip_index = bv.bits(43, 40).get_value();
    dip.unpack(bv.bits(39, 8));
    ttl = bv.bits(7, 0).get_value();
}



field_structure npl_vxlan_dlp_specific_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vxlan_dlp_specific_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(group_policy_encap);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("group_policy_encap", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(stp_state_is_block);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("stp_state_is_block", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lp_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_profile", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ttl_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl_mode", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lp_set);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_set", fs_subfield);
    
    fs_result.subfields.emplace_back("qos_info", qos_info.to_field_structure());
    fs_result.subfields.emplace_back("p_counter", p_counter.to_field_structure());
    fs_subfield.flat_value = to_hex_string(sip_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sip_index", fs_subfield);
    
    fs_result.subfields.emplace_back("dip", dip.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_vxlan_dlp_specific_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vxlan_dlp_specific_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vxlan_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 24, group_policy_id);
    bv.set_bits(23, 0, vni);
    return bv;
}


void npl_vxlan_encap_data_t::unpack(bit_vector64_t bv) 
{
    group_policy_id = bv.bits(39, 24).get_value();
    vni = bv.bits(23, 0).get_value();
}



field_structure npl_vxlan_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vxlan_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(group_policy_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("group_policy_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vni);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vni", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_vxlan_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vxlan_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_vxlan_relay_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 44);
    bv.set_bits(43, 20, vni);
    bv.set_bits(19, 0, vni_counter.pack());
    return bv;
}


void npl_vxlan_relay_encap_data_t::unpack(bit_vector64_t bv) 
{
    vni = bv.bits(43, 20).get_value();
    vni_counter.unpack(bv.bits(19, 0));
}



field_structure npl_vxlan_relay_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vxlan_relay_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(vni);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vni", fs_subfield);
    
    fs_result.subfields.emplace_back("vni_counter", vni_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_vxlan_relay_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vxlan_relay_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_wfq_priority_weight_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, weight);
    return bv;
}


void npl_wfq_priority_weight_t::unpack(bit_vector64_t bv) 
{
    weight = bv.bits(7, 0).get_value();
}



field_structure npl_wfq_priority_weight_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_wfq_priority_weight_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(weight);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("weight", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_wfq_priority_weight_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_wfq_priority_weight_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_wfq_weight_4p_entry_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 24, priority[3].pack());
    bv.set_bits(23, 16, priority[2].pack());
    bv.set_bits(15, 8, priority[1].pack());
    bv.set_bits(7, 0, priority[0].pack());
    return bv;
}


void npl_wfq_weight_4p_entry_t::unpack(bit_vector64_t bv) 
{
    priority[3].unpack(bv.bits(31, 24));
    priority[2].unpack(bv.bits(23, 16));
    priority[1].unpack(bv.bits(15, 8));
    priority[0].unpack(bv.bits(7, 0));
}



field_structure npl_wfq_weight_4p_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_wfq_weight_4p_entry_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("priority[3]", priority[3].to_field_structure());
    fs_result.subfields.emplace_back("priority[2]", priority[2].to_field_structure());
    fs_result.subfields.emplace_back("priority[1]", priority[1].to_field_structure());
    fs_result.subfields.emplace_back("priority[0]", priority[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_wfq_weight_4p_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_wfq_weight_4p_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_wfq_weight_8p_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 56, priority[7].pack());
    bv.set_bits(55, 48, priority[6].pack());
    bv.set_bits(47, 40, priority[5].pack());
    bv.set_bits(39, 32, priority[4].pack());
    bv.set_bits(31, 24, priority[3].pack());
    bv.set_bits(23, 16, priority[2].pack());
    bv.set_bits(15, 8, priority[1].pack());
    bv.set_bits(7, 0, priority[0].pack());
    return bv;
}


void npl_wfq_weight_8p_t::unpack(bit_vector64_t bv) 
{
    priority[7].unpack(bv.bits(63, 56));
    priority[6].unpack(bv.bits(55, 48));
    priority[5].unpack(bv.bits(47, 40));
    priority[4].unpack(bv.bits(39, 32));
    priority[3].unpack(bv.bits(31, 24));
    priority[2].unpack(bv.bits(23, 16));
    priority[1].unpack(bv.bits(15, 8));
    priority[0].unpack(bv.bits(7, 0));
}



field_structure npl_wfq_weight_8p_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_wfq_weight_8p_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("priority[7]", priority[7].to_field_structure());
    fs_result.subfields.emplace_back("priority[6]", priority[6].to_field_structure());
    fs_result.subfields.emplace_back("priority[5]", priority[5].to_field_structure());
    fs_result.subfields.emplace_back("priority[4]", priority[4].to_field_structure());
    fs_result.subfields.emplace_back("priority[3]", priority[3].to_field_structure());
    fs_result.subfields.emplace_back("priority[2]", priority[2].to_field_structure());
    fs_result.subfields.emplace_back("priority[1]", priority[1].to_field_structure());
    fs_result.subfields.emplace_back("priority[0]", priority[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_wfq_weight_8p_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_wfq_weight_8p_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_wide_protection_entry_t::pack(void) const // union
{
    bit_vector128_t bv(0, 65);
    { // union compound field start
        bit_vector128_t tbv = stage0_l2_dlp_dest_l2_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(64, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage1_nh_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(64, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage1_te_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(64, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage1_raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(64, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_wide_protection_entry_t::unpack(bit_vector128_t bv) // union
{
    stage0_l2_dlp_dest_l2_dlp.unpack(bv.bits(64, 0));
}



field_structure npl_wide_protection_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_wide_protection_entry_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = stage0_l2_dlp_dest_l2_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_l2_dlp_dest_l2_dlp", stage0_l2_dlp_dest_l2_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage1_nh_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_nh_dest", stage1_nh_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage1_te_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_te_tunnel", stage1_te_tunnel.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage1_raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_raw", stage1_raw.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_wide_protection_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_wide_protection_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_app_relay_id_t::pack(void) const // union
{
    bit_vector64_t bv(0, 14);
    { // union compound field start
        bit_vector64_t tbv = l2_relay_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(13, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_relay_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(11, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_app_relay_id_t::unpack(bit_vector64_t bv) // union
{
    l2_relay_id.unpack(bv.bits(13, 0));
}



field_structure npl_app_relay_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_relay_id_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_relay_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_relay_id", l2_relay_id.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_relay_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_relay_id", l3_relay_id.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_app_relay_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_relay_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_base_l3_lp_attributes_t_anonymous_union_rtf_conf_set_and_stages_or_post_fwd_stage_t::pack(void) const // union
{
    bit_vector64_t bv(0, 12);
    { // union compound field start
        bit_vector64_t tbv = rtf_conf_set_and_stages.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(11, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ip_ver_and_post_fwd_stage.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(3, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_base_l3_lp_attributes_t_anonymous_union_rtf_conf_set_and_stages_or_post_fwd_stage_t::unpack(bit_vector64_t bv) // union
{
    rtf_conf_set_and_stages.unpack(bv.bits(11, 0));
}



field_structure npl_base_l3_lp_attributes_t_anonymous_union_rtf_conf_set_and_stages_or_post_fwd_stage_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_base_l3_lp_attributes_t_anonymous_union_rtf_conf_set_and_stages_or_post_fwd_stage_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = rtf_conf_set_and_stages.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rtf_conf_set_and_stages", rtf_conf_set_and_stages.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ip_ver_and_post_fwd_stage.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ip_ver_and_post_fwd_stage", ip_ver_and_post_fwd_stage.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_base_l3_lp_attributes_t_anonymous_union_rtf_conf_set_and_stages_or_post_fwd_stage_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_base_l3_lp_attributes_t_anonymous_union_rtf_conf_set_and_stages_or_post_fwd_stage_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_aux_shared_payload_t_anonymous_union_prot_shared_t::pack(void) const // union
{
    bit_vector64_t bv(0, 40);
    { // union compound field start
        bit_vector64_t tbv = ipv6.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv4.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_bfd_aux_shared_payload_t_anonymous_union_prot_shared_t::unpack(bit_vector64_t bv) // union
{
    ipv6.unpack(bv.bits(39, 0));
}



field_structure npl_bfd_aux_shared_payload_t_anonymous_union_prot_shared_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_shared_payload_t_anonymous_union_prot_shared_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ipv6.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv6", ipv6.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv4.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv4", ipv4.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_bfd_aux_shared_payload_t_anonymous_union_prot_shared_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_shared_payload_t_anonymous_union_prot_shared_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_aux_transmit_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 8, prot_trans.pack());
    // PADDING -  bv.set_bits(7, 4, padding);
    bv.set_bits(3, 1, interval_selector);
    bv.set_bits(0, 0, echo_mode_enabled);
    return bv;
}


void npl_bfd_aux_transmit_payload_t::unpack(bit_vector64_t bv) 
{
    prot_trans.unpack(bv.bits(39, 8));
    // PADDING -  padding = bv.bits(7, 4).get_value();
    interval_selector = bv.bits(3, 1).get_value();
    echo_mode_enabled = bv.bits(0, 0).get_value();
}



field_structure npl_bfd_aux_transmit_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_transmit_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("prot_trans", prot_trans.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(interval_selector);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("interval_selector", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(echo_mode_enabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("echo_mode_enabled", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_aux_transmit_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_transmit_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_flags_state_t_anonymous_union_bfd_flags_t::pack(void) const // union
{
    bit_vector64_t bv(0, 6);
    { // union compound field start
        bit_vector64_t tbv = indiv_flags.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(5, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (flags != 0) {  // union primitive field start
        bv.set_bits(5, 0, flags);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_bfd_flags_state_t_anonymous_union_bfd_flags_t::unpack(bit_vector64_t bv) // union
{
    indiv_flags.unpack(bv.bits(5, 0));
}



field_structure npl_bfd_flags_state_t_anonymous_union_bfd_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_flags_state_t_anonymous_union_bfd_flags_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = indiv_flags.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("indiv_flags", indiv_flags.to_field_structure());
        }
    } // union compound field end
    
    if (flags != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(flags);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_bfd_flags_state_t_anonymous_union_bfd_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_flags_state_t_anonymous_union_bfd_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_mp_table_extra_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 16, mpls_label.pack());
    bv.set_bits(15, 0, extra_tx_b.pack());
    return bv;
}


void npl_bfd_mp_table_extra_payload_t::unpack(bit_vector64_t bv) 
{
    mpls_label.unpack(bv.bits(47, 16));
    extra_tx_b.unpack(bv.bits(15, 0));
}



field_structure npl_bfd_mp_table_extra_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_extra_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mpls_label", mpls_label.to_field_structure());
    fs_result.subfields.emplace_back("extra_tx_b", extra_tx_b.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_extra_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_extra_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_mp_table_shared_msb_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 3, trans_data.pack());
    bv.set_bits(2, 0, transport_label.pack());
    return bv;
}


void npl_bfd_mp_table_shared_msb_t::unpack(bit_vector64_t bv) 
{
    trans_data.unpack(bv.bits(59, 3));
    transport_label.unpack(bv.bits(2, 0));
}



field_structure npl_bfd_mp_table_shared_msb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_shared_msb_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("trans_data", trans_data.to_field_structure());
    fs_result.subfields.emplace_back("transport_label", transport_label.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_shared_msb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_shared_msb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_cntr_offset_and_padding_t_anonymous_union_cntr_offset_t::pack(void) const // union
{
    bit_vector64_t bv(0, 4);
    { // union compound field start
        bit_vector64_t tbv = offset.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_common_cntr_offset_and_padding_t_anonymous_union_cntr_offset_t::unpack(bit_vector64_t bv) // union
{
    
}



field_structure npl_common_cntr_offset_and_padding_t_anonymous_union_cntr_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_cntr_offset_and_padding_t_anonymous_union_cntr_offset_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = offset.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("offset", offset.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_common_cntr_offset_and_padding_t_anonymous_union_cntr_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_cntr_offset_and_padding_t_anonymous_union_cntr_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_cntr_offset_packed_t_anonymous_union_cntr_offset_t::pack(void) const // union
{
    bit_vector64_t bv(0, 4);
    { // union compound field start
        bit_vector64_t tbv = offset.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_common_cntr_offset_packed_t_anonymous_union_cntr_offset_t::unpack(bit_vector64_t bv) // union
{
    offset.unpack(bv.bits(2, 0));
}



field_structure npl_common_cntr_offset_packed_t_anonymous_union_cntr_offset_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_cntr_offset_packed_t_anonymous_union_cntr_offset_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = offset.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("offset", offset.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_common_cntr_offset_packed_t_anonymous_union_cntr_offset_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_cntr_offset_packed_t_anonymous_union_cntr_offset_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_fwd_info_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 0, macro_or_fwd_dest.pack());
    return bv;
}


void npl_db_access_fwd_info_header_t::unpack(bit_vector64_t bv) 
{
    macro_or_fwd_dest.unpack(bv.bits(23, 0));
}



field_structure npl_db_access_fwd_info_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_fwd_info_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("macro_or_fwd_dest", macro_or_fwd_dest.to_field_structure());
    return fs_result;
}
std::string to_string(npl_db_access_fwd_info_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_fwd_info_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_db_access_fwd_macro_dests_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 52, bucket_a_lu_dest);
    bv.set_bits(51, 48, bucket_b_lu_dest);
    bv.set_bits(47, 44, bucket_c_lu_dest);
    bv.set_bits(43, 40, bucket_d_lu_dest);
    bv.set_bits(39, 36, bucket_a_result_dest);
    bv.set_bits(35, 32, bucket_b_result_dest);
    bv.set_bits(31, 28, bucket_c_result_dest);
    bv.set_bits(27, 24, bucket_d_result_dest);
    bv.set_bits(23, 0, db_access_key_selectors_header.pack());
    return bv;
}


void npl_db_access_fwd_macro_dests_header_t::unpack(bit_vector64_t bv) 
{
    bucket_a_lu_dest = (npl_fwd_bucket_a_lu_dest_e)bv.bits(55, 52).get_value();
    bucket_b_lu_dest = (npl_fwd_bucket_b_lu_dest_e)bv.bits(51, 48).get_value();
    bucket_c_lu_dest = (npl_fwd_bucket_c_lu_dest_e)bv.bits(47, 44).get_value();
    bucket_d_lu_dest = (npl_fwd_bucket_d_lu_dest_e)bv.bits(43, 40).get_value();
    bucket_a_result_dest = (npl_fwd_bucket_a_result_dest_e)bv.bits(39, 36).get_value();
    bucket_b_result_dest = (npl_fwd_bucket_b_result_dest_e)bv.bits(35, 32).get_value();
    bucket_c_result_dest = (npl_fwd_bucket_c_result_dest_e)bv.bits(31, 28).get_value();
    bucket_d_result_dest = (npl_fwd_bucket_d_result_dest_e)bv.bits(27, 24).get_value();
    db_access_key_selectors_header.unpack(bv.bits(23, 0));
}



field_structure npl_db_access_fwd_macro_dests_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_db_access_fwd_macro_dests_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(bucket_a_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_b_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_c_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_d_lu_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_lu_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_a_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_a_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_b_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_b_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_c_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_c_result_dest", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bucket_d_result_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bucket_d_result_dest", fs_subfield);
    
    fs_result.subfields.emplace_back("db_access_key_selectors_header", db_access_key_selectors_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_db_access_fwd_macro_dests_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_db_access_fwd_macro_dests_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_demux_pif_ifg_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 6, pad);
    bv.set_bits(5, 0, pif_ifg.pack());
    return bv;
}


void npl_demux_pif_ifg_t::unpack(bit_vector64_t bv) 
{
    pad = bv.bits(6, 6).get_value();
    pif_ifg.unpack(bv.bits(5, 0));
}



field_structure npl_demux_pif_ifg_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_demux_pif_ifg_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(pad);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pad", fs_subfield);
    
    fs_result.subfields.emplace_back("pif_ifg", pif_ifg.to_field_structure());
    return fs_result;
}
std::string to_string(npl_demux_pif_ifg_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_demux_pif_ifg_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_destination_prefix_lp_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 16, prefix);
    bv.set_bits(15, 4, lsbs.pack());
    bv.set_bits(3, 2, msbs.pack());
    // PADDING -  bv.set_bits(1, 0, padding);
    return bv;
}


void npl_destination_prefix_lp_t::unpack(bit_vector64_t bv) 
{
    prefix = bv.bits(19, 16).get_value();
    lsbs.unpack(bv.bits(15, 4));
    msbs.unpack(bv.bits(3, 2));
    // PADDING -  padding = bv.bits(1, 0).get_value();
}



field_structure npl_destination_prefix_lp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_destination_prefix_lp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(prefix);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prefix", fs_subfield);
    
    fs_result.subfields.emplace_back("lsbs", lsbs.to_field_structure());
    fs_result.subfields.emplace_back("msbs", msbs.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_destination_prefix_lp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_destination_prefix_lp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dlp_profile_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    { // union compound field start
        bit_vector64_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_sec.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_dlp_profile_t::unpack(bit_vector64_t bv) // union
{
    l2.unpack(bv.bits(7, 0));
}



field_structure npl_dlp_profile_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dlp_profile_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2", l2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_sec.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_sec", l3_sec.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_dlp_profile_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dlp_profile_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_drop_color_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 45, drop_color[15].pack());
    bv.set_bits(44, 42, drop_color[14].pack());
    bv.set_bits(41, 39, drop_color[13].pack());
    bv.set_bits(38, 36, drop_color[12].pack());
    bv.set_bits(35, 33, drop_color[11].pack());
    bv.set_bits(32, 30, drop_color[10].pack());
    bv.set_bits(29, 27, drop_color[9].pack());
    bv.set_bits(26, 24, drop_color[8].pack());
    bv.set_bits(23, 21, drop_color[7].pack());
    bv.set_bits(20, 18, drop_color[6].pack());
    bv.set_bits(17, 15, drop_color[5].pack());
    bv.set_bits(14, 12, drop_color[4].pack());
    bv.set_bits(11, 9, drop_color[3].pack());
    bv.set_bits(8, 6, drop_color[2].pack());
    bv.set_bits(5, 3, drop_color[1].pack());
    bv.set_bits(2, 0, drop_color[0].pack());
    return bv;
}


void npl_drop_color_t::unpack(bit_vector64_t bv) 
{
    drop_color[15].unpack(bv.bits(47, 45));
    drop_color[14].unpack(bv.bits(44, 42));
    drop_color[13].unpack(bv.bits(41, 39));
    drop_color[12].unpack(bv.bits(38, 36));
    drop_color[11].unpack(bv.bits(35, 33));
    drop_color[10].unpack(bv.bits(32, 30));
    drop_color[9].unpack(bv.bits(29, 27));
    drop_color[8].unpack(bv.bits(26, 24));
    drop_color[7].unpack(bv.bits(23, 21));
    drop_color[6].unpack(bv.bits(20, 18));
    drop_color[5].unpack(bv.bits(17, 15));
    drop_color[4].unpack(bv.bits(14, 12));
    drop_color[3].unpack(bv.bits(11, 9));
    drop_color[2].unpack(bv.bits(8, 6));
    drop_color[1].unpack(bv.bits(5, 3));
    drop_color[0].unpack(bv.bits(2, 0));
}



field_structure npl_drop_color_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_drop_color_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("drop_color[15]", drop_color[15].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[14]", drop_color[14].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[13]", drop_color[13].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[12]", drop_color[12].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[11]", drop_color[11].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[10]", drop_color[10].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[9]", drop_color[9].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[8]", drop_color[8].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[7]", drop_color[7].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[6]", drop_color[6].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[5]", drop_color[5].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[4]", drop_color[4].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[3]", drop_color[3].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[2]", drop_color[2].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[1]", drop_color[1].to_field_structure());
    fs_result.subfields.emplace_back("drop_color[0]", drop_color[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_drop_color_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_drop_color_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dsp_attr_common_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 23, dsp_is_dma);
    bv.set_bits(22, 21, dsp_map_info.pack());
    bv.set_bits(20, 20, mask_egress_vlan_edit);
    bv.set_bits(19, 4, dsp);
    bv.set_bits(3, 3, svl_vpc_prune_port);
    // PADDING -  bv.set_bits(2, 0, padding);
    return bv;
}


void npl_dsp_attr_common_t::unpack(bit_vector64_t bv) 
{
    dsp_is_dma = bv.bits(23, 23).get_value();
    dsp_map_info.unpack(bv.bits(22, 21));
    mask_egress_vlan_edit = bv.bits(20, 20).get_value();
    dsp = bv.bits(19, 4).get_value();
    svl_vpc_prune_port = bv.bits(3, 3).get_value();
    // PADDING -  padding = bv.bits(2, 0).get_value();
}



field_structure npl_dsp_attr_common_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dsp_attr_common_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(dsp_is_dma);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp_is_dma", fs_subfield);
    
    fs_result.subfields.emplace_back("dsp_map_info", dsp_map_info.to_field_structure());
    fs_subfield.flat_value = to_hex_string(mask_egress_vlan_edit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mask_egress_vlan_edit", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(svl_vpc_prune_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svl_vpc_prune_port", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_dsp_attr_common_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dsp_attr_common_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dsp_l2_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 40, mc_pruning_low);
    bv.set_bits(39, 24, mc_pruning_high);
    bv.set_bits(23, 0, dsp_attr_common.pack());
    return bv;
}


void npl_dsp_l2_attributes_t::unpack(bit_vector64_t bv) 
{
    mc_pruning_low = bv.bits(55, 40).get_value();
    mc_pruning_high = bv.bits(39, 24).get_value();
    dsp_attr_common.unpack(bv.bits(23, 0));
}



field_structure npl_dsp_l2_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dsp_l2_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mc_pruning_low);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mc_pruning_low", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mc_pruning_high);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mc_pruning_high", fs_subfield);
    
    fs_result.subfields.emplace_back("dsp_attr_common", dsp_attr_common.to_field_structure());
    return fs_result;
}
std::string to_string(npl_dsp_l2_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dsp_l2_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dsp_l3_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 42);
    bv.set_bits(41, 28, mtu);
    // PADDING -  bv.set_bits(27, 26, padding);
    bv.set_bits(25, 25, no_decrement_ttl);
    bv.set_bits(24, 24, mpls_ip_ttl_propagation);
    bv.set_bits(23, 0, dsp_attr_common.pack());
    return bv;
}


void npl_dsp_l3_attributes_t::unpack(bit_vector64_t bv) 
{
    mtu = bv.bits(41, 28).get_value();
    // PADDING -  padding = bv.bits(27, 26).get_value();
    no_decrement_ttl = bv.bits(25, 25).get_value();
    mpls_ip_ttl_propagation = (npl_ttl_mode_e)bv.bits(24, 24).get_value();
    dsp_attr_common.unpack(bv.bits(23, 0));
}



field_structure npl_dsp_l3_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dsp_l3_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mtu);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mtu", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(no_decrement_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_decrement_ttl", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(mpls_ip_ttl_propagation);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mpls_ip_ttl_propagation", fs_subfield);
    
    fs_result.subfields.emplace_back("dsp_attr_common", dsp_attr_common.to_field_structure());
    return fs_result;
}
std::string to_string(npl_dsp_l3_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dsp_l3_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_sec_acl_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 21, drop_punt_or_permit.pack());
    bv.set_bits(20, 20, mirror_valid);
    bv.set_bits(19, 0, drop_or_permit.pack());
    return bv;
}


void npl_egress_sec_acl_result_t::unpack(bit_vector64_t bv) 
{
    drop_punt_or_permit.unpack(bv.bits(23, 21));
    mirror_valid = bv.bits(20, 20).get_value();
    drop_or_permit.unpack(bv.bits(19, 0));
}



field_structure npl_egress_sec_acl_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_sec_acl_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("drop_punt_or_permit", drop_punt_or_permit.to_field_structure());
    fs_subfield.flat_value = to_hex_string(mirror_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mirror_valid", fs_subfield);
    
    fs_result.subfields.emplace_back("drop_or_permit", drop_or_permit.to_field_structure());
    return fs_result;
}
std::string to_string(npl_egress_sec_acl_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_sec_acl_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 63);
    // PADDING -  bv.set_bits(62, 48, padding);
    bv.set_bits(47, 28, em_rpf_src.pack());
    bv.set_bits(27, 20, class_id.pack());
    bv.set_bits(19, 0, dest.pack());
    return bv;
}


void npl_em_destination_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(62, 48).get_value();
    em_rpf_src.unpack(bv.bits(47, 28));
    class_id.unpack(bv.bits(27, 20));
    dest.unpack(bv.bits(19, 0));
}



field_structure npl_em_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_destination_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("em_rpf_src", em_rpf_src.to_field_structure());
    fs_result.subfields.emplace_back("class_id", class_id.to_field_structure());
    fs_result.subfields.emplace_back("dest", dest.to_field_structure());
    return fs_result;
}
std::string to_string(npl_em_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_payload_t::pack(void) const // union
{
    bit_vector64_t bv(0, 40);
    { // union compound field start
        bit_vector64_t tbv = ethernet_oam.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(28, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = bfd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mpls_tp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pfc.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_em_payload_t::unpack(bit_vector64_t bv) // union
{
    ethernet_oam.unpack(bv.bits(28, 0));
}



field_structure npl_em_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_payload_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ethernet_oam.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ethernet_oam", ethernet_oam.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = bfd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("bfd", bfd.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mpls_tp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mpls_tp", mpls_tp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pfc.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pfc", pfc.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_em_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_result_dsp_host_w_class_t::pack(void) const 
{
    bit_vector64_t bv(0, 63);
    bv.set_bits(62, 60, dest_type_or_has_class.pack());
    bv.set_bits(59, 56, class_id);
    bv.set_bits(55, 48, dest);
    bv.set_bits(47, 41, host_mac_msb);
    bv.set_bits(40, 40, extra_dest_bit);
    bv.set_bits(39, 0, host_mac_lsb);
    return bv;
}


void npl_em_result_dsp_host_w_class_t::unpack(bit_vector64_t bv) 
{
    dest_type_or_has_class.unpack(bv.bits(62, 60));
    class_id = bv.bits(59, 56).get_value();
    dest = bv.bits(55, 48).get_value();
    host_mac_msb = bv.bits(47, 41).get_value();
    extra_dest_bit = bv.bits(40, 40).get_value();
    host_mac_lsb = bv.bits(39, 0).get_value();
}



field_structure npl_em_result_dsp_host_w_class_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_result_dsp_host_w_class_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("dest_type_or_has_class", dest_type_or_has_class.to_field_structure());
    fs_subfield.flat_value = to_hex_string(class_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("class_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(host_mac_msb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_mac_msb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(extra_dest_bit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("extra_dest_bit", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(host_mac_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_mac_lsb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_em_result_dsp_host_w_class_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_result_dsp_host_w_class_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_inject_down_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 25, ene_inject_down_encap_type);
    bv.set_bits(24, 20, ene_inject_phb.pack());
    bv.set_bits(19, 0, ene_inject_destination.pack());
    return bv;
}


void npl_ene_inject_down_payload_t::unpack(bit_vector64_t bv) 
{
    ene_inject_down_encap_type = (npl_inject_down_encap_type_e)bv.bits(27, 25).get_value();
    ene_inject_phb.unpack(bv.bits(24, 20));
    ene_inject_destination.unpack(bv.bits(19, 0));
}



field_structure npl_ene_inject_down_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_inject_down_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ene_inject_down_encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_inject_down_encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("ene_inject_phb", ene_inject_phb.to_field_structure());
    fs_result.subfields.emplace_back("ene_inject_destination", ene_inject_destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ene_inject_down_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_inject_down_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_dsp_and_ssp_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, ssp.pack());
    bv.set_bits(15, 0, dsp);
    return bv;
}


void npl_ene_punt_dsp_and_ssp_t::unpack(bit_vector64_t bv) 
{
    ssp.unpack(bv.bits(31, 16));
    dsp = bv.bits(15, 0).get_value();
}



field_structure npl_ene_punt_dsp_and_ssp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_dsp_and_ssp_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ssp", ssp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ene_punt_dsp_and_ssp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_dsp_and_ssp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_eth_oam_aux_shared_payload_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 0, meg_id.pack());
    return bv;
}


void npl_eth_oam_aux_shared_payload_t::unpack(bit_vector128_t bv) 
{
    meg_id.unpack(bv.bits(119, 0));
}



field_structure npl_eth_oam_aux_shared_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_oam_aux_shared_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("meg_id", meg_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_eth_oam_aux_shared_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_oam_aux_shared_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_eth_rtf_iteration_properties_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 4, f0_rtf_prop.pack());
    bv.set_bits(3, 0, stop_on_step_and_next_stage_compressed_fields.pack());
    return bv;
}


void npl_eth_rtf_iteration_properties_t::unpack(bit_vector64_t bv) 
{
    f0_rtf_prop.unpack(bv.bits(11, 4));
    stop_on_step_and_next_stage_compressed_fields.unpack(bv.bits(3, 0));
}



field_structure npl_eth_rtf_iteration_properties_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_rtf_iteration_properties_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("f0_rtf_prop", f0_rtf_prop.to_field_structure());
    fs_result.subfields.emplace_back("stop_on_step_and_next_stage_compressed_fields", stop_on_step_and_next_stage_compressed_fields.to_field_structure());
    return fs_result;
}
std::string to_string(npl_eth_rtf_iteration_properties_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_rtf_iteration_properties_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ethernet_mac_t::pack(void) const 
{
    bit_vector128_t bv(0, 96);
    bv.set_bits(95, 48, da.pack());
    bv.set_bits(47, 0, sa.pack());
    return bv;
}


void npl_ethernet_mac_t::unpack(bit_vector128_t bv) 
{
    da.unpack(bv.bits(95, 48));
    sa.unpack(bv.bits(47, 0));
}



field_structure npl_ethernet_mac_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ethernet_mac_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("da", da.to_field_structure());
    fs_result.subfields.emplace_back("sa", sa.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ethernet_mac_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ethernet_mac_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_flc_header_types_array_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 20, range_comp_sel_3.pack());
    bv.set_bits(19, 15, range_comp_sel_2.pack());
    bv.set_bits(14, 10, range_comp_sel_1.pack());
    bv.set_bits(9, 5, range_comp_sel_0.pack());
    bv.set_bits(4, 4, range_comp_vld_3);
    bv.set_bits(3, 3, range_comp_vld_2);
    bv.set_bits(2, 2, range_comp_vld_1);
    bv.set_bits(1, 1, range_comp_vld_0);
    bv.set_bits(0, 0, use_cache);
    return bv;
}


void npl_flc_header_types_array_data_t::unpack(bit_vector64_t bv) 
{
    range_comp_sel_3.unpack(bv.bits(24, 20));
    range_comp_sel_2.unpack(bv.bits(19, 15));
    range_comp_sel_1.unpack(bv.bits(14, 10));
    range_comp_sel_0.unpack(bv.bits(9, 5));
    range_comp_vld_3 = bv.bits(4, 4).get_value();
    range_comp_vld_2 = bv.bits(3, 3).get_value();
    range_comp_vld_1 = bv.bits(2, 2).get_value();
    range_comp_vld_0 = bv.bits(1, 1).get_value();
    use_cache = bv.bits(0, 0).get_value();
}



field_structure npl_flc_header_types_array_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_header_types_array_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("range_comp_sel_3", range_comp_sel_3.to_field_structure());
    fs_result.subfields.emplace_back("range_comp_sel_2", range_comp_sel_2.to_field_structure());
    fs_result.subfields.emplace_back("range_comp_sel_1", range_comp_sel_1.to_field_structure());
    fs_result.subfields.emplace_back("range_comp_sel_0", range_comp_sel_0.to_field_structure());
    fs_subfield.flat_value = to_hex_string(range_comp_vld_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_comp_vld_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(range_comp_vld_2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_comp_vld_2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(range_comp_vld_1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_comp_vld_1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(range_comp_vld_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("range_comp_vld_0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(use_cache);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("use_cache", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_flc_header_types_array_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_header_types_array_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_force_pipe_ttl_ingress_ptp_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 1, ingress_ptp_info.pack());
    bv.set_bits(0, 0, force_pipe_ttl);
    return bv;
}


void npl_force_pipe_ttl_ingress_ptp_info_t::unpack(bit_vector64_t bv) 
{
    ingress_ptp_info.unpack(bv.bits(3, 1));
    force_pipe_ttl = bv.bits(0, 0).get_value();
}



field_structure npl_force_pipe_ttl_ingress_ptp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_force_pipe_ttl_ingress_ptp_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ingress_ptp_info", ingress_ptp_info.to_field_structure());
    fs_subfield.flat_value = to_hex_string(force_pipe_ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("force_pipe_ttl", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_force_pipe_ttl_ingress_ptp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_force_pipe_ttl_ingress_ptp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_gb_std_ip_em_lpm_result_destination_with_default_t::pack(void) const 
{
    bit_vector128_t bv(0, 88);
    bv.set_bits(87, 4, destination_with_default.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_gb_std_ip_em_lpm_result_destination_with_default_t::unpack(bit_vector128_t bv) 
{
    destination_with_default.unpack(bv.bits(87, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_gb_std_ip_em_lpm_result_destination_with_default_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_gb_std_ip_em_lpm_result_destination_with_default_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("destination_with_default", destination_with_default.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_gb_std_ip_em_lpm_result_destination_with_default_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_gb_std_ip_em_lpm_result_destination_with_default_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_gre_tunnel_attributes_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 119, demux_count);
    bv.set_bits(118, 117, dip_entropy);
    bv.set_bits(116, 101, tunnel_qos_encap.pack());
    bv.set_bits(100, 97, tunnel_control.pack());
    bv.set_bits(96, 92, qos_info.pack());
    bv.set_bits(91, 72, p_counter.pack());
    bv.set_bits(71, 52, tunnel_type_q_counter.pack());
    bv.set_bits(51, 48, sip_index);
    bv.set_bits(47, 16, dip);
    bv.set_bits(15, 8, gre_flags);
    bv.set_bits(7, 0, ttl);
    return bv;
}


void npl_gre_tunnel_attributes_t::unpack(bit_vector128_t bv) 
{
    demux_count = bv.bits(119, 119).get_value();
    dip_entropy = (npl_gre_dip_entropy_e)bv.bits(118, 117).get_value();
    tunnel_qos_encap.unpack(bv.bits(116, 101));
    tunnel_control.unpack(bv.bits(100, 97));
    qos_info.unpack(bv.bits(96, 92));
    p_counter.unpack(bv.bits(91, 72));
    tunnel_type_q_counter.unpack(bv.bits(71, 52));
    sip_index = bv.bits(51, 48).get_value();
    dip = bv.bits(47, 16).get_value();
    gre_flags = bv.bits(15, 8).get_value();
    ttl = bv.bits(7, 0).get_value();
}



field_structure npl_gre_tunnel_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_gre_tunnel_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(demux_count);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("demux_count", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(dip_entropy);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dip_entropy", fs_subfield);
    
    fs_result.subfields.emplace_back("tunnel_qos_encap", tunnel_qos_encap.to_field_structure());
    fs_result.subfields.emplace_back("tunnel_control", tunnel_control.to_field_structure());
    fs_result.subfields.emplace_back("qos_info", qos_info.to_field_structure());
    fs_result.subfields.emplace_back("p_counter", p_counter.to_field_structure());
    fs_result.subfields.emplace_back("tunnel_type_q_counter", tunnel_type_q_counter.to_field_structure());
    fs_subfield.flat_value = to_hex_string(sip_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sip_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dip);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dip", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(gre_flags);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("gre_flags", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ttl);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_gre_tunnel_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_gre_tunnel_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_header_flags_t::pack(void) const // union
{
    bit_vector64_t bv(0, 3);
    if (all_header_flags != 0) {  // union primitive field start
        bv.set_bits(2, 0, all_header_flags);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv4_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv6_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vlan_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ethernet_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mpls_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(2, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_header_flags_t::unpack(bit_vector64_t bv) // union
{
    all_header_flags = bv.bits(2, 0).get_value();
}



field_structure npl_header_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_header_flags_t";
    field_structure fs_subfield;
    //add members to result
    if (all_header_flags != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(all_header_flags);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv4_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv4_header_flags", ipv4_header_flags.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ipv6_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ipv6_header_flags", ipv6_header_flags.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vlan_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("vlan_header_flags", vlan_header_flags.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ethernet_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ethernet_header_flags", ethernet_header_flags.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mpls_header_flags.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mpls_header_flags", mpls_header_flags.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_header_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_header_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_header_format_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 5, flags.pack());
    bv.set_bits(4, 0, type);
    return bv;
}


void npl_header_format_t::unpack(bit_vector64_t bv) 
{
    flags.unpack(bv.bits(7, 5));
    type = (npl_protocol_type_e)bv.bits(4, 0).get_value();
}



field_structure npl_header_format_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_header_format_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("flags", flags.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_header_format_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_header_format_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector npl_hmc_cgm_profile_global_results_t::pack(void) const 
{
    bit_vector bv(0, 540);
    bv.set_bits(539, 536, wred_ema_weight);
    bv.set_bits(535, 523, wred_fcn_probability_region[15].pack());
    bv.set_bits(522, 510, wred_fcn_probability_region[14].pack());
    bv.set_bits(509, 497, wred_fcn_probability_region[13].pack());
    bv.set_bits(496, 484, wred_fcn_probability_region[12].pack());
    bv.set_bits(483, 471, wred_fcn_probability_region[11].pack());
    bv.set_bits(470, 458, wred_fcn_probability_region[10].pack());
    bv.set_bits(457, 445, wred_fcn_probability_region[9].pack());
    bv.set_bits(444, 432, wred_fcn_probability_region[8].pack());
    bv.set_bits(431, 419, wred_fcn_probability_region[7].pack());
    bv.set_bits(418, 406, wred_fcn_probability_region[6].pack());
    bv.set_bits(405, 393, wred_fcn_probability_region[5].pack());
    bv.set_bits(392, 380, wred_fcn_probability_region[4].pack());
    bv.set_bits(379, 367, wred_fcn_probability_region[3].pack());
    bv.set_bits(366, 354, wred_fcn_probability_region[2].pack());
    bv.set_bits(353, 341, wred_fcn_probability_region[1].pack());
    bv.set_bits(340, 328, wred_fcn_probability_region[0].pack());
    bv.set_bits(327, 309, wred_region_borders[14].pack());
    bv.set_bits(308, 290, wred_region_borders[13].pack());
    bv.set_bits(289, 271, wred_region_borders[12].pack());
    bv.set_bits(270, 252, wred_region_borders[11].pack());
    bv.set_bits(251, 233, wred_region_borders[10].pack());
    bv.set_bits(232, 214, wred_region_borders[9].pack());
    bv.set_bits(213, 195, wred_region_borders[8].pack());
    bv.set_bits(194, 176, wred_region_borders[7].pack());
    bv.set_bits(175, 157, wred_region_borders[6].pack());
    bv.set_bits(156, 138, wred_region_borders[5].pack());
    bv.set_bits(137, 119, wred_region_borders[4].pack());
    bv.set_bits(118, 100, wred_region_borders[3].pack());
    bv.set_bits(99, 81, wred_region_borders[2].pack());
    bv.set_bits(80, 62, wred_region_borders[1].pack());
    bv.set_bits(61, 43, wred_region_borders[0].pack());
    bv.set_bits(42, 42, wred_fcn_enable);
    bv.set_bits(41, 37, alpha_dpo1.pack());
    bv.set_bits(36, 22, shared_resource_threshold_dp1.pack());
    bv.set_bits(21, 17, alpha_dpo0.pack());
    bv.set_bits(16, 2, shared_resource_threshold_dp0.pack());
    bv.set_bits(1, 1, shared_resource_threshold_mode);
    bv.set_bits(0, 0, shared_pool_id);
    return bv;
}


void npl_hmc_cgm_profile_global_results_t::unpack(bit_vector bv) 
{
    wred_ema_weight = bv.bits(539, 536).get_value();
    wred_fcn_probability_region[15].unpack(bv.bits(535, 523));
    wred_fcn_probability_region[14].unpack(bv.bits(522, 510));
    wred_fcn_probability_region[13].unpack(bv.bits(509, 497));
    wred_fcn_probability_region[12].unpack(bv.bits(496, 484));
    wred_fcn_probability_region[11].unpack(bv.bits(483, 471));
    wred_fcn_probability_region[10].unpack(bv.bits(470, 458));
    wred_fcn_probability_region[9].unpack(bv.bits(457, 445));
    wred_fcn_probability_region[8].unpack(bv.bits(444, 432));
    wred_fcn_probability_region[7].unpack(bv.bits(431, 419));
    wred_fcn_probability_region[6].unpack(bv.bits(418, 406));
    wred_fcn_probability_region[5].unpack(bv.bits(405, 393));
    wred_fcn_probability_region[4].unpack(bv.bits(392, 380));
    wred_fcn_probability_region[3].unpack(bv.bits(379, 367));
    wred_fcn_probability_region[2].unpack(bv.bits(366, 354));
    wred_fcn_probability_region[1].unpack(bv.bits(353, 341));
    wred_fcn_probability_region[0].unpack(bv.bits(340, 328));
    wred_region_borders[14].unpack(bv.bits(327, 309));
    wred_region_borders[13].unpack(bv.bits(308, 290));
    wred_region_borders[12].unpack(bv.bits(289, 271));
    wred_region_borders[11].unpack(bv.bits(270, 252));
    wred_region_borders[10].unpack(bv.bits(251, 233));
    wred_region_borders[9].unpack(bv.bits(232, 214));
    wred_region_borders[8].unpack(bv.bits(213, 195));
    wred_region_borders[7].unpack(bv.bits(194, 176));
    wred_region_borders[6].unpack(bv.bits(175, 157));
    wred_region_borders[5].unpack(bv.bits(156, 138));
    wred_region_borders[4].unpack(bv.bits(137, 119));
    wred_region_borders[3].unpack(bv.bits(118, 100));
    wred_region_borders[2].unpack(bv.bits(99, 81));
    wred_region_borders[1].unpack(bv.bits(80, 62));
    wred_region_borders[0].unpack(bv.bits(61, 43));
    wred_fcn_enable = bv.bits(42, 42).get_value();
    alpha_dpo1.unpack(bv.bits(41, 37));
    shared_resource_threshold_dp1.unpack(bv.bits(36, 22));
    alpha_dpo0.unpack(bv.bits(21, 17));
    shared_resource_threshold_dp0.unpack(bv.bits(16, 2));
    shared_resource_threshold_mode = bv.bits(1, 1).get_value();
    shared_pool_id = bv.bits(0, 0).get_value();
}



field_structure npl_hmc_cgm_profile_global_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_hmc_cgm_profile_global_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(wred_ema_weight);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("wred_ema_weight", fs_subfield);
    
    fs_result.subfields.emplace_back("wred_fcn_probability_region[15]", wred_fcn_probability_region[15].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[14]", wred_fcn_probability_region[14].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[13]", wred_fcn_probability_region[13].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[12]", wred_fcn_probability_region[12].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[11]", wred_fcn_probability_region[11].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[10]", wred_fcn_probability_region[10].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[9]", wred_fcn_probability_region[9].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[8]", wred_fcn_probability_region[8].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[7]", wred_fcn_probability_region[7].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[6]", wred_fcn_probability_region[6].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[5]", wred_fcn_probability_region[5].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[4]", wred_fcn_probability_region[4].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[3]", wred_fcn_probability_region[3].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[2]", wred_fcn_probability_region[2].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[1]", wred_fcn_probability_region[1].to_field_structure());
    fs_result.subfields.emplace_back("wred_fcn_probability_region[0]", wred_fcn_probability_region[0].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[14]", wred_region_borders[14].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[13]", wred_region_borders[13].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[12]", wred_region_borders[12].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[11]", wred_region_borders[11].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[10]", wred_region_borders[10].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[9]", wred_region_borders[9].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[8]", wred_region_borders[8].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[7]", wred_region_borders[7].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[6]", wred_region_borders[6].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[5]", wred_region_borders[5].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[4]", wred_region_borders[4].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[3]", wred_region_borders[3].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[2]", wred_region_borders[2].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[1]", wred_region_borders[1].to_field_structure());
    fs_result.subfields.emplace_back("wred_region_borders[0]", wred_region_borders[0].to_field_structure());
    fs_subfield.flat_value = to_hex_string(wred_fcn_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("wred_fcn_enable", fs_subfield);
    
    fs_result.subfields.emplace_back("alpha_dpo1", alpha_dpo1.to_field_structure());
    fs_result.subfields.emplace_back("shared_resource_threshold_dp1", shared_resource_threshold_dp1.to_field_structure());
    fs_result.subfields.emplace_back("alpha_dpo0", alpha_dpo0.to_field_structure());
    fs_result.subfields.emplace_back("shared_resource_threshold_dp0", shared_resource_threshold_dp0.to_field_structure());
    fs_subfield.flat_value = to_hex_string(shared_resource_threshold_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("shared_resource_threshold_mode", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(shared_pool_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("shared_pool_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_hmc_cgm_profile_global_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_hmc_cgm_profile_global_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ibm_cmd_table_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 49);
    bv.set_bits(48, 31, sampling_probability);
    bv.set_bits(30, 30, is_mc);
    bv.set_bits(29, 29, ignore_in_rxrq_sel);
    bv.set_bits(28, 28, mirror_to_dest);
    bv.set_bits(27, 25, tc_map_profile);
    bv.set_bits(24, 16, destination_device);
    bv.set_bits(15, 0, voq_or_bitmap.pack());
    return bv;
}


void npl_ibm_cmd_table_result_t::unpack(bit_vector64_t bv) 
{
    sampling_probability = bv.bits(48, 31).get_value();
    is_mc = bv.bits(30, 30).get_value();
    ignore_in_rxrq_sel = bv.bits(29, 29).get_value();
    mirror_to_dest = bv.bits(28, 28).get_value();
    tc_map_profile = bv.bits(27, 25).get_value();
    destination_device = bv.bits(24, 16).get_value();
    voq_or_bitmap.unpack(bv.bits(15, 0));
}



field_structure npl_ibm_cmd_table_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ibm_cmd_table_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sampling_probability);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sampling_probability", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ignore_in_rxrq_sel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ignore_in_rxrq_sel", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mirror_to_dest);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mirror_to_dest", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc_map_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc_map_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_device);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_device", fs_subfield);
    
    fs_result.subfields.emplace_back("voq_or_bitmap", voq_or_bitmap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ibm_cmd_table_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ibm_cmd_table_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_ptp_info_and_is_slp_dm_cmpressed_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 3, is_slp_dm);
    bv.set_bits(2, 0, ingress_ptp_info.pack());
    return bv;
}


void npl_ingress_ptp_info_and_is_slp_dm_cmpressed_fields_t::unpack(bit_vector64_t bv) 
{
    is_slp_dm = bv.bits(3, 3).get_value();
    ingress_ptp_info.unpack(bv.bits(2, 0));
}



field_structure npl_ingress_ptp_info_and_is_slp_dm_cmpressed_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_ptp_info_and_is_slp_dm_cmpressed_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(is_slp_dm);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_slp_dm", fs_subfield);
    
    fs_result.subfields.emplace_back("ingress_ptp_info", ingress_ptp_info.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ingress_ptp_info_and_is_slp_dm_cmpressed_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_ptp_info_and_is_slp_dm_cmpressed_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_remark_t::pack(void) const 
{
    bit_vector64_t bv(0, 21);
    bv.set_bits(20, 14, encap_qos_tag_u.pack());
    bv.set_bits(13, 7, qos_group);
    bv.set_bits(6, 0, fwd_qos_tag);
    return bv;
}


void npl_ingress_qos_remark_t::unpack(bit_vector64_t bv) 
{
    encap_qos_tag_u.unpack(bv.bits(20, 14));
    qos_group = bv.bits(13, 7).get_value();
    fwd_qos_tag = bv.bits(6, 0).get_value();
}



field_structure npl_ingress_qos_remark_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_remark_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("encap_qos_tag_u", encap_qos_tag_u.to_field_structure());
    fs_subfield.flat_value = to_hex_string(qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_group", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fwd_qos_tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_qos_tag", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_remark_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_remark_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_initial_pd_nw_rx_data_t_anonymous_union_mapping_key_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = initial_lp_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 4, tbv);
            return bv;
        }
    } // union compound field end
    
    if (mpls_label_placeholder != 0) {  // union primitive field start
        bv.set_bits(19, 0, mpls_label_placeholder);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_initial_pd_nw_rx_data_t_anonymous_union_mapping_key_t::unpack(bit_vector64_t bv) // union
{
    initial_lp_id.unpack(bv.bits(19, 4));
}



field_structure npl_initial_pd_nw_rx_data_t_anonymous_union_mapping_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_initial_pd_nw_rx_data_t_anonymous_union_mapping_key_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = initial_lp_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("initial_lp_id", initial_lp_id.to_field_structure());
        }
    } // union compound field end
    
    if (mpls_label_placeholder != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mpls_label_placeholder);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_initial_pd_nw_rx_data_t_anonymous_union_mapping_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_initial_pd_nw_rx_data_t_anonymous_union_mapping_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_initial_recycle_pd_nw_rx_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, init_data.pack());
    bv.set_bits(7, 4, initial_mapping_type);
    // PADDING -  bv.set_bits(3, 3, padding);
    bv.set_bits(2, 2, initial_is_rcy_if);
    // PADDING -  bv.set_bits(1, 1, padding);
    bv.set_bits(0, 0, initial_mac_lp_type);
    return bv;
}


void npl_initial_recycle_pd_nw_rx_data_t::unpack(bit_vector64_t bv) 
{
    init_data.unpack(bv.bits(15, 8));
    initial_mapping_type = (npl_mac_mapping_type_e)bv.bits(7, 4).get_value();
    // PADDING -  padding = bv.bits(3, 3).get_value();
    initial_is_rcy_if = bv.bits(2, 2).get_value();
    // PADDING -  padding = bv.bits(1, 1).get_value();
    initial_mac_lp_type = (npl_mac_lp_type_e)bv.bits(0, 0).get_value();
}



field_structure npl_initial_recycle_pd_nw_rx_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_initial_recycle_pd_nw_rx_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("init_data", init_data.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(initial_mapping_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_mapping_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(initial_is_rcy_if);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_is_rcy_if", fs_subfield);
    
    
    fs_subfield.flat_value = npl_enum_to_string(initial_mac_lp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_mac_lp_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_initial_recycle_pd_nw_rx_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_initial_recycle_pd_nw_rx_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_down_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 25, inject_down_encap_type);
    bv.set_bits(24, 20, inject_phb.pack());
    bv.set_bits(19, 0, inject_destination.pack());
    return bv;
}


void npl_inject_down_header_t::unpack(bit_vector64_t bv) 
{
    inject_down_encap_type = (npl_inject_down_encap_type_e)bv.bits(27, 25).get_value();
    inject_phb.unpack(bv.bits(24, 20));
    inject_destination.unpack(bv.bits(19, 0));
}



field_structure npl_inject_down_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_down_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(inject_down_encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_down_encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("inject_phb", inject_phb.to_field_structure());
    fs_result.subfields.emplace_back("inject_destination", inject_destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_down_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_down_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_ts_and_lm_cmd_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 12, time_stamp_cmd.pack());
    bv.set_bits(11, 0, counter_stamp_cmd.pack());
    return bv;
}


void npl_inject_ts_and_lm_cmd_t::unpack(bit_vector64_t bv) 
{
    time_stamp_cmd.unpack(bv.bits(23, 12));
    counter_stamp_cmd.unpack(bv.bits(11, 0));
}



field_structure npl_inject_ts_and_lm_cmd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_ts_and_lm_cmd_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("time_stamp_cmd", time_stamp_cmd.to_field_structure());
    fs_result.subfields.emplace_back("counter_stamp_cmd", counter_stamp_cmd.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_ts_and_lm_cmd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_ts_and_lm_cmd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_eth_qos_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    // PADDING -  bv.set_bits(23, 20, padding);
    bv.set_bits(19, 19, inject_up_hdr_phb_src);
    bv.set_bits(18, 14, inject_up_phb.pack());
    bv.set_bits(13, 7, inject_up_qos_group);
    bv.set_bits(6, 0, inject_up_fwd_qos_tag);
    return bv;
}


void npl_inject_up_eth_qos_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(23, 20).get_value();
    inject_up_hdr_phb_src = (npl_inject_up_hdr_phb_src_e)bv.bits(19, 19).get_value();
    inject_up_phb.unpack(bv.bits(18, 14));
    inject_up_qos_group = bv.bits(13, 7).get_value();
    inject_up_fwd_qos_tag = bv.bits(6, 0).get_value();
}



field_structure npl_inject_up_eth_qos_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_eth_qos_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = npl_enum_to_string(inject_up_hdr_phb_src);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_up_hdr_phb_src", fs_subfield);
    
    fs_result.subfields.emplace_back("inject_up_phb", inject_up_phb.to_field_structure());
    fs_subfield.flat_value = to_hex_string(inject_up_qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_up_qos_group", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(inject_up_fwd_qos_tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_up_fwd_qos_tag", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_up_eth_qos_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_eth_qos_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_encap_data_t_anonymous_union_upper_layer_t::pack(void) const // union
{
    bit_vector64_t bv(0, 40);
    { // union compound field start
        bit_vector64_t tbv = vxlan_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = gre_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 8, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = udp_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 8, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ip_encap_data_t_anonymous_union_upper_layer_t::unpack(bit_vector64_t bv) // union
{
    vxlan_data.unpack(bv.bits(39, 0));
}



field_structure npl_ip_encap_data_t_anonymous_union_upper_layer_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_encap_data_t_anonymous_union_upper_layer_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = vxlan_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("vxlan_data", vxlan_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = gre_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("gre_data", gre_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = udp_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("udp_data", udp_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ip_encap_data_t_anonymous_union_upper_layer_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_encap_data_t_anonymous_union_upper_layer_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_lpm_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 33);
    bv.set_bits(32, 25, class_id.pack());
    bv.set_bits(24, 5, destination_or_default.pack());
    // PADDING -  bv.set_bits(4, 4, padding);
    bv.set_bits(3, 2, rtype_or_is_fec.pack());
    bv.set_bits(1, 1, no_hbm_access);
    bv.set_bits(0, 0, is_default_unused);
    return bv;
}


void npl_ip_lpm_result_t::unpack(bit_vector64_t bv) 
{
    class_id.unpack(bv.bits(32, 25));
    destination_or_default.unpack(bv.bits(24, 5));
    // PADDING -  padding = bv.bits(4, 4).get_value();
    rtype_or_is_fec.unpack(bv.bits(3, 2));
    no_hbm_access = bv.bits(1, 1).get_value();
    is_default_unused = bv.bits(0, 0).get_value();
}



field_structure npl_ip_lpm_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_lpm_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("class_id", class_id.to_field_structure());
    fs_result.subfields.emplace_back("destination_or_default", destination_or_default.to_field_structure());
    
    fs_result.subfields.emplace_back("rtype_or_is_fec", rtype_or_is_fec.to_field_structure());
    fs_subfield.flat_value = to_hex_string(no_hbm_access);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_default_unused);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_default_unused", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_lpm_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_lpm_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_muxed_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 4, muxed_soft_lb_wa_enable.pack());
    bv.set_bits(3, 3, muxed_is_bfd_and_udp);
    bv.set_bits(2, 2, muxed_is_bfd);
    bv.set_bits(1, 1, muxed_is_hop_by_hop);
    bv.set_bits(0, 0, muxed_is_udp);
    return bv;
}


void npl_ip_muxed_fields_t::unpack(bit_vector64_t bv) 
{
    muxed_soft_lb_wa_enable.unpack(bv.bits(5, 4));
    muxed_is_bfd_and_udp = bv.bits(3, 3).get_value();
    muxed_is_bfd = bv.bits(2, 2).get_value();
    muxed_is_hop_by_hop = bv.bits(1, 1).get_value();
    muxed_is_udp = bv.bits(0, 0).get_value();
}



field_structure npl_ip_muxed_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_muxed_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("muxed_soft_lb_wa_enable", muxed_soft_lb_wa_enable.to_field_structure());
    fs_subfield.flat_value = to_hex_string(muxed_is_bfd_and_udp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("muxed_is_bfd_and_udp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(muxed_is_bfd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("muxed_is_bfd", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(muxed_is_hop_by_hop);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("muxed_is_hop_by_hop", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(muxed_is_udp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("muxed_is_udp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_muxed_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_muxed_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_rtf_iteration_properties_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 14, f0_rtf_prop.pack());
    bv.set_bits(13, 5, f1_rtf_prop.pack());
    bv.set_bits(4, 1, stop_on_step_and_next_stage_compressed_fields.pack());
    bv.set_bits(0, 0, use_fwd1_interface);
    return bv;
}


void npl_ip_rtf_iteration_properties_t::unpack(bit_vector64_t bv) 
{
    f0_rtf_prop.unpack(bv.bits(23, 14));
    f1_rtf_prop.unpack(bv.bits(13, 5));
    stop_on_step_and_next_stage_compressed_fields.unpack(bv.bits(4, 1));
    use_fwd1_interface = bv.bits(0, 0).get_value();
}



field_structure npl_ip_rtf_iteration_properties_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_rtf_iteration_properties_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("f0_rtf_prop", f0_rtf_prop.to_field_structure());
    fs_result.subfields.emplace_back("f1_rtf_prop", f1_rtf_prop.to_field_structure());
    fs_result.subfields.emplace_back("stop_on_step_and_next_stage_compressed_fields", stop_on_step_and_next_stage_compressed_fields.to_field_structure());
    fs_subfield.flat_value = to_hex_string(use_fwd1_interface);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("use_fwd1_interface", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_rtf_iteration_properties_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_rtf_iteration_properties_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_sgt_em_result_t_anonymous_union_result_t::pack(void) const // union
{
    bit_vector64_t bv(0, 62);
    { // union compound field start
        bit_vector64_t tbv = sgt_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ip_sgt_em_result_t_anonymous_union_result_t::unpack(bit_vector64_t bv) // union
{
    sgt_data.unpack(bv.bits(19, 0));
}



field_structure npl_ip_sgt_em_result_t_anonymous_union_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_sgt_em_result_t_anonymous_union_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = sgt_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("sgt_data", sgt_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ip_sgt_em_result_t_anonymous_union_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_sgt_em_result_t_anonymous_union_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_sgt_lpm_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 5, sgt_data.pack());
    // PADDING -  bv.set_bits(4, 4, padding);
    bv.set_bits(3, 2, rtype);
    bv.set_bits(1, 1, no_hbm_access);
    bv.set_bits(0, 0, is_default_unused);
    return bv;
}


void npl_ip_sgt_lpm_result_t::unpack(bit_vector64_t bv) 
{
    sgt_data.unpack(bv.bits(24, 5));
    // PADDING -  padding = bv.bits(4, 4).get_value();
    rtype = bv.bits(3, 2).get_value();
    no_hbm_access = bv.bits(1, 1).get_value();
    is_default_unused = bv.bits(0, 0).get_value();
}



field_structure npl_ip_sgt_lpm_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_sgt_lpm_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("sgt_data", sgt_data.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(rtype);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtype", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_default_unused);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_default_unused", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ip_sgt_lpm_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_sgt_lpm_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ipv4_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 64, ene_ttl_and_protocol.pack());
    bv.set_bits(63, 0, ene_ipv4_sip_dip.pack());
    return bv;
}


void npl_ipv4_encap_data_t::unpack(bit_vector128_t bv) 
{
    ene_ttl_and_protocol.unpack(bv.bits(79, 64));
    ene_ipv4_sip_dip.unpack(bv.bits(63, 0));
}



field_structure npl_ipv4_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ene_ttl_and_protocol", ene_ttl_and_protocol.to_field_structure());
    fs_result.subfields.emplace_back("ene_ipv4_sip_dip", ene_ipv4_sip_dip.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ipv4_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ipv4_ipv6_eth_init_rtf_stages_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 3, ipv4_ipv6_init_rtf_stage.pack());
    bv.set_bits(2, 0, eth_init_rtf_stage);
    return bv;
}


void npl_ipv4_ipv6_eth_init_rtf_stages_t::unpack(bit_vector64_t bv) 
{
    ipv4_ipv6_init_rtf_stage.unpack(bv.bits(6, 3));
    eth_init_rtf_stage = (npl_rtf_stage_and_type_e)bv.bits(2, 0).get_value();
}



field_structure npl_ipv4_ipv6_eth_init_rtf_stages_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv4_ipv6_eth_init_rtf_stages_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ipv4_ipv6_init_rtf_stage", ipv4_ipv6_init_rtf_stage.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(eth_init_rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_init_rtf_stage", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv4_ipv6_eth_init_rtf_stages_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv4_ipv6_eth_init_rtf_stages_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ipv6_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 64, ene_nh_and_hl.pack());
    bv.set_bits(63, 0, ene_ipv6_sip_msb);
    return bv;
}


void npl_ipv6_encap_data_t::unpack(bit_vector128_t bv) 
{
    ene_nh_and_hl.unpack(bv.bits(79, 64));
    ene_ipv6_sip_msb = bv.bits(63, 0).get_value();
}



field_structure npl_ipv6_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ipv6_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ene_nh_and_hl", ene_nh_and_hl.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ene_ipv6_sip_msb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_ipv6_sip_msb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ipv6_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ipv6_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ive_profile_and_data_t_anonymous_union_secondary_type_or_vid_2_t::pack(void) const // union
{
    bit_vector64_t bv(0, 12);
    { // union compound field start
        bit_vector64_t tbv = secondary_type_with_padding.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(11, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (vid2 != 0) {  // union primitive field start
        bv.set_bits(11, 0, vid2);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_ive_profile_and_data_t_anonymous_union_secondary_type_or_vid_2_t::unpack(bit_vector64_t bv) // union
{
    secondary_type_with_padding.unpack(bv.bits(11, 0));
}



field_structure npl_ive_profile_and_data_t_anonymous_union_secondary_type_or_vid_2_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ive_profile_and_data_t_anonymous_union_secondary_type_or_vid_2_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = secondary_type_with_padding.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("secondary_type_with_padding", secondary_type_with_padding.to_field_structure());
        }
    } // union compound field end
    
    if (vid2 != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(vid2);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_ive_profile_and_data_t_anonymous_union_secondary_type_or_vid_2_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ive_profile_and_data_t_anonymous_union_secondary_type_or_vid_2_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_ac_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, l2_dlp.pack());
    return bv;
}


void npl_l2_ac_encap_t::unpack(bit_vector64_t bv) 
{
    l2_dlp.unpack(bv.bits(19, 0));
}



field_structure npl_l2_ac_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_ac_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l2_dlp", l2_dlp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_ac_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_ac_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_dlp_attr_on_nh_t::pack(void) const 
{
    bit_vector64_t bv(0, 54);
    bv.set_bits(53, 52, nh_ene_macro_code);
    bv.set_bits(51, 50, l2_tpid_prof);
    // PADDING -  bv.set_bits(49, 46, padding);
    bv.set_bits(45, 0, l2_dlp_qos_and_attr.pack());
    return bv;
}


void npl_l2_dlp_attr_on_nh_t::unpack(bit_vector64_t bv) 
{
    nh_ene_macro_code = (npl_nh_ene_macro_code_e)bv.bits(53, 52).get_value();
    l2_tpid_prof = bv.bits(51, 50).get_value();
    // PADDING -  padding = bv.bits(49, 46).get_value();
    l2_dlp_qos_and_attr.unpack(bv.bits(45, 0));
}



field_structure npl_l2_dlp_attr_on_nh_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_dlp_attr_on_nh_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(nh_ene_macro_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh_ene_macro_code", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_tpid_prof);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_tpid_prof", fs_subfield);
    
    
    fs_result.subfields.emplace_back("l2_dlp_qos_and_attr", l2_dlp_qos_and_attr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_dlp_attr_on_nh_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_dlp_attr_on_nh_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_lp_with_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    // PADDING -  bv.set_bits(19, 18, padding);
    bv.set_bits(17, 0, l2_lp.pack());
    return bv;
}


void npl_l2_lp_with_padding_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(19, 18).get_value();
    l2_lp.unpack(bv.bits(17, 0));
}



field_structure npl_l2_lp_with_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lp_with_padding_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("l2_lp", l2_lp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_lp_with_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lp_with_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_lpts_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 31, lacp);
    bv.set_bits(30, 30, l2cp0);
    bv.set_bits(29, 29, l2cp1);
    bv.set_bits(28, 28, l2cp2);
    bv.set_bits(27, 27, l2cp3);
    bv.set_bits(26, 26, l2cp4);
    bv.set_bits(25, 25, l2cp5);
    bv.set_bits(24, 24, l2cp6);
    bv.set_bits(23, 23, l2cp7);
    bv.set_bits(22, 22, cisco_protocols);
    bv.set_bits(21, 21, isis_over_l2);
    bv.set_bits(20, 20, isis_drain);
    bv.set_bits(19, 19, isis_over_l3);
    bv.set_bits(18, 18, arp);
    bv.set_bits(17, 17, ptp_over_eth);
    bv.set_bits(16, 16, macsec);
    bv.set_bits(15, 15, dhcpv4_server);
    bv.set_bits(14, 14, dhcpv4_client);
    bv.set_bits(13, 13, dhcpv6_server);
    bv.set_bits(12, 12, dhcpv6_client);
    bv.set_bits(11, 0, rsvd.pack());
    return bv;
}


void npl_l2_lpts_payload_t::unpack(bit_vector64_t bv) 
{
    lacp = bv.bits(31, 31).get_value();
    l2cp0 = bv.bits(30, 30).get_value();
    l2cp1 = bv.bits(29, 29).get_value();
    l2cp2 = bv.bits(28, 28).get_value();
    l2cp3 = bv.bits(27, 27).get_value();
    l2cp4 = bv.bits(26, 26).get_value();
    l2cp5 = bv.bits(25, 25).get_value();
    l2cp6 = bv.bits(24, 24).get_value();
    l2cp7 = bv.bits(23, 23).get_value();
    cisco_protocols = bv.bits(22, 22).get_value();
    isis_over_l2 = bv.bits(21, 21).get_value();
    isis_drain = bv.bits(20, 20).get_value();
    isis_over_l3 = bv.bits(19, 19).get_value();
    arp = bv.bits(18, 18).get_value();
    ptp_over_eth = bv.bits(17, 17).get_value();
    macsec = bv.bits(16, 16).get_value();
    dhcpv4_server = bv.bits(15, 15).get_value();
    dhcpv4_client = bv.bits(14, 14).get_value();
    dhcpv6_server = bv.bits(13, 13).get_value();
    dhcpv6_client = bv.bits(12, 12).get_value();
    rsvd.unpack(bv.bits(11, 0));
}



field_structure npl_l2_lpts_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lpts_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lacp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lacp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp5);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp5", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2cp7);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2cp7", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cisco_protocols);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cisco_protocols", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(isis_over_l2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("isis_over_l2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(isis_drain);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("isis_drain", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(isis_over_l3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("isis_over_l3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(arp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("arp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ptp_over_eth);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ptp_over_eth", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(macsec);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("macsec", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv4_server);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv4_server", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv4_client);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv4_client", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv6_server);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv6_server", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dhcpv6_client);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dhcpv6_client", fs_subfield);
    
    fs_result.subfields.emplace_back("rsvd", rsvd.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_lpts_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lpts_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_mc_cud_narrow_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 20, l2_encapsulation_type);
    bv.set_bits(19, 0, l2_ac_encdap.pack());
    return bv;
}


void npl_l2_mc_cud_narrow_t::unpack(bit_vector64_t bv) 
{
    l2_encapsulation_type = (npl_npu_encap_l2_header_type_e)bv.bits(23, 20).get_value();
    l2_ac_encdap.unpack(bv.bits(19, 0));
}



field_structure npl_l2_mc_cud_narrow_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_mc_cud_narrow_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(l2_encapsulation_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_encapsulation_type", fs_subfield);
    
    fs_result.subfields.emplace_back("l2_ac_encdap", l2_ac_encdap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_mc_cud_narrow_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_mc_cud_narrow_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_rtf_conf_set_and_init_stages_t::pack(void) const 
{
    bit_vector64_t bv(0, 15);
    bv.set_bits(14, 3, rtf_conf_set_and_stages.pack());
    bv.set_bits(2, 0, eth_rtf_stage);
    return bv;
}


void npl_l2_rtf_conf_set_and_init_stages_t::unpack(bit_vector64_t bv) 
{
    rtf_conf_set_and_stages.unpack(bv.bits(14, 3));
    eth_rtf_stage = (npl_rtf_stage_and_type_e)bv.bits(2, 0).get_value();
}



field_structure npl_l2_rtf_conf_set_and_init_stages_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_rtf_conf_set_and_init_stages_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("rtf_conf_set_and_stages", rtf_conf_set_and_stages.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(eth_rtf_stage);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eth_rtf_stage", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_rtf_conf_set_and_init_stages_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_rtf_conf_set_and_init_stages_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_l3_dlp_encap_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    bv.set_bits(71, 68, sa_prefix_index);
    bv.set_bits(67, 24, vlan_and_sa_lsb_encap.pack());
    bv.set_bits(23, 0, vid2_or_flood_rcy_sm_vlans.pack());
    return bv;
}


void npl_l3_dlp_encap_t::unpack(bit_vector128_t bv) 
{
    sa_prefix_index = bv.bits(71, 68).get_value();
    vlan_and_sa_lsb_encap.unpack(bv.bits(67, 24));
    vid2_or_flood_rcy_sm_vlans.unpack(bv.bits(23, 0));
}



field_structure npl_l3_dlp_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sa_prefix_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_prefix_index", fs_subfield);
    
    fs_result.subfields.emplace_back("vlan_and_sa_lsb_encap", vlan_and_sa_lsb_encap.to_field_structure());
    fs_result.subfields.emplace_back("vid2_or_flood_rcy_sm_vlans", vid2_or_flood_rcy_sm_vlans.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_dlp_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_dlp_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 12, msbs.pack());
    bv.set_bits(11, 0, lsbs.pack());
    return bv;
}


void npl_l3_dlp_id_t::unpack(bit_vector64_t bv) 
{
    msbs.unpack(bv.bits(13, 12));
    lsbs.unpack(bv.bits(11, 0));
}



field_structure npl_l3_dlp_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("msbs", msbs.to_field_structure());
    fs_result.subfields.emplace_back("lsbs", lsbs.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_dlp_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_dlp_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 0, id.pack());
    return bv;
}


void npl_l3_dlp_t::unpack(bit_vector64_t bv) 
{
    id.unpack(bv.bits(13, 0));
}



field_structure npl_l3_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("id", id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_lp_additional_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 9, lp_profile);
    bv.set_bits(8, 7, load_balance_profile);
    bv.set_bits(6, 6, enable_monitor);
    bv.set_bits(5, 4, slp_based_fwd_and_per_vrf_mpls_fwd.pack());
    bv.set_bits(3, 0, qos_id);
    return bv;
}


void npl_l3_lp_additional_attributes_t::unpack(bit_vector64_t bv) 
{
    lp_profile = bv.bits(10, 9).get_value();
    load_balance_profile = (npl_lb_profile_enum_e)bv.bits(8, 7).get_value();
    enable_monitor = bv.bits(6, 6).get_value();
    slp_based_fwd_and_per_vrf_mpls_fwd.unpack(bv.bits(5, 4));
    qos_id = bv.bits(3, 0).get_value();
}



field_structure npl_l3_lp_additional_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_lp_additional_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lp_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_profile", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(load_balance_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("load_balance_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(enable_monitor);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_monitor", fs_subfield);
    
    fs_result.subfields.emplace_back("slp_based_fwd_and_per_vrf_mpls_fwd", slp_based_fwd_and_per_vrf_mpls_fwd.to_field_structure());
    fs_subfield.flat_value = to_hex_string(qos_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_lp_additional_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_lp_additional_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_sa_lsb_on_nh_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 32, sa_prefix_index);
    bv.set_bits(31, 0, tpid_sa_lsb.pack());
    return bv;
}


void npl_l3_sa_lsb_on_nh_t::unpack(bit_vector64_t bv) 
{
    sa_prefix_index = bv.bits(35, 32).get_value();
    tpid_sa_lsb.unpack(bv.bits(31, 0));
}



field_structure npl_l3_sa_lsb_on_nh_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_sa_lsb_on_nh_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(sa_prefix_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("sa_prefix_index", fs_subfield);
    
    fs_result.subfields.emplace_back("tpid_sa_lsb", tpid_sa_lsb.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_sa_lsb_on_nh_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_sa_lsb_on_nh_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_slp_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 12, msbs.pack());
    bv.set_bits(11, 0, lsbs.pack());
    return bv;
}


void npl_l3_slp_id_t::unpack(bit_vector64_t bv) 
{
    msbs.unpack(bv.bits(13, 12));
    lsbs.unpack(bv.bits(11, 0));
}



field_structure npl_l3_slp_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_slp_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("msbs", msbs.to_field_structure());
    fs_result.subfields.emplace_back("lsbs", lsbs.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_slp_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_slp_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_vxlan_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 12, tunnel_dlp.pack());
    // PADDING -  bv.set_bits(11, 10, padding);
    bv.set_bits(9, 0, overlay_nh);
    return bv;
}


void npl_l3_vxlan_encap_t::unpack(bit_vector64_t bv) 
{
    tunnel_dlp.unpack(bv.bits(31, 12));
    // PADDING -  padding = bv.bits(11, 10).get_value();
    overlay_nh = bv.bits(9, 0).get_value();
}



field_structure npl_l3_vxlan_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_vxlan_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("tunnel_dlp", tunnel_dlp.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(overlay_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("overlay_nh", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l3_vxlan_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_vxlan_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_l3_vxlan_relay_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 112);
    bv.set_bits(111, 44, overlay_nh_data.pack());
    bv.set_bits(43, 20, vni);
    bv.set_bits(19, 0, vni_counter.pack());
    return bv;
}


void npl_l3_vxlan_relay_encap_data_t::unpack(bit_vector128_t bv) 
{
    overlay_nh_data.unpack(bv.bits(111, 44));
    vni = bv.bits(43, 20).get_value();
    vni_counter.unpack(bv.bits(19, 0));
}



field_structure npl_l3_vxlan_relay_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_vxlan_relay_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("overlay_nh_data", overlay_nh_data.to_field_structure());
    fs_subfield.flat_value = to_hex_string(vni);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vni", fs_subfield);
    
    fs_result.subfields.emplace_back("vni_counter", vni_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_vxlan_relay_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_vxlan_relay_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_label_or_num_labels_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    if (label != 0) {  // union primitive field start
        bv.set_bits(19, 0, label);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = num_labels.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_label_or_num_labels_t::unpack(bit_vector64_t bv) // union
{
    label = bv.bits(19, 0).get_value();
}



field_structure npl_label_or_num_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_label_or_num_labels_t";
    field_structure fs_subfield;
    //add members to result
    if (label != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(label);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = num_labels.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("num_labels", num_labels.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_label_or_num_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_label_or_num_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ldp_over_te_tunnel_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    bv.set_bits(61, 60, num_labels);
    bv.set_bits(59, 20, lsp_labels.pack());
    bv.set_bits(19, 0, te_counter.pack());
    return bv;
}


void npl_ldp_over_te_tunnel_data_t::unpack(bit_vector64_t bv) 
{
    num_labels = bv.bits(61, 60).get_value();
    lsp_labels.unpack(bv.bits(59, 20));
    te_counter.unpack(bv.bits(19, 0));
}



field_structure npl_ldp_over_te_tunnel_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ldp_over_te_tunnel_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(num_labels);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("num_labels", fs_subfield);
    
    fs_result.subfields.emplace_back("lsp_labels", lsp_labels.to_field_structure());
    fs_result.subfields.emplace_back("te_counter", te_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ldp_over_te_tunnel_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ldp_over_te_tunnel_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_lpm_std_ip_em_lpm_result_destination_t::pack(void) const 
{
    bit_vector128_t bv(0, 124);
    bv.set_bits(123, 0, union_for_padding.pack());
    return bv;
}


void npl_lpm_std_ip_em_lpm_result_destination_t::unpack(bit_vector128_t bv) 
{
    union_for_padding.unpack(bv.bits(123, 0));
}



field_structure npl_lpm_std_ip_em_lpm_result_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpm_std_ip_em_lpm_result_destination_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("union_for_padding", union_for_padding.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lpm_std_ip_em_lpm_result_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpm_std_ip_em_lpm_result_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_object_groups_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, src_code.pack());
    bv.set_bits(15, 0, dest_code.pack());
    return bv;
}


void npl_lpts_object_groups_t::unpack(bit_vector64_t bv) 
{
    src_code.unpack(bv.bits(31, 16));
    dest_code.unpack(bv.bits(15, 0));
}



field_structure npl_lpts_object_groups_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_object_groups_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("src_code", src_code.to_field_structure());
    fs_result.subfields.emplace_back("dest_code", dest_code.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lpts_object_groups_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_object_groups_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 25);
    bv.set_bits(24, 20, phb.pack());
    bv.set_bits(19, 0, destination);
    return bv;
}


void npl_lpts_payload_t::unpack(bit_vector64_t bv) 
{
    phb.unpack(bv.bits(24, 20));
    destination = bv.bits(19, 0).get_value();
}



field_structure npl_lpts_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("phb", phb.to_field_structure());
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lpts_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 16, lsp_type.pack());
    bv.set_bits(15, 0, lsp_dest_prefix);
    return bv;
}


void npl_lsp_destination_t::unpack(bit_vector64_t bv) 
{
    lsp_type.unpack(bv.bits(19, 16));
    lsp_dest_prefix = bv.bits(15, 0).get_value();
}



field_structure npl_lsp_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_destination_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lsp_type", lsp_type.to_field_structure());
    fs_subfield.flat_value = to_hex_string(lsp_dest_prefix);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lsp_dest_prefix", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_lsp_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_encap_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 10);
    bv.set_bits(9, 8, service_flags.pack());
    bv.set_bits(7, 3, num_outer_transport_labels.pack());
    // PADDING -  bv.set_bits(2, 0, padding);
    return bv;
}


void npl_lsp_encap_fields_t::unpack(bit_vector64_t bv) 
{
    service_flags.unpack(bv.bits(9, 8));
    num_outer_transport_labels.unpack(bv.bits(7, 3));
    // PADDING -  padding = bv.bits(2, 0).get_value();
}



field_structure npl_lsp_encap_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_encap_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("service_flags", service_flags.to_field_structure());
    fs_result.subfields.emplace_back("num_outer_transport_labels", num_outer_transport_labels.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_lsp_encap_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_encap_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_labels_opt2_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 40, label_0);
    bv.set_bits(39, 0, labels_1_2.pack());
    return bv;
}


void npl_lsp_labels_opt2_t::unpack(bit_vector64_t bv) 
{
    label_0 = bv.bits(59, 40).get_value();
    labels_1_2.unpack(bv.bits(39, 0));
}



field_structure npl_lsp_labels_opt2_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_labels_opt2_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(label_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_0", fs_subfield);
    
    fs_result.subfields.emplace_back("labels_1_2", labels_1_2.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lsp_labels_opt2_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_labels_opt2_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsr_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 46);
    bv.set_bits(45, 26, lsp.pack());
    bv.set_bits(25, 10, backup_te_tunnel);
    bv.set_bits(9, 0, mldp_protection.pack());
    return bv;
}


void npl_lsr_encap_t::unpack(bit_vector64_t bv) 
{
    lsp.unpack(bv.bits(45, 26));
    backup_te_tunnel = bv.bits(25, 10).get_value();
    mldp_protection.unpack(bv.bits(9, 0));
}



field_structure npl_lsr_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsr_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lsp", lsp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(backup_te_tunnel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("backup_te_tunnel", fs_subfield);
    
    fs_result.subfields.emplace_back("mldp_protection", mldp_protection.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lsr_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsr_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_af_npp_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 49);
    bv.set_bits(48, 48, enable_sr_dm_accounting);
    bv.set_bits(47, 40, npp_attributes);
    bv.set_bits(39, 36, mapping_type);
    bv.set_bits(35, 20, port_vlan_tag.pack());
    bv.set_bits(19, 8, mac_relay_id);
    bv.set_bits(7, 7, enable_vlan_membership);
    bv.set_bits(6, 6, enable_vrf_for_l2);
    bv.set_bits(5, 1, vlan_membership_index);
    bv.set_bits(0, 0, enable_transparent_ptp);
    return bv;
}


void npl_mac_af_npp_attributes_t::unpack(bit_vector64_t bv) 
{
    enable_sr_dm_accounting = bv.bits(48, 48).get_value();
    npp_attributes = bv.bits(47, 40).get_value();
    mapping_type = (npl_mac_mapping_type_e)bv.bits(39, 36).get_value();
    port_vlan_tag.unpack(bv.bits(35, 20));
    mac_relay_id = bv.bits(19, 8).get_value();
    enable_vlan_membership = bv.bits(7, 7).get_value();
    enable_vrf_for_l2 = bv.bits(6, 6).get_value();
    vlan_membership_index = bv.bits(5, 1).get_value();
    enable_transparent_ptp = bv.bits(0, 0).get_value();
}



field_structure npl_mac_af_npp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_af_npp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable_sr_dm_accounting);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_sr_dm_accounting", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(npp_attributes);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("npp_attributes", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(mapping_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mapping_type", fs_subfield);
    
    fs_result.subfields.emplace_back("port_vlan_tag", port_vlan_tag.to_field_structure());
    fs_subfield.flat_value = to_hex_string(mac_relay_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_relay_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(enable_vlan_membership);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_vlan_membership", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(enable_vrf_for_l2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_vrf_for_l2", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vlan_membership_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vlan_membership_index", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(enable_transparent_ptp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_transparent_ptp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mac_af_npp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_af_npp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_forwarding_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    bv.set_bits(61, 48, relay_id.pack());
    bv.set_bits(47, 0, mac_address.pack());
    return bv;
}


void npl_mac_forwarding_key_t::unpack(bit_vector64_t bv) 
{
    relay_id.unpack(bv.bits(61, 48));
    mac_address.unpack(bv.bits(47, 0));
}



field_structure npl_mac_forwarding_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_forwarding_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("relay_id", relay_id.to_field_structure());
    fs_result.subfields.emplace_back("mac_address", mac_address.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_forwarding_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_forwarding_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_lp_attr_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 16, vlan_profile_and_lp_type.pack());
    bv.set_bits(15, 0, local_slp_id.pack());
    return bv;
}


void npl_mac_lp_attr_t::unpack(bit_vector64_t bv) 
{
    vlan_profile_and_lp_type.unpack(bv.bits(23, 16));
    local_slp_id.unpack(bv.bits(15, 0));
}



field_structure npl_mac_lp_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_lp_attr_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("vlan_profile_and_lp_type", vlan_profile_and_lp_type.to_field_structure());
    fs_result.subfields.emplace_back("local_slp_id", local_slp_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_lp_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_lp_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_attributes_inf_payload_t_anonymous_union_l2_relay_id_or_l3_attr_u_t::pack(void) const // union
{
    bit_vector64_t bv(0, 14);
    if (id != 0) {  // union primitive field start
        bv.set_bits(13, 0, id);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_lp_additional_attributes.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(10, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mac_relay_attributes_inf_payload_t_anonymous_union_l2_relay_id_or_l3_attr_u_t::unpack(bit_vector64_t bv) // union
{
    id = bv.bits(13, 0).get_value();
}



field_structure npl_mac_relay_attributes_inf_payload_t_anonymous_union_l2_relay_id_or_l3_attr_u_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_attributes_inf_payload_t_anonymous_union_l2_relay_id_or_l3_attr_u_t";
    field_structure fs_subfield;
    //add members to result
    if (id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(id);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_lp_additional_attributes.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_lp_additional_attributes", l3_lp_additional_attributes.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mac_relay_attributes_inf_payload_t_anonymous_union_l2_relay_id_or_l3_attr_u_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_attributes_inf_payload_t_anonymous_union_l2_relay_id_or_l3_attr_u_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_attributes_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 45);
    bv.set_bits(44, 34, l3_lp_additional_attributes.pack());
    bv.set_bits(33, 0, mac_l2_relay_attributes.pack());
    return bv;
}


void npl_mac_relay_attributes_payload_t::unpack(bit_vector64_t bv) 
{
    l3_lp_additional_attributes.unpack(bv.bits(44, 34));
    mac_l2_relay_attributes.unpack(bv.bits(33, 0));
}



field_structure npl_mac_relay_attributes_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_attributes_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_lp_additional_attributes", l3_lp_additional_attributes.to_field_structure());
    fs_result.subfields.emplace_back("mac_l2_relay_attributes", mac_l2_relay_attributes.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_relay_attributes_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_attributes_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mark_color_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 30, mark_color[15].pack());
    bv.set_bits(29, 28, mark_color[14].pack());
    bv.set_bits(27, 26, mark_color[13].pack());
    bv.set_bits(25, 24, mark_color[12].pack());
    bv.set_bits(23, 22, mark_color[11].pack());
    bv.set_bits(21, 20, mark_color[10].pack());
    bv.set_bits(19, 18, mark_color[9].pack());
    bv.set_bits(17, 16, mark_color[8].pack());
    bv.set_bits(15, 14, mark_color[7].pack());
    bv.set_bits(13, 12, mark_color[6].pack());
    bv.set_bits(11, 10, mark_color[5].pack());
    bv.set_bits(9, 8, mark_color[4].pack());
    bv.set_bits(7, 6, mark_color[3].pack());
    bv.set_bits(5, 4, mark_color[2].pack());
    bv.set_bits(3, 2, mark_color[1].pack());
    bv.set_bits(1, 0, mark_color[0].pack());
    return bv;
}


void npl_mark_color_t::unpack(bit_vector64_t bv) 
{
    mark_color[15].unpack(bv.bits(31, 30));
    mark_color[14].unpack(bv.bits(29, 28));
    mark_color[13].unpack(bv.bits(27, 26));
    mark_color[12].unpack(bv.bits(25, 24));
    mark_color[11].unpack(bv.bits(23, 22));
    mark_color[10].unpack(bv.bits(21, 20));
    mark_color[9].unpack(bv.bits(19, 18));
    mark_color[8].unpack(bv.bits(17, 16));
    mark_color[7].unpack(bv.bits(15, 14));
    mark_color[6].unpack(bv.bits(13, 12));
    mark_color[5].unpack(bv.bits(11, 10));
    mark_color[4].unpack(bv.bits(9, 8));
    mark_color[3].unpack(bv.bits(7, 6));
    mark_color[2].unpack(bv.bits(5, 4));
    mark_color[1].unpack(bv.bits(3, 2));
    mark_color[0].unpack(bv.bits(1, 0));
}



field_structure npl_mark_color_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mark_color_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mark_color[15]", mark_color[15].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[14]", mark_color[14].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[13]", mark_color[13].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[12]", mark_color[12].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[11]", mark_color[11].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[10]", mark_color[10].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[9]", mark_color[9].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[8]", mark_color[8].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[7]", mark_color[7].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[6]", mark_color[6].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[5]", mark_color[5].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[4]", mark_color[4].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[3]", mark_color[3].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[2]", mark_color[2].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[1]", mark_color[1].to_field_structure());
    fs_result.subfields.emplace_back("mark_color[0]", mark_color[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_mark_color_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mark_color_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_em_db_result_rx_single_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 34, tc_map_profile.pack());
    bv.set_bits(33, 18, base_voq_nr.pack());
    bv.set_bits(17, 0, mc_copy_id.pack());
    return bv;
}


void npl_mc_em_db_result_rx_single_t::unpack(bit_vector64_t bv) 
{
    tc_map_profile.unpack(bv.bits(35, 34));
    base_voq_nr.unpack(bv.bits(33, 18));
    mc_copy_id.unpack(bv.bits(17, 0));
}



field_structure npl_mc_em_db_result_rx_single_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_rx_single_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("tc_map_profile", tc_map_profile.to_field_structure());
    fs_result.subfields.emplace_back("base_voq_nr", base_voq_nr.to_field_structure());
    fs_result.subfields.emplace_back("mc_copy_id", mc_copy_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_rx_single_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_rx_single_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mc_em_db_result_rx_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    bv.set_bits(71, 36, result_1.pack());
    bv.set_bits(35, 0, result_0.pack());
    return bv;
}


void npl_mc_em_db_result_rx_t::unpack(bit_vector128_t bv) 
{
    result_1.unpack(bv.bits(71, 36));
    result_0.unpack(bv.bits(35, 0));
}



field_structure npl_mc_em_db_result_rx_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_rx_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("result_1", result_1.to_field_structure());
    fs_result.subfields.emplace_back("result_0", result_0.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_rx_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_rx_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_em_db_result_tx_format_0_t::pack(void) const 
{
    bit_vector64_t bv(0, 58);
    bv.set_bits(57, 55, tc_map_profile_1.pack());
    bv.set_bits(54, 52, tc_map_profile_0.pack());
    bv.set_bits(51, 44, oq_group_1.pack());
    bv.set_bits(43, 36, oq_group_0.pack());
    bv.set_bits(35, 18, mc_copy_id_1.pack());
    bv.set_bits(17, 0, mc_copy_id_0.pack());
    return bv;
}


void npl_mc_em_db_result_tx_format_0_t::unpack(bit_vector64_t bv) 
{
    tc_map_profile_1.unpack(bv.bits(57, 55));
    tc_map_profile_0.unpack(bv.bits(54, 52));
    oq_group_1.unpack(bv.bits(51, 44));
    oq_group_0.unpack(bv.bits(43, 36));
    mc_copy_id_1.unpack(bv.bits(35, 18));
    mc_copy_id_0.unpack(bv.bits(17, 0));
}



field_structure npl_mc_em_db_result_tx_format_0_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_tx_format_0_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("tc_map_profile_1", tc_map_profile_1.to_field_structure());
    fs_result.subfields.emplace_back("tc_map_profile_0", tc_map_profile_0.to_field_structure());
    fs_result.subfields.emplace_back("oq_group_1", oq_group_1.to_field_structure());
    fs_result.subfields.emplace_back("oq_group_0", oq_group_0.to_field_structure());
    fs_result.subfields.emplace_back("mc_copy_id_1", mc_copy_id_1.to_field_structure());
    fs_result.subfields.emplace_back("mc_copy_id_0", mc_copy_id_0.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_tx_format_0_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_tx_format_0_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mc_em_db_result_tx_t_anonymous_union_format_0_or_1_t::pack(void) const // union
{
    bit_vector128_t bv(0, 71);
    { // union compound field start
        bit_vector64_t tbv = format_0.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(57, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = format_1.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(70, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mc_em_db_result_tx_t_anonymous_union_format_0_or_1_t::unpack(bit_vector128_t bv) // union
{
    format_0.unpack(bv.bits(57, 0));
}



field_structure npl_mc_em_db_result_tx_t_anonymous_union_format_0_or_1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_tx_t_anonymous_union_format_0_or_1_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = format_0.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("format_0", format_0.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = format_1.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("format_1", format_1.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_tx_t_anonymous_union_format_0_or_1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_tx_t_anonymous_union_format_0_or_1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mc_slice_bitmap_table_entry_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 11, counterA_inc_enable);
    bv.set_bits(10, 0, group_size_or_bitmap.pack());
    return bv;
}


void npl_mc_slice_bitmap_table_entry_t::unpack(bit_vector64_t bv) 
{
    counterA_inc_enable = bv.bits(11, 11).get_value();
    group_size_or_bitmap.unpack(bv.bits(10, 0));
}



field_structure npl_mc_slice_bitmap_table_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_slice_bitmap_table_entry_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(counterA_inc_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counterA_inc_enable", fs_subfield);
    
    fs_result.subfields.emplace_back("group_size_or_bitmap", group_size_or_bitmap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mc_slice_bitmap_table_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_slice_bitmap_table_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mcid_array_t::pack(void) const 
{
    bit_vector128_t bv(0, 128);
    bv.set_bits(127, 112, mcid[7].pack());
    bv.set_bits(111, 96, mcid[6].pack());
    bv.set_bits(95, 80, mcid[5].pack());
    bv.set_bits(79, 64, mcid[4].pack());
    bv.set_bits(63, 48, mcid[3].pack());
    bv.set_bits(47, 32, mcid[2].pack());
    bv.set_bits(31, 16, mcid[1].pack());
    bv.set_bits(15, 0, mcid[0].pack());
    return bv;
}


void npl_mcid_array_t::unpack(bit_vector128_t bv) 
{
    mcid[7].unpack(bv.bits(127, 112));
    mcid[6].unpack(bv.bits(111, 96));
    mcid[5].unpack(bv.bits(95, 80));
    mcid[4].unpack(bv.bits(79, 64));
    mcid[3].unpack(bv.bits(63, 48));
    mcid[2].unpack(bv.bits(47, 32));
    mcid[1].unpack(bv.bits(31, 16));
    mcid[0].unpack(bv.bits(15, 0));
}



field_structure npl_mcid_array_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mcid_array_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mcid[7]", mcid[7].to_field_structure());
    fs_result.subfields.emplace_back("mcid[6]", mcid[6].to_field_structure());
    fs_result.subfields.emplace_back("mcid[5]", mcid[5].to_field_structure());
    fs_result.subfields.emplace_back("mcid[4]", mcid[4].to_field_structure());
    fs_result.subfields.emplace_back("mcid[3]", mcid[3].to_field_structure());
    fs_result.subfields.emplace_back("mcid[2]", mcid[2].to_field_structure());
    fs_result.subfields.emplace_back("mcid[1]", mcid[1].to_field_structure());
    fs_result.subfields.emplace_back("mcid[0]", mcid[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_mcid_array_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mcid_array_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mcid_array_wrapper_t::pack(void) const 
{
    bit_vector192_t bv(0, 144);
    bv.set_bits(143, 16, payload.pack());
    bv.set_bits(15, 0, key);
    return bv;
}


void npl_mcid_array_wrapper_t::unpack(bit_vector192_t bv) 
{
    payload.unpack(bv.bits(143, 16));
    key = bv.bits(15, 0).get_value();
}



field_structure npl_mcid_array_wrapper_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mcid_array_wrapper_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("payload", payload.to_field_structure());
    fs_subfield.flat_value = to_hex_string(key);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("key", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mcid_array_wrapper_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mcid_array_wrapper_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mmm_tm_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 16, base.pack());
    bv.set_bits(15, 0, multicast_id);
    return bv;
}


void npl_mmm_tm_header_t::unpack(bit_vector64_t bv) 
{
    base.unpack(bv.bits(23, 16));
    multicast_id = bv.bits(15, 0).get_value();
}



field_structure npl_mmm_tm_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mmm_tm_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("base", base.to_field_structure());
    fs_subfield.flat_value = to_hex_string(multicast_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("multicast_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mmm_tm_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mmm_tm_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_more_labels_and_flags_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 8, more_labels.pack());
    bv.set_bits(7, 7, enable_sr_dm_accounting);
    bv.set_bits(6, 6, multi_counter_enable);
    bv.set_bits(5, 4, service_flags.pack());
    bv.set_bits(3, 0, total_num_labels);
    return bv;
}


void npl_more_labels_and_flags_t::unpack(bit_vector64_t bv) 
{
    more_labels.unpack(bv.bits(19, 8));
    enable_sr_dm_accounting = bv.bits(7, 7).get_value();
    multi_counter_enable = bv.bits(6, 6).get_value();
    service_flags.unpack(bv.bits(5, 4));
    total_num_labels = bv.bits(3, 0).get_value();
}



field_structure npl_more_labels_and_flags_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_more_labels_and_flags_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("more_labels", more_labels.to_field_structure());
    fs_subfield.flat_value = to_hex_string(enable_sr_dm_accounting);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_sr_dm_accounting", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(multi_counter_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("multi_counter_enable", fs_subfield);
    
    fs_result.subfields.emplace_back("service_flags", service_flags.to_field_structure());
    fs_subfield.flat_value = to_hex_string(total_num_labels);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("total_num_labels", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_more_labels_and_flags_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_more_labels_and_flags_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_l3vpn_uc_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 14, padding);
    bv.set_bits(13, 12, allow_ipv4_ipv6_fwd_bits.pack());
    // PADDING -  bv.set_bits(11, 0, padding);
    return bv;
}


void npl_mpls_termination_l3vpn_uc_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 14).get_value();
    allow_ipv4_ipv6_fwd_bits.unpack(bv.bits(13, 12));
    // PADDING -  padding = bv.bits(11, 0).get_value();
}



field_structure npl_mpls_termination_l3vpn_uc_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_l3vpn_uc_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("allow_ipv4_ipv6_fwd_bits", allow_ipv4_ipv6_fwd_bits.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_mpls_termination_l3vpn_uc_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_l3vpn_uc_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_pwe_t::pack(void) const 
{
    bit_vector64_t bv(0, 47);
    // PADDING -  bv.set_bits(46, 46, padding);
    bv.set_bits(45, 45, is_pwe_raw);
    bv.set_bits(44, 44, enable_mpls_tp_oam);
    bv.set_bits(43, 43, fat_exists);
    bv.set_bits(42, 42, cw_exists);
    bv.set_bits(41, 38, bfd_channel);
    bv.set_bits(37, 24, l2_relay_id.pack());
    bv.set_bits(23, 0, mac_lp_attr.pack());
    return bv;
}


void npl_mpls_termination_pwe_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(46, 46).get_value();
    is_pwe_raw = bv.bits(45, 45).get_value();
    enable_mpls_tp_oam = bv.bits(44, 44).get_value();
    fat_exists = bv.bits(43, 43).get_value();
    cw_exists = bv.bits(42, 42).get_value();
    bfd_channel = (npl_bfd_channel_e)bv.bits(41, 38).get_value();
    l2_relay_id.unpack(bv.bits(37, 24));
    mac_lp_attr.unpack(bv.bits(23, 0));
}



field_structure npl_mpls_termination_pwe_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_pwe_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(is_pwe_raw);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_pwe_raw", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(enable_mpls_tp_oam);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_mpls_tp_oam", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fat_exists);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fat_exists", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(cw_exists);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("cw_exists", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(bfd_channel);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("bfd_channel", fs_subfield);
    
    fs_result.subfields.emplace_back("l2_relay_id", l2_relay_id.to_field_structure());
    fs_result.subfields.emplace_back("mac_lp_attr", mac_lp_attr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mpls_termination_pwe_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_pwe_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mum_tm_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 32, base.pack());
    bv.set_bits(31, 29, reserved);
    bv.set_bits(28, 20, destination_device);
    bv.set_bits(19, 17, destination_slice);
    bv.set_bits(16, 16, destination_txrq);
    bv.set_bits(15, 0, multicast_id);
    return bv;
}


void npl_mum_tm_header_t::unpack(bit_vector64_t bv) 
{
    base.unpack(bv.bits(39, 32));
    reserved = bv.bits(31, 29).get_value();
    destination_device = bv.bits(28, 20).get_value();
    destination_slice = bv.bits(19, 17).get_value();
    destination_txrq = bv.bits(16, 16).get_value();
    multicast_id = bv.bits(15, 0).get_value();
}



field_structure npl_mum_tm_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mum_tm_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("base", base.to_field_structure());
    fs_subfield.flat_value = to_hex_string(reserved);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reserved", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_device);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_device", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_slice);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_slice", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination_txrq);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination_txrq", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(multicast_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("multicast_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mum_tm_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mum_tm_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_my_ipv4_table_payload_t_anonymous_union_ip_tunnel_termination_attr_or_slp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    { // union compound field start
        bit_vector64_t tbv = sip_ip_tunnel_termination_attr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = tunnel_slp_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_my_ipv4_table_payload_t_anonymous_union_ip_tunnel_termination_attr_or_slp_t::unpack(bit_vector64_t bv) // union
{
    sip_ip_tunnel_termination_attr.unpack(bv.bits(15, 0));
}



field_structure npl_my_ipv4_table_payload_t_anonymous_union_ip_tunnel_termination_attr_or_slp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_my_ipv4_table_payload_t_anonymous_union_ip_tunnel_termination_attr_or_slp_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = sip_ip_tunnel_termination_attr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("sip_ip_tunnel_termination_attr", sip_ip_tunnel_termination_attr.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = tunnel_slp_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("tunnel_slp_id", tunnel_slp_id.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_my_ipv4_table_payload_t_anonymous_union_ip_tunnel_termination_attr_or_slp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_my_ipv4_table_payload_t_anonymous_union_ip_tunnel_termination_attr_or_slp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_nh_payload_t_anonymous_union_l3_sa_vlan_or_l2_dlp_attr_t::pack(void) const // union
{
    bit_vector64_t bv(0, 54);
    { // union compound field start
        bit_vector64_t tbv = l2_dlp_attr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(53, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_sa_lsb.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_nh_payload_t_anonymous_union_l3_sa_vlan_or_l2_dlp_attr_t::unpack(bit_vector64_t bv) // union
{
    l2_dlp_attr.unpack(bv.bits(53, 0));
}



field_structure npl_nh_payload_t_anonymous_union_l3_sa_vlan_or_l2_dlp_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_nh_payload_t_anonymous_union_l3_sa_vlan_or_l2_dlp_attr_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_dlp_attr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_dlp_attr", l2_dlp_attr.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_sa_lsb.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_sa_lsb", l3_sa_lsb.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_nh_payload_t_anonymous_union_l3_sa_vlan_or_l2_dlp_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_nh_payload_t_anonymous_union_l3_sa_vlan_or_l2_dlp_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_base_header_leaba_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 12, rx_nw_app_or_lb_key.pack());
    bv.set_bits(11, 8, slp_qos_id);
    bv.set_bits(7, 7, issu_codespace);
    bv.set_bits(6, 0, fwd_offset);
    return bv;
}


void npl_npu_base_header_leaba_t::unpack(bit_vector64_t bv) 
{
    rx_nw_app_or_lb_key.unpack(bv.bits(27, 12));
    slp_qos_id = bv.bits(11, 8).get_value();
    issu_codespace = bv.bits(7, 7).get_value();
    fwd_offset = bv.bits(6, 0).get_value();
}



field_structure npl_npu_base_header_leaba_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_base_header_leaba_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("rx_nw_app_or_lb_key", rx_nw_app_or_lb_key.to_field_structure());
    fs_subfield.flat_value = to_hex_string(slp_qos_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slp_qos_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(issu_codespace);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("issu_codespace", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fwd_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npu_base_header_leaba_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_base_header_leaba_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_base_leaba_dont_overwrite_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 60, base_type);
    bv.set_bits(59, 28, receive_time);
    bv.set_bits(27, 26, meter_color);
    bv.set_bits(25, 25, l2_flood_mc_pruning);
    bv.set_bits(24, 4, ingress_qos_remark.pack());
    bv.set_bits(3, 0, fwd_header_type);
    return bv;
}


void npl_npu_base_leaba_dont_overwrite_t::unpack(bit_vector64_t bv) 
{
    base_type = bv.bits(63, 60).get_value();
    receive_time = bv.bits(59, 28).get_value();
    meter_color = bv.bits(27, 26).get_value();
    l2_flood_mc_pruning = bv.bits(25, 25).get_value();
    ingress_qos_remark.unpack(bv.bits(24, 4));
    fwd_header_type = (npl_fwd_header_type_e)bv.bits(3, 0).get_value();
}



field_structure npl_npu_base_leaba_dont_overwrite_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_base_leaba_dont_overwrite_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(base_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("base_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(receive_time);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("receive_time", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(meter_color);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter_color", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_flood_mc_pruning);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_flood_mc_pruning", fs_subfield);
    
    fs_result.subfields.emplace_back("ingress_qos_remark", ingress_qos_remark.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(fwd_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_header_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npu_base_leaba_dont_overwrite_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_base_leaba_dont_overwrite_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_dsp_pif_ifg_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 1, padded_pif_ifg.pack());
    bv.set_bits(0, 0, use_npu_header_pif_ifg);
    return bv;
}


void npl_npu_dsp_pif_ifg_t::unpack(bit_vector64_t bv) 
{
    padded_pif_ifg.unpack(bv.bits(7, 1));
    use_npu_header_pif_ifg = bv.bits(0, 0).get_value();
}



field_structure npl_npu_dsp_pif_ifg_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_dsp_pif_ifg_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("padded_pif_ifg", padded_pif_ifg.to_field_structure());
    fs_subfield.flat_value = to_hex_string(use_npu_header_pif_ifg);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("use_npu_header_pif_ifg", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npu_dsp_pif_ifg_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_dsp_pif_ifg_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_object_groups_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 24, src_code.pack());
    bv.set_bits(23, 0, dest_code.pack());
    return bv;
}


void npl_object_groups_t::unpack(bit_vector64_t bv) 
{
    src_code.unpack(bv.bits(47, 24));
    dest_code.unpack(bv.bits(23, 0));
}



field_structure npl_object_groups_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_object_groups_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("src_code", src_code.to_field_structure());
    fs_result.subfields.emplace_back("dest_code", dest_code.to_field_structure());
    return fs_result;
}
std::string to_string(npl_object_groups_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_object_groups_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_lpm_code_or_destination_t::pack(void) const // union
{
    bit_vector64_t bv(0, 25);
    { // union compound field start
        bit_vector64_t tbv = lpm_code.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(24, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lpts_code.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_og_lpm_code_or_destination_t::unpack(bit_vector64_t bv) // union
{
    lpm_code.unpack(bv.bits(24, 0));
}



field_structure npl_og_lpm_code_or_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_lpm_code_or_destination_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = lpm_code.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lpm_code", lpm_code.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lpts_code.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lpts_code", lpts_code.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = destination.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("destination", destination.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_og_lpm_code_or_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_lpm_code_or_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_lpm_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 30);
    bv.set_bits(29, 5, lpm_code_or_dest.pack());
    // PADDING -  bv.set_bits(4, 4, padding);
    bv.set_bits(3, 2, rtype);
    bv.set_bits(1, 1, no_hbm_access);
    bv.set_bits(0, 0, is_default_unused);
    return bv;
}


void npl_og_lpm_result_t::unpack(bit_vector64_t bv) 
{
    lpm_code_or_dest.unpack(bv.bits(29, 5));
    // PADDING -  padding = bv.bits(4, 4).get_value();
    rtype = bv.bits(3, 2).get_value();
    no_hbm_access = bv.bits(1, 1).get_value();
    is_default_unused = bv.bits(0, 0).get_value();
}



field_structure npl_og_lpm_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_lpm_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lpm_code_or_dest", lpm_code_or_dest.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(rtype);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtype", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(is_default_unused);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_default_unused", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_og_lpm_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_lpm_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_pcl_config_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 8, compress);
    bv.set_bits(7, 0, pcl_id.pack());
    return bv;
}


void npl_og_pcl_config_t::unpack(bit_vector64_t bv) 
{
    compress = bv.bits(8, 8).get_value();
    pcl_id.unpack(bv.bits(7, 0));
}



field_structure npl_og_pcl_config_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_pcl_config_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(compress);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("compress", fs_subfield);
    
    fs_result.subfields.emplace_back("pcl_id", pcl_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_og_pcl_config_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_pcl_config_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_output_learn_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 34);
    bv.set_bits(33, 14, slp);
    bv.set_bits(13, 0, relay_id.pack());
    return bv;
}


void npl_output_learn_info_t::unpack(bit_vector64_t bv) 
{
    slp = bv.bits(33, 14).get_value();
    relay_id.unpack(bv.bits(13, 0));
}



field_structure npl_output_learn_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_output_learn_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(slp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slp", fs_subfield);
    
    fs_result.subfields.emplace_back("relay_id", relay_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_output_learn_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_output_learn_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_output_learn_record_t::pack(void) const 
{
    bit_vector128_t bv(0, 88);
    bv.set_bits(87, 86, result);
    bv.set_bits(85, 52, learn_info.pack());
    bv.set_bits(51, 4, ethernet_address);
    bv.set_bits(3, 0, mact_ldb);
    return bv;
}


void npl_output_learn_record_t::unpack(bit_vector128_t bv) 
{
    result = (npl_learn_record_result_e)bv.bits(87, 86).get_value();
    learn_info.unpack(bv.bits(85, 52));
    ethernet_address = bv.bits(51, 4).get_value();
    mact_ldb = bv.bits(3, 0).get_value();
}



field_structure npl_output_learn_record_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_output_learn_record_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(result);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("result", fs_subfield);
    
    fs_result.subfields.emplace_back("learn_info", learn_info.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ethernet_address);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ethernet_address", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mact_ldb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mact_ldb", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_output_learn_record_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_output_learn_record_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_overload_union_dlp_profile_union_t_user_app_data_defined_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    { // union compound field start
        bit_vector64_t tbv = user_app_dlp_profile.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (user_app_data_defined != 0) {  // union primitive field start
        bv.set_bits(7, 0, user_app_data_defined);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_overload_union_dlp_profile_union_t_user_app_data_defined_t::unpack(bit_vector64_t bv) // union
{
    user_app_dlp_profile.unpack(bv.bits(7, 0));
}



field_structure npl_overload_union_dlp_profile_union_t_user_app_data_defined_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_overload_union_dlp_profile_union_t_user_app_data_defined_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = user_app_dlp_profile.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("user_app_dlp_profile", user_app_dlp_profile.to_field_structure());
        }
    } // union compound field end
    
    if (user_app_data_defined != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(user_app_data_defined);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_overload_union_dlp_profile_union_t_user_app_data_defined_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_overload_union_dlp_profile_union_t_user_app_data_defined_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pd_rx_nw_app_t_anonymous_union_init_recycle_fields_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    { // union compound field start
        bit_vector64_t tbv = init_recycle_fields.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_pd_rx_nw_app_t_anonymous_union_init_recycle_fields_union_t::unpack(bit_vector64_t bv) // union
{
    init_recycle_fields.unpack(bv.bits(15, 0));
}



field_structure npl_pd_rx_nw_app_t_anonymous_union_init_recycle_fields_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pd_rx_nw_app_t_anonymous_union_init_recycle_fields_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = init_recycle_fields.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("init_recycle_fields", init_recycle_fields.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_pd_rx_nw_app_t_anonymous_union_init_recycle_fields_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pd_rx_nw_app_t_anonymous_union_init_recycle_fields_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pdoq_oq_ifc_mapping_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 15);
    bv.set_bits(14, 13, fcn_profile);
    bv.set_bits(12, 5, txpp_map_data.pack());
    bv.set_bits(4, 0, dest_pif);
    return bv;
}


void npl_pdoq_oq_ifc_mapping_result_t::unpack(bit_vector64_t bv) 
{
    fcn_profile = bv.bits(14, 13).get_value();
    txpp_map_data.unpack(bv.bits(12, 5));
    dest_pif = bv.bits(4, 0).get_value();
}



field_structure npl_pdoq_oq_ifc_mapping_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pdoq_oq_ifc_mapping_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(fcn_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fcn_profile", fs_subfield);
    
    fs_result.subfields.emplace_back("txpp_map_data", txpp_map_data.to_field_structure());
    fs_subfield.flat_value = to_hex_string(dest_pif);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dest_pif", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pdoq_oq_ifc_mapping_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pdoq_oq_ifc_mapping_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_pdvoq_bank_pair_offset_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 108);
    bv.set_bits(107, 107, array[107].pack());
    bv.set_bits(106, 106, array[106].pack());
    bv.set_bits(105, 105, array[105].pack());
    bv.set_bits(104, 104, array[104].pack());
    bv.set_bits(103, 103, array[103].pack());
    bv.set_bits(102, 102, array[102].pack());
    bv.set_bits(101, 101, array[101].pack());
    bv.set_bits(100, 100, array[100].pack());
    bv.set_bits(99, 99, array[99].pack());
    bv.set_bits(98, 98, array[98].pack());
    bv.set_bits(97, 97, array[97].pack());
    bv.set_bits(96, 96, array[96].pack());
    bv.set_bits(95, 95, array[95].pack());
    bv.set_bits(94, 94, array[94].pack());
    bv.set_bits(93, 93, array[93].pack());
    bv.set_bits(92, 92, array[92].pack());
    bv.set_bits(91, 91, array[91].pack());
    bv.set_bits(90, 90, array[90].pack());
    bv.set_bits(89, 89, array[89].pack());
    bv.set_bits(88, 88, array[88].pack());
    bv.set_bits(87, 87, array[87].pack());
    bv.set_bits(86, 86, array[86].pack());
    bv.set_bits(85, 85, array[85].pack());
    bv.set_bits(84, 84, array[84].pack());
    bv.set_bits(83, 83, array[83].pack());
    bv.set_bits(82, 82, array[82].pack());
    bv.set_bits(81, 81, array[81].pack());
    bv.set_bits(80, 80, array[80].pack());
    bv.set_bits(79, 79, array[79].pack());
    bv.set_bits(78, 78, array[78].pack());
    bv.set_bits(77, 77, array[77].pack());
    bv.set_bits(76, 76, array[76].pack());
    bv.set_bits(75, 75, array[75].pack());
    bv.set_bits(74, 74, array[74].pack());
    bv.set_bits(73, 73, array[73].pack());
    bv.set_bits(72, 72, array[72].pack());
    bv.set_bits(71, 71, array[71].pack());
    bv.set_bits(70, 70, array[70].pack());
    bv.set_bits(69, 69, array[69].pack());
    bv.set_bits(68, 68, array[68].pack());
    bv.set_bits(67, 67, array[67].pack());
    bv.set_bits(66, 66, array[66].pack());
    bv.set_bits(65, 65, array[65].pack());
    bv.set_bits(64, 64, array[64].pack());
    bv.set_bits(63, 63, array[63].pack());
    bv.set_bits(62, 62, array[62].pack());
    bv.set_bits(61, 61, array[61].pack());
    bv.set_bits(60, 60, array[60].pack());
    bv.set_bits(59, 59, array[59].pack());
    bv.set_bits(58, 58, array[58].pack());
    bv.set_bits(57, 57, array[57].pack());
    bv.set_bits(56, 56, array[56].pack());
    bv.set_bits(55, 55, array[55].pack());
    bv.set_bits(54, 54, array[54].pack());
    bv.set_bits(53, 53, array[53].pack());
    bv.set_bits(52, 52, array[52].pack());
    bv.set_bits(51, 51, array[51].pack());
    bv.set_bits(50, 50, array[50].pack());
    bv.set_bits(49, 49, array[49].pack());
    bv.set_bits(48, 48, array[48].pack());
    bv.set_bits(47, 47, array[47].pack());
    bv.set_bits(46, 46, array[46].pack());
    bv.set_bits(45, 45, array[45].pack());
    bv.set_bits(44, 44, array[44].pack());
    bv.set_bits(43, 43, array[43].pack());
    bv.set_bits(42, 42, array[42].pack());
    bv.set_bits(41, 41, array[41].pack());
    bv.set_bits(40, 40, array[40].pack());
    bv.set_bits(39, 39, array[39].pack());
    bv.set_bits(38, 38, array[38].pack());
    bv.set_bits(37, 37, array[37].pack());
    bv.set_bits(36, 36, array[36].pack());
    bv.set_bits(35, 35, array[35].pack());
    bv.set_bits(34, 34, array[34].pack());
    bv.set_bits(33, 33, array[33].pack());
    bv.set_bits(32, 32, array[32].pack());
    bv.set_bits(31, 31, array[31].pack());
    bv.set_bits(30, 30, array[30].pack());
    bv.set_bits(29, 29, array[29].pack());
    bv.set_bits(28, 28, array[28].pack());
    bv.set_bits(27, 27, array[27].pack());
    bv.set_bits(26, 26, array[26].pack());
    bv.set_bits(25, 25, array[25].pack());
    bv.set_bits(24, 24, array[24].pack());
    bv.set_bits(23, 23, array[23].pack());
    bv.set_bits(22, 22, array[22].pack());
    bv.set_bits(21, 21, array[21].pack());
    bv.set_bits(20, 20, array[20].pack());
    bv.set_bits(19, 19, array[19].pack());
    bv.set_bits(18, 18, array[18].pack());
    bv.set_bits(17, 17, array[17].pack());
    bv.set_bits(16, 16, array[16].pack());
    bv.set_bits(15, 15, array[15].pack());
    bv.set_bits(14, 14, array[14].pack());
    bv.set_bits(13, 13, array[13].pack());
    bv.set_bits(12, 12, array[12].pack());
    bv.set_bits(11, 11, array[11].pack());
    bv.set_bits(10, 10, array[10].pack());
    bv.set_bits(9, 9, array[9].pack());
    bv.set_bits(8, 8, array[8].pack());
    bv.set_bits(7, 7, array[7].pack());
    bv.set_bits(6, 6, array[6].pack());
    bv.set_bits(5, 5, array[5].pack());
    bv.set_bits(4, 4, array[4].pack());
    bv.set_bits(3, 3, array[3].pack());
    bv.set_bits(2, 2, array[2].pack());
    bv.set_bits(1, 1, array[1].pack());
    bv.set_bits(0, 0, array[0].pack());
    return bv;
}


void npl_pdvoq_bank_pair_offset_result_t::unpack(bit_vector128_t bv) 
{
    array[107].unpack(bv.bits(107, 107));
    array[106].unpack(bv.bits(106, 106));
    array[105].unpack(bv.bits(105, 105));
    array[104].unpack(bv.bits(104, 104));
    array[103].unpack(bv.bits(103, 103));
    array[102].unpack(bv.bits(102, 102));
    array[101].unpack(bv.bits(101, 101));
    array[100].unpack(bv.bits(100, 100));
    array[99].unpack(bv.bits(99, 99));
    array[98].unpack(bv.bits(98, 98));
    array[97].unpack(bv.bits(97, 97));
    array[96].unpack(bv.bits(96, 96));
    array[95].unpack(bv.bits(95, 95));
    array[94].unpack(bv.bits(94, 94));
    array[93].unpack(bv.bits(93, 93));
    array[92].unpack(bv.bits(92, 92));
    array[91].unpack(bv.bits(91, 91));
    array[90].unpack(bv.bits(90, 90));
    array[89].unpack(bv.bits(89, 89));
    array[88].unpack(bv.bits(88, 88));
    array[87].unpack(bv.bits(87, 87));
    array[86].unpack(bv.bits(86, 86));
    array[85].unpack(bv.bits(85, 85));
    array[84].unpack(bv.bits(84, 84));
    array[83].unpack(bv.bits(83, 83));
    array[82].unpack(bv.bits(82, 82));
    array[81].unpack(bv.bits(81, 81));
    array[80].unpack(bv.bits(80, 80));
    array[79].unpack(bv.bits(79, 79));
    array[78].unpack(bv.bits(78, 78));
    array[77].unpack(bv.bits(77, 77));
    array[76].unpack(bv.bits(76, 76));
    array[75].unpack(bv.bits(75, 75));
    array[74].unpack(bv.bits(74, 74));
    array[73].unpack(bv.bits(73, 73));
    array[72].unpack(bv.bits(72, 72));
    array[71].unpack(bv.bits(71, 71));
    array[70].unpack(bv.bits(70, 70));
    array[69].unpack(bv.bits(69, 69));
    array[68].unpack(bv.bits(68, 68));
    array[67].unpack(bv.bits(67, 67));
    array[66].unpack(bv.bits(66, 66));
    array[65].unpack(bv.bits(65, 65));
    array[64].unpack(bv.bits(64, 64));
    array[63].unpack(bv.bits(63, 63));
    array[62].unpack(bv.bits(62, 62));
    array[61].unpack(bv.bits(61, 61));
    array[60].unpack(bv.bits(60, 60));
    array[59].unpack(bv.bits(59, 59));
    array[58].unpack(bv.bits(58, 58));
    array[57].unpack(bv.bits(57, 57));
    array[56].unpack(bv.bits(56, 56));
    array[55].unpack(bv.bits(55, 55));
    array[54].unpack(bv.bits(54, 54));
    array[53].unpack(bv.bits(53, 53));
    array[52].unpack(bv.bits(52, 52));
    array[51].unpack(bv.bits(51, 51));
    array[50].unpack(bv.bits(50, 50));
    array[49].unpack(bv.bits(49, 49));
    array[48].unpack(bv.bits(48, 48));
    array[47].unpack(bv.bits(47, 47));
    array[46].unpack(bv.bits(46, 46));
    array[45].unpack(bv.bits(45, 45));
    array[44].unpack(bv.bits(44, 44));
    array[43].unpack(bv.bits(43, 43));
    array[42].unpack(bv.bits(42, 42));
    array[41].unpack(bv.bits(41, 41));
    array[40].unpack(bv.bits(40, 40));
    array[39].unpack(bv.bits(39, 39));
    array[38].unpack(bv.bits(38, 38));
    array[37].unpack(bv.bits(37, 37));
    array[36].unpack(bv.bits(36, 36));
    array[35].unpack(bv.bits(35, 35));
    array[34].unpack(bv.bits(34, 34));
    array[33].unpack(bv.bits(33, 33));
    array[32].unpack(bv.bits(32, 32));
    array[31].unpack(bv.bits(31, 31));
    array[30].unpack(bv.bits(30, 30));
    array[29].unpack(bv.bits(29, 29));
    array[28].unpack(bv.bits(28, 28));
    array[27].unpack(bv.bits(27, 27));
    array[26].unpack(bv.bits(26, 26));
    array[25].unpack(bv.bits(25, 25));
    array[24].unpack(bv.bits(24, 24));
    array[23].unpack(bv.bits(23, 23));
    array[22].unpack(bv.bits(22, 22));
    array[21].unpack(bv.bits(21, 21));
    array[20].unpack(bv.bits(20, 20));
    array[19].unpack(bv.bits(19, 19));
    array[18].unpack(bv.bits(18, 18));
    array[17].unpack(bv.bits(17, 17));
    array[16].unpack(bv.bits(16, 16));
    array[15].unpack(bv.bits(15, 15));
    array[14].unpack(bv.bits(14, 14));
    array[13].unpack(bv.bits(13, 13));
    array[12].unpack(bv.bits(12, 12));
    array[11].unpack(bv.bits(11, 11));
    array[10].unpack(bv.bits(10, 10));
    array[9].unpack(bv.bits(9, 9));
    array[8].unpack(bv.bits(8, 8));
    array[7].unpack(bv.bits(7, 7));
    array[6].unpack(bv.bits(6, 6));
    array[5].unpack(bv.bits(5, 5));
    array[4].unpack(bv.bits(4, 4));
    array[3].unpack(bv.bits(3, 3));
    array[2].unpack(bv.bits(2, 2));
    array[1].unpack(bv.bits(1, 1));
    array[0].unpack(bv.bits(0, 0));
}



field_structure npl_pdvoq_bank_pair_offset_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pdvoq_bank_pair_offset_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("array[107]", array[107].to_field_structure());
    fs_result.subfields.emplace_back("array[106]", array[106].to_field_structure());
    fs_result.subfields.emplace_back("array[105]", array[105].to_field_structure());
    fs_result.subfields.emplace_back("array[104]", array[104].to_field_structure());
    fs_result.subfields.emplace_back("array[103]", array[103].to_field_structure());
    fs_result.subfields.emplace_back("array[102]", array[102].to_field_structure());
    fs_result.subfields.emplace_back("array[101]", array[101].to_field_structure());
    fs_result.subfields.emplace_back("array[100]", array[100].to_field_structure());
    fs_result.subfields.emplace_back("array[99]", array[99].to_field_structure());
    fs_result.subfields.emplace_back("array[98]", array[98].to_field_structure());
    fs_result.subfields.emplace_back("array[97]", array[97].to_field_structure());
    fs_result.subfields.emplace_back("array[96]", array[96].to_field_structure());
    fs_result.subfields.emplace_back("array[95]", array[95].to_field_structure());
    fs_result.subfields.emplace_back("array[94]", array[94].to_field_structure());
    fs_result.subfields.emplace_back("array[93]", array[93].to_field_structure());
    fs_result.subfields.emplace_back("array[92]", array[92].to_field_structure());
    fs_result.subfields.emplace_back("array[91]", array[91].to_field_structure());
    fs_result.subfields.emplace_back("array[90]", array[90].to_field_structure());
    fs_result.subfields.emplace_back("array[89]", array[89].to_field_structure());
    fs_result.subfields.emplace_back("array[88]", array[88].to_field_structure());
    fs_result.subfields.emplace_back("array[87]", array[87].to_field_structure());
    fs_result.subfields.emplace_back("array[86]", array[86].to_field_structure());
    fs_result.subfields.emplace_back("array[85]", array[85].to_field_structure());
    fs_result.subfields.emplace_back("array[84]", array[84].to_field_structure());
    fs_result.subfields.emplace_back("array[83]", array[83].to_field_structure());
    fs_result.subfields.emplace_back("array[82]", array[82].to_field_structure());
    fs_result.subfields.emplace_back("array[81]", array[81].to_field_structure());
    fs_result.subfields.emplace_back("array[80]", array[80].to_field_structure());
    fs_result.subfields.emplace_back("array[79]", array[79].to_field_structure());
    fs_result.subfields.emplace_back("array[78]", array[78].to_field_structure());
    fs_result.subfields.emplace_back("array[77]", array[77].to_field_structure());
    fs_result.subfields.emplace_back("array[76]", array[76].to_field_structure());
    fs_result.subfields.emplace_back("array[75]", array[75].to_field_structure());
    fs_result.subfields.emplace_back("array[74]", array[74].to_field_structure());
    fs_result.subfields.emplace_back("array[73]", array[73].to_field_structure());
    fs_result.subfields.emplace_back("array[72]", array[72].to_field_structure());
    fs_result.subfields.emplace_back("array[71]", array[71].to_field_structure());
    fs_result.subfields.emplace_back("array[70]", array[70].to_field_structure());
    fs_result.subfields.emplace_back("array[69]", array[69].to_field_structure());
    fs_result.subfields.emplace_back("array[68]", array[68].to_field_structure());
    fs_result.subfields.emplace_back("array[67]", array[67].to_field_structure());
    fs_result.subfields.emplace_back("array[66]", array[66].to_field_structure());
    fs_result.subfields.emplace_back("array[65]", array[65].to_field_structure());
    fs_result.subfields.emplace_back("array[64]", array[64].to_field_structure());
    fs_result.subfields.emplace_back("array[63]", array[63].to_field_structure());
    fs_result.subfields.emplace_back("array[62]", array[62].to_field_structure());
    fs_result.subfields.emplace_back("array[61]", array[61].to_field_structure());
    fs_result.subfields.emplace_back("array[60]", array[60].to_field_structure());
    fs_result.subfields.emplace_back("array[59]", array[59].to_field_structure());
    fs_result.subfields.emplace_back("array[58]", array[58].to_field_structure());
    fs_result.subfields.emplace_back("array[57]", array[57].to_field_structure());
    fs_result.subfields.emplace_back("array[56]", array[56].to_field_structure());
    fs_result.subfields.emplace_back("array[55]", array[55].to_field_structure());
    fs_result.subfields.emplace_back("array[54]", array[54].to_field_structure());
    fs_result.subfields.emplace_back("array[53]", array[53].to_field_structure());
    fs_result.subfields.emplace_back("array[52]", array[52].to_field_structure());
    fs_result.subfields.emplace_back("array[51]", array[51].to_field_structure());
    fs_result.subfields.emplace_back("array[50]", array[50].to_field_structure());
    fs_result.subfields.emplace_back("array[49]", array[49].to_field_structure());
    fs_result.subfields.emplace_back("array[48]", array[48].to_field_structure());
    fs_result.subfields.emplace_back("array[47]", array[47].to_field_structure());
    fs_result.subfields.emplace_back("array[46]", array[46].to_field_structure());
    fs_result.subfields.emplace_back("array[45]", array[45].to_field_structure());
    fs_result.subfields.emplace_back("array[44]", array[44].to_field_structure());
    fs_result.subfields.emplace_back("array[43]", array[43].to_field_structure());
    fs_result.subfields.emplace_back("array[42]", array[42].to_field_structure());
    fs_result.subfields.emplace_back("array[41]", array[41].to_field_structure());
    fs_result.subfields.emplace_back("array[40]", array[40].to_field_structure());
    fs_result.subfields.emplace_back("array[39]", array[39].to_field_structure());
    fs_result.subfields.emplace_back("array[38]", array[38].to_field_structure());
    fs_result.subfields.emplace_back("array[37]", array[37].to_field_structure());
    fs_result.subfields.emplace_back("array[36]", array[36].to_field_structure());
    fs_result.subfields.emplace_back("array[35]", array[35].to_field_structure());
    fs_result.subfields.emplace_back("array[34]", array[34].to_field_structure());
    fs_result.subfields.emplace_back("array[33]", array[33].to_field_structure());
    fs_result.subfields.emplace_back("array[32]", array[32].to_field_structure());
    fs_result.subfields.emplace_back("array[31]", array[31].to_field_structure());
    fs_result.subfields.emplace_back("array[30]", array[30].to_field_structure());
    fs_result.subfields.emplace_back("array[29]", array[29].to_field_structure());
    fs_result.subfields.emplace_back("array[28]", array[28].to_field_structure());
    fs_result.subfields.emplace_back("array[27]", array[27].to_field_structure());
    fs_result.subfields.emplace_back("array[26]", array[26].to_field_structure());
    fs_result.subfields.emplace_back("array[25]", array[25].to_field_structure());
    fs_result.subfields.emplace_back("array[24]", array[24].to_field_structure());
    fs_result.subfields.emplace_back("array[23]", array[23].to_field_structure());
    fs_result.subfields.emplace_back("array[22]", array[22].to_field_structure());
    fs_result.subfields.emplace_back("array[21]", array[21].to_field_structure());
    fs_result.subfields.emplace_back("array[20]", array[20].to_field_structure());
    fs_result.subfields.emplace_back("array[19]", array[19].to_field_structure());
    fs_result.subfields.emplace_back("array[18]", array[18].to_field_structure());
    fs_result.subfields.emplace_back("array[17]", array[17].to_field_structure());
    fs_result.subfields.emplace_back("array[16]", array[16].to_field_structure());
    fs_result.subfields.emplace_back("array[15]", array[15].to_field_structure());
    fs_result.subfields.emplace_back("array[14]", array[14].to_field_structure());
    fs_result.subfields.emplace_back("array[13]", array[13].to_field_structure());
    fs_result.subfields.emplace_back("array[12]", array[12].to_field_structure());
    fs_result.subfields.emplace_back("array[11]", array[11].to_field_structure());
    fs_result.subfields.emplace_back("array[10]", array[10].to_field_structure());
    fs_result.subfields.emplace_back("array[9]", array[9].to_field_structure());
    fs_result.subfields.emplace_back("array[8]", array[8].to_field_structure());
    fs_result.subfields.emplace_back("array[7]", array[7].to_field_structure());
    fs_result.subfields.emplace_back("array[6]", array[6].to_field_structure());
    fs_result.subfields.emplace_back("array[5]", array[5].to_field_structure());
    fs_result.subfields.emplace_back("array[4]", array[4].to_field_structure());
    fs_result.subfields.emplace_back("array[3]", array[3].to_field_structure());
    fs_result.subfields.emplace_back("array[2]", array[2].to_field_structure());
    fs_result.subfields.emplace_back("array[1]", array[1].to_field_structure());
    fs_result.subfields.emplace_back("array[0]", array[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_pdvoq_bank_pair_offset_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pdvoq_bank_pair_offset_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pdvoq_slice_dram_wred_lut_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 15, mark_y.pack());
    bv.set_bits(14, 10, mark_g.pack());
    bv.set_bits(9, 5, drop_y.pack());
    bv.set_bits(4, 0, drop_g.pack());
    return bv;
}


void npl_pdvoq_slice_dram_wred_lut_result_t::unpack(bit_vector64_t bv) 
{
    mark_y.unpack(bv.bits(19, 15));
    mark_g.unpack(bv.bits(14, 10));
    drop_y.unpack(bv.bits(9, 5));
    drop_g.unpack(bv.bits(4, 0));
}



field_structure npl_pdvoq_slice_dram_wred_lut_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pdvoq_slice_dram_wred_lut_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mark_y", mark_y.to_field_structure());
    fs_result.subfields.emplace_back("mark_g", mark_g.to_field_structure());
    fs_result.subfields.emplace_back("drop_y", drop_y.to_field_structure());
    fs_result.subfields.emplace_back("drop_g", drop_g.to_field_structure());
    return fs_result;
}
std::string to_string(npl_pdvoq_slice_dram_wred_lut_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pdvoq_slice_dram_wred_lut_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pdvoq_slice_voq_properties_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 5, type);
    bv.set_bits(4, 0, profile.pack());
    return bv;
}


void npl_pdvoq_slice_voq_properties_result_t::unpack(bit_vector64_t bv) 
{
    type = bv.bits(7, 5).get_value();
    profile.unpack(bv.bits(4, 0));
}



field_structure npl_pdvoq_slice_voq_properties_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pdvoq_slice_voq_properties_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_result.subfields.emplace_back("profile", profile.to_field_structure());
    return fs_result;
}
std::string to_string(npl_pdvoq_slice_voq_properties_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pdvoq_slice_voq_properties_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pfc_em_compound_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 44);
    bv.set_bits(43, 4, payload.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_pfc_em_compound_results_t::unpack(bit_vector64_t bv) 
{
    payload.unpack(bv.bits(43, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_pfc_em_compound_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_em_compound_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("payload", payload.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_pfc_em_compound_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_em_compound_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_post_fwd_params_t::pack(void) const 
{
    bit_vector64_t bv(0, 6);
    bv.set_bits(5, 4, use_metedata_table_per_packet_format.pack());
    bv.set_bits(3, 0, ip_ver_and_post_fwd_stage.pack());
    return bv;
}


void npl_post_fwd_params_t::unpack(bit_vector64_t bv) 
{
    use_metedata_table_per_packet_format.unpack(bv.bits(5, 4));
    ip_ver_and_post_fwd_stage.unpack(bv.bits(3, 0));
}



field_structure npl_post_fwd_params_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_post_fwd_params_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("use_metedata_table_per_packet_format", use_metedata_table_per_packet_format.to_field_structure());
    fs_result.subfields.emplace_back("ip_ver_and_post_fwd_stage", ip_ver_and_post_fwd_stage.to_field_structure());
    return fs_result;
}
std::string to_string(npl_post_fwd_params_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_post_fwd_params_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_properties_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 2, l3_dlp_id_ext.pack());
    // PADDING -  bv.set_bits(1, 1, padding);
    bv.set_bits(0, 0, monitor_or_l3_dlp_ip_type.pack());
    return bv;
}


void npl_properties_t::unpack(bit_vector64_t bv) 
{
    l3_dlp_id_ext.unpack(bv.bits(3, 2));
    // PADDING -  padding = bv.bits(1, 1).get_value();
    monitor_or_l3_dlp_ip_type.unpack(bv.bits(0, 0));
}



field_structure npl_properties_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_properties_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp_id_ext", l3_dlp_id_ext.to_field_structure());
    
    fs_result.subfields.emplace_back("monitor_or_l3_dlp_ip_type", monitor_or_l3_dlp_ip_type.to_field_structure());
    return fs_result;
}
std::string to_string(npl_properties_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_properties_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_code_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    { // union compound field start
        bit_vector64_t tbv = punt_redirect_code.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = snoop_code.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (punt_mirror_code != 0) {  // union primitive field start
        bv.set_bits(7, 0, punt_mirror_code);
        return bv;
    }// union primitive field end
    
    if (lpts_reason != 0) {  // union primitive field start
        bv.set_bits(7, 0, lpts_reason);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_punt_code_t::unpack(bit_vector64_t bv) // union
{
    punt_redirect_code.unpack(bv.bits(7, 0));
}



field_structure npl_punt_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_code_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = punt_redirect_code.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_redirect_code", punt_redirect_code.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = snoop_code.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("snoop_code", snoop_code.to_field_structure());
        }
    } // union compound field end
    
    if (punt_mirror_code != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(punt_mirror_code);
        return union_found;
    }// union primitive field end
    
    if (lpts_reason != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(lpts_reason);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_punt_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_encap_data_lsb_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, punt_nw_encap_ptr.pack());
    bv.set_bits(7, 4, punt_nw_encap_type);
    bv.set_bits(3, 3, extra.pack());
    bv.set_bits(2, 0, punt_controls.pack());
    return bv;
}


void npl_punt_encap_data_lsb_t::unpack(bit_vector64_t bv) 
{
    punt_nw_encap_ptr.unpack(bv.bits(15, 8));
    punt_nw_encap_type = (npl_punt_nw_encap_type_e)bv.bits(7, 4).get_value();
    extra.unpack(bv.bits(3, 3));
    punt_controls.unpack(bv.bits(2, 0));
}



field_structure npl_punt_encap_data_lsb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_encap_data_lsb_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("punt_nw_encap_ptr", punt_nw_encap_ptr.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(punt_nw_encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_nw_encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("extra", extra.to_field_structure());
    fs_result.subfields.emplace_back("punt_controls", punt_controls.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_encap_data_lsb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_encap_data_lsb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_if_sa_or_npu_host_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (punt_if_sa_lsb != 0) {  // union primitive field start
        bv.set_bits(15, 0, punt_if_sa_lsb);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = punt_npu_host_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_punt_if_sa_or_npu_host_data_t::unpack(bit_vector64_t bv) // union
{
    punt_if_sa_lsb = bv.bits(15, 0).get_value();
}



field_structure npl_punt_if_sa_or_npu_host_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_if_sa_or_npu_host_data_t";
    field_structure fs_subfield;
    //add members to result
    if (punt_if_sa_lsb != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(punt_if_sa_lsb);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = punt_npu_host_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_npu_host_data", punt_npu_host_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_punt_if_sa_or_npu_host_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_if_sa_or_npu_host_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_npu_host_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    // PADDING -  bv.set_bits(47, 16, padding);
    bv.set_bits(15, 0, npu_host_macro_data.pack());
    return bv;
}


void npl_punt_npu_host_data_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(47, 16).get_value();
    npu_host_macro_data.unpack(bv.bits(15, 0));
}



field_structure npl_punt_npu_host_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_npu_host_data_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("npu_host_macro_data", npu_host_macro_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_npu_host_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_npu_host_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_padding_id_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 0, id.pack());
    return bv;
}


void npl_punt_padding_id_t::unpack(bit_vector64_t bv) 
{
    id.unpack(bv.bits(13, 0));
}



field_structure npl_punt_padding_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_padding_id_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("id", id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_padding_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_padding_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_shared_lsb_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 20, punt_ts_cmd.pack());
    bv.set_bits(19, 4, punt_encap_data_lsb.pack());
    bv.set_bits(3, 0, punt_cud_type);
    return bv;
}


void npl_punt_shared_lsb_encap_t::unpack(bit_vector64_t bv) 
{
    punt_ts_cmd.unpack(bv.bits(31, 20));
    punt_encap_data_lsb.unpack(bv.bits(19, 4));
    punt_cud_type = (npl_punt_cud_type_e)bv.bits(3, 0).get_value();
}



field_structure npl_punt_shared_lsb_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_shared_lsb_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("punt_ts_cmd", punt_ts_cmd.to_field_structure());
    fs_result.subfields.emplace_back("punt_encap_data_lsb", punt_encap_data_lsb.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(punt_cud_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_cud_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_shared_lsb_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_shared_lsb_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_src_and_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 8, punt_source);
    bv.set_bits(7, 0, punt_code.pack());
    return bv;
}


void npl_punt_src_and_code_t::unpack(bit_vector64_t bv) 
{
    punt_source = (npl_punt_source_e)bv.bits(11, 8).get_value();
    punt_code.unpack(bv.bits(7, 0));
}



field_structure npl_punt_src_and_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_src_and_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(punt_source);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_source", fs_subfield);
    
    fs_result.subfields.emplace_back("punt_code", punt_code.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_src_and_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_src_and_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_ssp_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 27);
    bv.set_bits(26, 16, split_voq.pack());
    bv.set_bits(15, 0, ssp.pack());
    return bv;
}


void npl_punt_ssp_attributes_t::unpack(bit_vector64_t bv) 
{
    split_voq.unpack(bv.bits(26, 16));
    ssp.unpack(bv.bits(15, 0));
}



field_structure npl_punt_ssp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_ssp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("split_voq", split_voq.to_field_structure());
    fs_result.subfields.emplace_back("ssp", ssp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_ssp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_ssp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_sub_code_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, sub_code.pack());
    return bv;
}


void npl_punt_sub_code_t::unpack(bit_vector64_t bv) 
{
    sub_code.unpack(bv.bits(3, 0));
}



field_structure npl_punt_sub_code_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_sub_code_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("sub_code", sub_code.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_sub_code_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_sub_code_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_sub_code_with_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    // PADDING -  bv.set_bits(7, 4, padding);
    bv.set_bits(3, 0, ene_punt_sub_code.pack());
    return bv;
}


void npl_punt_sub_code_with_padding_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(7, 4).get_value();
    ene_punt_sub_code.unpack(bv.bits(3, 0));
}



field_structure npl_punt_sub_code_with_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_sub_code_with_padding_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("ene_punt_sub_code", ene_punt_sub_code.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_sub_code_with_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_sub_code_with_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pwe_to_l3_compound_lookup_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 4, payload.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_pwe_to_l3_compound_lookup_result_t::unpack(bit_vector64_t bv) 
{
    payload.unpack(bv.bits(23, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_pwe_to_l3_compound_lookup_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pwe_to_l3_compound_lookup_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("payload", payload.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_pwe_to_l3_compound_lookup_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pwe_to_l3_compound_lookup_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_mapping_key_t_anonymous_union_key_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    { // union compound field start
        bit_vector64_t tbv = key.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (mpls_exp != 0) {  // union primitive field start
        bv.set_bits(2, 0, mpls_exp);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_qos_mapping_key_t_anonymous_union_key_union_t::unpack(bit_vector64_t bv) // union
{
    key.unpack(bv.bits(7, 0));
}



field_structure npl_qos_mapping_key_t_anonymous_union_key_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_mapping_key_t_anonymous_union_key_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = key.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("key", key.to_field_structure());
        }
    } // union compound field end
    
    if (mpls_exp != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mpls_exp);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_qos_mapping_key_t_anonymous_union_key_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_mapping_key_t_anonymous_union_key_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_redirect_stage_og_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 39);
    bv.set_bits(38, 38, lpts_is_mc);
    bv.set_bits(37, 34, lpts_og_app_id);
    bv.set_bits(33, 32, lpts_packet_flags.pack());
    bv.set_bits(31, 0, lpts_object_groups.pack());
    return bv;
}


void npl_redirect_stage_og_key_t::unpack(bit_vector64_t bv) 
{
    lpts_is_mc = bv.bits(38, 38).get_value();
    lpts_og_app_id = bv.bits(37, 34).get_value();
    lpts_packet_flags.unpack(bv.bits(33, 32));
    lpts_object_groups.unpack(bv.bits(31, 0));
}



field_structure npl_redirect_stage_og_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_redirect_stage_og_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lpts_is_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpts_is_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lpts_og_app_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpts_og_app_id", fs_subfield);
    
    fs_result.subfields.emplace_back("lpts_packet_flags", lpts_packet_flags.to_field_structure());
    fs_result.subfields.emplace_back("lpts_object_groups", lpts_object_groups.to_field_structure());
    return fs_result;
}
std::string to_string(npl_redirect_stage_og_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_redirect_stage_og_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_relay_attr_table_payload_t::pack(void) const // union
{
    bit_vector128_t bv(0, 66);
    { // union compound field start
        bit_vector64_t tbv = relay_attr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(44, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_relay_attr_table_payload_t::unpack(bit_vector128_t bv) // union
{
    relay_attr.unpack(bv.bits(44, 0));
}



field_structure npl_relay_attr_table_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_relay_attr_table_payload_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = relay_attr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("relay_attr", relay_attr.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_relay_attr_table_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_relay_attr_table_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_stage_assoc_data_narrow_entry_t::pack(void) const // union
{
    bit_vector64_t bv(0, 36);
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_l3_nh_ip_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_level2_ecmp_ip_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_l2_dlp_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_nh_no_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_nh_te_he.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_nh_ldp_over_te.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_p_nh_no_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_p_nh_te_he.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_p_nh_ldp_over_te.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ecmp_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_destination_overlay_nh.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_dest1.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_dest1.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_tunnel_or_asbr_he_with_tunnel_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_tunnel_or_asbr_ldp_over_te.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_lsp_asbr_nh.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage3_dspa_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage3_raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_resolution_stage_assoc_data_narrow_entry_t::unpack(bit_vector64_t bv) // union
{
    stage0_ce_ptr_l3_nh_ip_tunnel.unpack(bv.bits(35, 0));
}



field_structure npl_resolution_stage_assoc_data_narrow_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_narrow_entry_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_l3_nh_ip_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_l3_nh_ip_tunnel", stage0_ce_ptr_l3_nh_ip_tunnel.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_level2_ecmp_ip_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_level2_ecmp_ip_tunnel", stage0_ce_ptr_level2_ecmp_ip_tunnel.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_l2_dlp_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_l2_dlp_dest", stage0_l2_dlp_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_nh_no_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_nh_no_tunnel", stage0_ce_ptr_nh_no_tunnel.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_nh_te_he.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_nh_te_he", stage0_ce_ptr_nh_te_he.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_nh_ldp_over_te.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_nh_ldp_over_te", stage0_ce_ptr_nh_ldp_over_te.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_p_nh_no_tunnel.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_p_nh_no_tunnel", stage0_ce_ptr_p_nh_no_tunnel.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_p_nh_te_he.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_p_nh_te_he", stage0_ce_ptr_p_nh_te_he.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ce_ptr_p_nh_ldp_over_te.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_p_nh_ldp_over_te", stage0_ce_ptr_p_nh_ldp_over_te.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_ecmp_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ecmp_dest", stage0_ecmp_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_destination_overlay_nh.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_destination_overlay_nh", stage0_destination_overlay_nh.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_dest1.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_dest1", stage0_dest1.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage0_raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_raw", stage0_raw.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_ecmp_dest", stage1_ecmp_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_dest1.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_ecmp_dest1", stage1_ecmp_dest1.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_tunnel_or_asbr_he_with_tunnel_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_ecmp_tunnel_or_asbr_he_with_tunnel_id", stage1_ecmp_tunnel_or_asbr_he_with_tunnel_id.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_tunnel_or_asbr_ldp_over_te.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_ecmp_tunnel_or_asbr_ldp_over_te", stage1_ecmp_tunnel_or_asbr_ldp_over_te.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage1_ecmp_lsp_asbr_nh.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage1_ecmp_lsp_asbr_nh", stage1_ecmp_lsp_asbr_nh.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage3_dspa_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage3_dspa_dest", stage3_dspa_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = stage3_raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage3_raw", stage3_raw.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_narrow_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_narrow_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_narrow_line_t::pack(void) const 
{
    bit_vector192_t bv(0, 145);
    bv.set_bits(144, 144, type);
    bv.set_bits(143, 108, entry[3].pack());
    bv.set_bits(107, 72, entry[2].pack());
    bv.set_bits(71, 36, entry[1].pack());
    bv.set_bits(35, 0, entry[0].pack());
    return bv;
}


void npl_resolution_stage_assoc_data_narrow_line_t::unpack(bit_vector192_t bv) 
{
    type = (npl_resolution_state_assoc_data_entry_type_e)bv.bits(144, 144).get_value();
    entry[3].unpack(bv.bits(143, 108));
    entry[2].unpack(bv.bits(107, 72));
    entry[1].unpack(bv.bits(71, 36));
    entry[0].unpack(bv.bits(35, 0));
}



field_structure npl_resolution_stage_assoc_data_narrow_line_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_narrow_line_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_result.subfields.emplace_back("entry[3]", entry[3].to_field_structure());
    fs_result.subfields.emplace_back("entry[2]", entry[2].to_field_structure());
    fs_result.subfields.emplace_back("entry[1]", entry[1].to_field_structure());
    fs_result.subfields.emplace_back("entry[0]", entry[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_narrow_line_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_narrow_line_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_narrow_protection_line_t::pack(void) const 
{
    bit_vector192_t bv(0, 145);
    bv.set_bits(144, 144, type);
    bv.set_bits(143, 131, id);
    bv.set_bits(130, 130, const1);
    bv.set_bits(129, 65, record[1].pack());
    bv.set_bits(64, 0, record[0].pack());
    return bv;
}


void npl_resolution_stage_assoc_data_narrow_protection_line_t::unpack(bit_vector192_t bv) 
{
    type = (npl_resolution_state_assoc_data_entry_type_e)bv.bits(144, 144).get_value();
    id = bv.bits(143, 131).get_value();
    const1 = bv.bits(130, 130).get_value();
    record[1].unpack(bv.bits(129, 65));
    record[0].unpack(bv.bits(64, 0));
}



field_structure npl_resolution_stage_assoc_data_narrow_protection_line_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_narrow_protection_line_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(const1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("const1", fs_subfield);
    
    fs_result.subfields.emplace_back("record[1]", record[1].to_field_structure());
    fs_result.subfields.emplace_back("record[0]", record[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_narrow_protection_line_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_narrow_protection_line_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_resolution_stage_assoc_data_wide_entry_t::pack(void) const // union
{
    bit_vector128_t bv(0, 72);
    { // union compound field start
        bit_vector128_t tbv = stage0_ce_ptr_ecmp2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage2_l3_nh_dlp_bvn_profile.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage2_l3_nh_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage2_raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_resolution_stage_assoc_data_wide_entry_t::unpack(bit_vector128_t bv) // union
{
    stage0_ce_ptr_ecmp2.unpack(bv.bits(71, 0));
}



field_structure npl_resolution_stage_assoc_data_wide_entry_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_wide_entry_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = stage0_ce_ptr_ecmp2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage0_ce_ptr_ecmp2", stage0_ce_ptr_ecmp2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage2_l3_nh_dlp_bvn_profile.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage2_l3_nh_dlp_bvn_profile", stage2_l3_nh_dlp_bvn_profile.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage2_l3_nh_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage2_l3_nh_dlp", stage2_l3_nh_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = stage2_raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("stage2_raw", stage2_raw.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_wide_entry_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_wide_entry_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_wide_line_t::pack(void) const 
{
    bit_vector192_t bv(0, 145);
    bv.set_bits(144, 144, type);
    bv.set_bits(143, 72, entry[1].pack());
    bv.set_bits(71, 0, entry[0].pack());
    return bv;
}


void npl_resolution_stage_assoc_data_wide_line_t::unpack(bit_vector192_t bv) 
{
    type = (npl_resolution_state_assoc_data_entry_type_e)bv.bits(144, 144).get_value();
    entry[1].unpack(bv.bits(143, 72));
    entry[0].unpack(bv.bits(71, 0));
}



field_structure npl_resolution_stage_assoc_data_wide_line_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_wide_line_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_result.subfields.emplace_back("entry[1]", entry[1].to_field_structure());
    fs_result.subfields.emplace_back("entry[0]", entry[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_wide_line_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_wide_line_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_wide_protection_record_t::pack(void) const 
{
    bit_vector192_t bv(0, 144);
    bv.set_bits(143, 131, id);
    bv.set_bits(130, 130, path);
    bv.set_bits(129, 65, primary_entry.pack());
    bv.set_bits(64, 0, protect_entry.pack());
    return bv;
}


void npl_resolution_stage_assoc_data_wide_protection_record_t::unpack(bit_vector192_t bv) 
{
    id = bv.bits(143, 131).get_value();
    path = (npl_resolution_protection_selector_e)bv.bits(130, 130).get_value();
    primary_entry.unpack(bv.bits(129, 65));
    protect_entry.unpack(bv.bits(64, 0));
}



field_structure npl_resolution_stage_assoc_data_wide_protection_record_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_wide_protection_record_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("id", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(path);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("path", fs_subfield);
    
    fs_result.subfields.emplace_back("primary_entry", primary_entry.to_field_structure());
    fs_result.subfields.emplace_back("protect_entry", protect_entry.to_field_structure());
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_wide_protection_record_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_wide_protection_record_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_resolution_stage_em_table_key_t::pack(void) const // union
{
    bit_vector64_t bv(0, 24);
    { // union compound field start
        bit_vector64_t tbv = dest_map_key.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lb_key.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = raw_key.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_resolution_stage_em_table_key_t::unpack(bit_vector64_t bv) // union
{
    dest_map_key.unpack(bv.bits(23, 0));
}



field_structure npl_resolution_stage_em_table_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_em_table_key_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = dest_map_key.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("dest_map_key", dest_map_key.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lb_key.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lb_key", lb_key.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = raw_key.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("raw_key", raw_key.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_em_table_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_em_table_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rpf_compressed_destination_t_anonymous_union_rpf_id_or_lp_id_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    if (rpf_id != 0) {  // union primitive field start
        bv.set_bits(15, 0, rpf_id);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = lp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(13, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rpf_compressed_destination_t_anonymous_union_rpf_id_or_lp_id_t::unpack(bit_vector64_t bv) // union
{
    rpf_id = bv.bits(15, 0).get_value();
}



field_structure npl_rpf_compressed_destination_t_anonymous_union_rpf_id_or_lp_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rpf_compressed_destination_t_anonymous_union_rpf_id_or_lp_id_t";
    field_structure fs_subfield;
    //add members to result
    if (rpf_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(rpf_id);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = lp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lp", lp.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rpf_compressed_destination_t_anonymous_union_rpf_id_or_lp_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rpf_compressed_destination_t_anonymous_union_rpf_id_or_lp_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_next_macro_pack_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 4, curr_and_next_prot_type.pack());
    bv.set_bits(3, 0, stop_on_step_and_next_stage_compressed_fields.pack());
    return bv;
}


void npl_rtf_next_macro_pack_fields_t::unpack(bit_vector64_t bv) 
{
    curr_and_next_prot_type.unpack(bv.bits(11, 4));
    stop_on_step_and_next_stage_compressed_fields.unpack(bv.bits(3, 0));
}



field_structure npl_rtf_next_macro_pack_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_next_macro_pack_fields_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("curr_and_next_prot_type", curr_and_next_prot_type.to_field_structure());
    fs_result.subfields.emplace_back("stop_on_step_and_next_stage_compressed_fields", stop_on_step_and_next_stage_compressed_fields.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rtf_next_macro_pack_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_next_macro_pack_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_0_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    bv.set_bits(61, 61, mirror_action);
    bv.set_bits(60, 56, phb.pack());
    bv.set_bits(55, 51, q_m_offset_5bits);
    bv.set_bits(50, 49, counter_action_type);
    bv.set_bits(48, 44, mirror_cmd_or_offset.pack());
    bv.set_bits(43, 43, override_phb);
    bv.set_bits(42, 40, rtf_sec_action);
    bv.set_bits(39, 39, override_qos_group);
    bv.set_bits(38, 20, ingress_qos_remark.pack());
    bv.set_bits(19, 0, force.pack());
    return bv;
}


void npl_rtf_result_profile_0_t::unpack(bit_vector64_t bv) 
{
    mirror_action = (npl_mirror_action_e)bv.bits(61, 61).get_value();
    phb.unpack(bv.bits(60, 56));
    q_m_offset_5bits = bv.bits(55, 51).get_value();
    counter_action_type = (npl_counter_action_type_e)bv.bits(50, 49).get_value();
    mirror_cmd_or_offset.unpack(bv.bits(48, 44));
    override_phb = bv.bits(43, 43).get_value();
    rtf_sec_action = (npl_rtf_sec_action_e)bv.bits(42, 40).get_value();
    override_qos_group = bv.bits(39, 39).get_value();
    ingress_qos_remark.unpack(bv.bits(38, 20));
    force.unpack(bv.bits(19, 0));
}



field_structure npl_rtf_result_profile_0_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_0_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(mirror_action);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mirror_action", fs_subfield);
    
    fs_result.subfields.emplace_back("phb", phb.to_field_structure());
    fs_subfield.flat_value = to_hex_string(q_m_offset_5bits);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("q_m_offset_5bits", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(counter_action_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_action_type", fs_subfield);
    
    fs_result.subfields.emplace_back("mirror_cmd_or_offset", mirror_cmd_or_offset.to_field_structure());
    fs_subfield.flat_value = to_hex_string(override_phb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_phb", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(rtf_sec_action);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtf_sec_action", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(override_qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_qos_group", fs_subfield);
    
    fs_result.subfields.emplace_back("ingress_qos_remark", ingress_qos_remark.to_field_structure());
    fs_result.subfields.emplace_back("force", force.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_0_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_0_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_result_profile_1_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    // PADDING -  bv.set_bits(61, 61, padding);
    bv.set_bits(60, 60, rtf_res_profile_1_action);
    bv.set_bits(59, 40, meter_or_counter.pack());
    bv.set_bits(39, 39, override_qos_group);
    bv.set_bits(38, 20, ingress_qos_remark.pack());
    bv.set_bits(19, 0, destination.pack());
    return bv;
}


void npl_rtf_result_profile_1_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(61, 61).get_value();
    rtf_res_profile_1_action = (npl_rtf_res_profile_1_action_e)bv.bits(60, 60).get_value();
    meter_or_counter.unpack(bv.bits(59, 40));
    override_qos_group = bv.bits(39, 39).get_value();
    ingress_qos_remark.unpack(bv.bits(38, 20));
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_rtf_result_profile_1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_result_profile_1_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = npl_enum_to_string(rtf_res_profile_1_action);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtf_res_profile_1_action", fs_subfield);
    
    fs_result.subfields.emplace_back("meter_or_counter", meter_or_counter.to_field_structure());
    fs_subfield.flat_value = to_hex_string(override_qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_qos_group", fs_subfield);
    
    fs_result.subfields.emplace_back("ingress_qos_remark", ingress_qos_remark.to_field_structure());
    fs_result.subfields.emplace_back("destination", destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rtf_result_profile_1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_result_profile_1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_rxpp_pd_t::pack(void) const 
{
    bit_vector384_t bv(0, 258);
    bv.set_bits(257, 250, source_if);
    bv.set_bits(249, 249, drop_flag);
    bv.set_bits(248, 229, fwd_destination.pack());
    bv.set_bits(228, 224, in_mirror_cmd0);
    bv.set_bits(223, 221, tc);
    bv.set_bits(220, 219, in_color);
    bv.set_bits(218, 200, counter_meter_ptr_0);
    bv.set_bits(199, 193, counter_meter_comp_0);
    bv.set_bits(192, 192, counter_lm_read_only_0);
    bv.set_bits(191, 189, ethernet_rate_limiter_type);
    bv.set_bits(188, 188, packet_learn_enable);
    bv.set_bits(187, 175, snr_context);
    bv.set_bits(174, 155, snr_psn);
    bv.set_bits(154, 153, snr_out_slice);
    bv.set_bits(152, 137, lb_or_slb.pack());
    bv.set_bits(136, 0, slice_mode_data.pack());
    return bv;
}


void npl_rxpp_pd_t::unpack(bit_vector384_t bv) 
{
    source_if = bv.bits(257, 250).get_value();
    drop_flag = bv.bits(249, 249).get_value();
    fwd_destination.unpack(bv.bits(248, 229));
    in_mirror_cmd0 = bv.bits(228, 224).get_value();
    tc = bv.bits(223, 221).get_value();
    in_color = bv.bits(220, 219).get_value();
    counter_meter_ptr_0 = bv.bits(218, 200).get_value();
    counter_meter_comp_0 = bv.bits(199, 193).get_value();
    counter_lm_read_only_0 = bv.bits(192, 192).get_value();
    ethernet_rate_limiter_type = bv.bits(191, 189).get_value();
    packet_learn_enable = bv.bits(188, 188).get_value();
    snr_context = bv.bits(187, 175).get_value();
    snr_psn = bv.bits(174, 155).get_value();
    snr_out_slice = bv.bits(154, 153).get_value();
    lb_or_slb.unpack(bv.bits(152, 137));
    slice_mode_data.unpack(bv.bits(136, 0));
}



field_structure npl_rxpp_pd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rxpp_pd_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(source_if);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("source_if", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(drop_flag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("drop_flag", fs_subfield);
    
    fs_result.subfields.emplace_back("fwd_destination", fwd_destination.to_field_structure());
    fs_subfield.flat_value = to_hex_string(in_mirror_cmd0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("in_mirror_cmd0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(in_color);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("in_color", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_ptr_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_ptr_0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_meter_comp_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_meter_comp_0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(counter_lm_read_only_0);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("counter_lm_read_only_0", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ethernet_rate_limiter_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ethernet_rate_limiter_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(packet_learn_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("packet_learn_enable", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(snr_context);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("snr_context", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(snr_psn);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("snr_psn", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(snr_out_slice);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("snr_out_slice", fs_subfield);
    
    fs_result.subfields.emplace_back("lb_or_slb", lb_or_slb.to_field_structure());
    fs_result.subfields.emplace_back("slice_mode_data", slice_mode_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rxpp_pd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rxpp_pd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_sch_oqse_cfg_result_4p_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    bv.set_bits(71, 70, logical_port_map[1]);
    bv.set_bits(69, 68, logical_port_map[0]);
    bv.set_bits(67, 66, oqse_topology[1].pack());
    bv.set_bits(65, 64, oqse_topology[0].pack());
    bv.set_bits(63, 32, oqse_wfq_weight[1].pack());
    bv.set_bits(31, 0, oqse_wfq_weight[0].pack());
    return bv;
}


void npl_sch_oqse_cfg_result_4p_t::unpack(bit_vector128_t bv) 
{
    logical_port_map[1] = (npl_oqse_logical_port_map_4p_e)bv.bits(71, 70).get_value();
    logical_port_map[0] = (npl_oqse_logical_port_map_4p_e)bv.bits(69, 68).get_value();
    oqse_topology[1].unpack(bv.bits(67, 66));
    oqse_topology[0].unpack(bv.bits(65, 64));
    oqse_wfq_weight[1].unpack(bv.bits(63, 32));
    oqse_wfq_weight[0].unpack(bv.bits(31, 0));
}



field_structure npl_sch_oqse_cfg_result_4p_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sch_oqse_cfg_result_4p_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(logical_port_map[1]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("logical_port_map[1]", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(logical_port_map[0]);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("logical_port_map[0]", fs_subfield);
    
    fs_result.subfields.emplace_back("oqse_topology[1]", oqse_topology[1].to_field_structure());
    fs_result.subfields.emplace_back("oqse_topology[0]", oqse_topology[0].to_field_structure());
    fs_result.subfields.emplace_back("oqse_wfq_weight[1]", oqse_wfq_weight[1].to_field_structure());
    fs_result.subfields.emplace_back("oqse_wfq_weight[0]", oqse_wfq_weight[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_sch_oqse_cfg_result_4p_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sch_oqse_cfg_result_4p_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_sch_oqse_cfg_result_8p_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    bv.set_bits(71, 68, logical_port_map);
    bv.set_bits(67, 64, oqse_topology);
    bv.set_bits(63, 0, oqse_wfq_weight.pack());
    return bv;
}


void npl_sch_oqse_cfg_result_8p_t::unpack(bit_vector128_t bv) 
{
    logical_port_map = (npl_oqse_logical_port_map_8p_e)bv.bits(71, 68).get_value();
    oqse_topology = (npl_oqse_topology_8p_e)bv.bits(67, 64).get_value();
    oqse_wfq_weight.unpack(bv.bits(63, 0));
}



field_structure npl_sch_oqse_cfg_result_8p_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sch_oqse_cfg_result_8p_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(logical_port_map);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("logical_port_map", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(oqse_topology);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("oqse_topology", fs_subfield);
    
    fs_result.subfields.emplace_back("oqse_wfq_weight", oqse_wfq_weight.to_field_structure());
    return fs_result;
}
std::string to_string(npl_sch_oqse_cfg_result_8p_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sch_oqse_cfg_result_8p_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_sch_oqse_cfg_result_t::pack(void) const // union
{
    bit_vector128_t bv(0, 72);
    { // union compound field start
        bit_vector128_t tbv = single_8p.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = pair_4p.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_sch_oqse_cfg_result_t::unpack(bit_vector128_t bv) // union
{
    single_8p.unpack(bv.bits(71, 0));
}



field_structure npl_sch_oqse_cfg_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sch_oqse_cfg_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = single_8p.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("single_8p", single_8p.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = pair_4p.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pair_4p", pair_4p.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_sch_oqse_cfg_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sch_oqse_cfg_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sec_acl_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 52);
    bv.set_bits(51, 44, rtf_conf_set_ptr);
    bv.set_bits(43, 24, p_counter.pack());
    bv.set_bits(23, 4, slp_dlp.pack());
    bv.set_bits(3, 3, per_pkt_type_count);
    bv.set_bits(2, 2, port_mirror_type);
    bv.set_bits(1, 0, l2_lpts_slp_attributes);
    return bv;
}


void npl_sec_acl_attributes_t::unpack(bit_vector64_t bv) 
{
    rtf_conf_set_ptr = bv.bits(51, 44).get_value();
    p_counter.unpack(bv.bits(43, 24));
    slp_dlp.unpack(bv.bits(23, 4));
    per_pkt_type_count = bv.bits(3, 3).get_value();
    port_mirror_type = (npl_port_mirror_type_e)bv.bits(2, 2).get_value();
    l2_lpts_slp_attributes = bv.bits(1, 0).get_value();
}



field_structure npl_sec_acl_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sec_acl_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(rtf_conf_set_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtf_conf_set_ptr", fs_subfield);
    
    fs_result.subfields.emplace_back("p_counter", p_counter.to_field_structure());
    fs_result.subfields.emplace_back("slp_dlp", slp_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(per_pkt_type_count);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("per_pkt_type_count", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(port_mirror_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("port_mirror_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_lpts_slp_attributes);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_lpts_slp_attributes", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_sec_acl_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sec_acl_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sgt_matrix_padded_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 57);
    bv.set_bits(56, 4, sgt_matrix_em_result.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_sgt_matrix_padded_result_t::unpack(bit_vector64_t bv) 
{
    sgt_matrix_em_result.unpack(bv.bits(56, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_sgt_matrix_padded_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sgt_matrix_padded_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("sgt_matrix_em_result", sgt_matrix_em_result.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_sgt_matrix_padded_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sgt_matrix_padded_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_shared_l2_lp_attributes_t::pack(void) const 
{
    bit_vector128_t bv(0, 105);
    bv.set_bits(104, 104, p2p);
    bv.set_bits(103, 100, qos_id);
    bv.set_bits(99, 98, lp_profile);
    bv.set_bits(97, 97, stp_state_block);
    bv.set_bits(96, 92, mirror_cmd);
    bv.set_bits(91, 40, sec_acl_attributes.pack());
    bv.set_bits(39, 20, q_counter.pack());
    bv.set_bits(19, 0, m_counter.pack());
    return bv;
}


void npl_shared_l2_lp_attributes_t::unpack(bit_vector128_t bv) 
{
    p2p = bv.bits(104, 104).get_value();
    qos_id = bv.bits(103, 100).get_value();
    lp_profile = bv.bits(99, 98).get_value();
    stp_state_block = bv.bits(97, 97).get_value();
    mirror_cmd = bv.bits(96, 92).get_value();
    sec_acl_attributes.unpack(bv.bits(91, 40));
    q_counter.unpack(bv.bits(39, 20));
    m_counter.unpack(bv.bits(19, 0));
}



field_structure npl_shared_l2_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_shared_l2_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(p2p);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("p2p", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(qos_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lp_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(stp_state_block);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("stp_state_block", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mirror_cmd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mirror_cmd", fs_subfield);
    
    fs_result.subfields.emplace_back("sec_acl_attributes", sec_acl_attributes.to_field_structure());
    fs_result.subfields.emplace_back("q_counter", q_counter.to_field_structure());
    fs_result.subfields.emplace_back("m_counter", m_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_shared_l2_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_shared_l2_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_single_label_encap_data_t_anonymous_union_udat_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    if (gre_key != 0) {  // union primitive field start
        bv.set_bits(31, 0, gre_key);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = label_and_valid.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(25, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_single_label_encap_data_t_anonymous_union_udat_t::unpack(bit_vector64_t bv) // union
{
    gre_key = bv.bits(31, 0).get_value();
}



field_structure npl_single_label_encap_data_t_anonymous_union_udat_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_single_label_encap_data_t_anonymous_union_udat_t";
    field_structure fs_subfield;
    //add members to result
    if (gre_key != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(gre_key);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = label_and_valid.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("label_and_valid", label_and_valid.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_single_label_encap_data_t_anonymous_union_udat_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_single_label_encap_data_t_anonymous_union_udat_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_slice_and_source_if_t::pack(void) const 
{
    bit_vector64_t bv(0, 11);
    bv.set_bits(10, 8, slice_id_on_npu);
    bv.set_bits(7, 0, source_if_on_npu.pack());
    return bv;
}


void npl_slice_and_source_if_t::unpack(bit_vector64_t bv) 
{
    slice_id_on_npu = bv.bits(10, 8).get_value();
    source_if_on_npu.unpack(bv.bits(7, 0));
}



field_structure npl_slice_and_source_if_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_slice_and_source_if_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(slice_id_on_npu);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slice_id_on_npu", fs_subfield);
    
    fs_result.subfields.emplace_back("source_if_on_npu", source_if_on_npu.to_field_structure());
    return fs_result;
}
std::string to_string(npl_slice_and_source_if_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_slice_and_source_if_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_sport_or_l4_protocol_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, sport_or_l4_protocol_type.pack());
    return bv;
}


void npl_sport_or_l4_protocol_t::unpack(bit_vector64_t bv) 
{
    sport_or_l4_protocol_type.unpack(bv.bits(15, 0));
}



field_structure npl_sport_or_l4_protocol_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_sport_or_l4_protocol_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("sport_or_l4_protocol_type", sport_or_l4_protocol_type.to_field_structure());
    return fs_result;
}
std::string to_string(npl_sport_or_l4_protocol_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_sport_or_l4_protocol_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svi_eve_sub_type_plus_pad_plus_prf_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    // PADDING -  bv.set_bits(13, 5, padding);
    bv.set_bits(4, 0, sub_type_plus_prf.pack());
    return bv;
}


void npl_svi_eve_sub_type_plus_pad_plus_prf_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(13, 5).get_value();
    sub_type_plus_prf.unpack(bv.bits(4, 0));
}



field_structure npl_svi_eve_sub_type_plus_pad_plus_prf_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svi_eve_sub_type_plus_pad_plus_prf_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("sub_type_plus_prf", sub_type_plus_prf.to_field_structure());
    return fs_result;
}
std::string to_string(npl_svi_eve_sub_type_plus_pad_plus_prf_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svi_eve_sub_type_plus_pad_plus_prf_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svl_data_t_anonymous_union_svl_uc_mc_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    { // union compound field start
        bit_vector64_t tbv = svl_uc_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = svl_mc_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_svl_data_t_anonymous_union_svl_uc_mc_data_t::unpack(bit_vector64_t bv) // union
{
    svl_uc_data.unpack(bv.bits(15, 0));
}



field_structure npl_svl_data_t_anonymous_union_svl_uc_mc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svl_data_t_anonymous_union_svl_uc_mc_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = svl_uc_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("svl_uc_data", svl_uc_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = svl_mc_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("svl_mc_data", svl_mc_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_svl_data_t_anonymous_union_svl_uc_mc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svl_data_t_anonymous_union_svl_uc_mc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_te_midpoint_nhlfe_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 40, mp_label);
    bv.set_bits(39, 20, lsp.pack());
    bv.set_bits(19, 8, midpoint_nh);
    bv.set_bits(7, 0, counter_offset.pack());
    return bv;
}


void npl_te_midpoint_nhlfe_t::unpack(bit_vector64_t bv) 
{
    mp_label = bv.bits(59, 40).get_value();
    lsp.unpack(bv.bits(39, 20));
    midpoint_nh = bv.bits(19, 8).get_value();
    counter_offset.unpack(bv.bits(7, 0));
}



field_structure npl_te_midpoint_nhlfe_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_te_midpoint_nhlfe_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(mp_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_label", fs_subfield);
    
    fs_result.subfields.emplace_back("lsp", lsp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(midpoint_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("midpoint_nh", fs_subfield);
    
    fs_result.subfields.emplace_back("counter_offset", counter_offset.to_field_structure());
    return fs_result;
}
std::string to_string(npl_te_midpoint_nhlfe_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_te_midpoint_nhlfe_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tunnel_headend_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 46);
    bv.set_bits(45, 26, lsp_destination.pack());
    bv.set_bits(25, 10, te_asbr.pack());
    bv.set_bits(9, 0, mldp_protection.pack());
    return bv;
}


void npl_tunnel_headend_encap_t::unpack(bit_vector64_t bv) 
{
    lsp_destination.unpack(bv.bits(45, 26));
    te_asbr.unpack(bv.bits(25, 10));
    mldp_protection.unpack(bv.bits(9, 0));
}



field_structure npl_tunnel_headend_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tunnel_headend_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lsp_destination", lsp_destination.to_field_structure());
    fs_result.subfields.emplace_back("te_asbr", te_asbr.to_field_structure());
    fs_result.subfields.emplace_back("mldp_protection", mldp_protection.to_field_structure());
    return fs_result;
}
std::string to_string(npl_tunnel_headend_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tunnel_headend_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tunnel_type_and_force_pipe_ttl_ingress_ptp_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 12);
    bv.set_bits(11, 8, force_pipe_ttl_ingress_ptp_null.pack());
    bv.set_bits(7, 4, force_pipe_ttl_ingress_ptp_info.pack());
    bv.set_bits(3, 0, tunnel_type);
    return bv;
}


void npl_tunnel_type_and_force_pipe_ttl_ingress_ptp_info_t::unpack(bit_vector64_t bv) 
{
    force_pipe_ttl_ingress_ptp_null.unpack(bv.bits(11, 8));
    force_pipe_ttl_ingress_ptp_info.unpack(bv.bits(7, 4));
    tunnel_type = (npl_tunnel_type_e)bv.bits(3, 0).get_value();
}



field_structure npl_tunnel_type_and_force_pipe_ttl_ingress_ptp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tunnel_type_and_force_pipe_ttl_ingress_ptp_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("force_pipe_ttl_ingress_ptp_null", force_pipe_ttl_ingress_ptp_null.to_field_structure());
    fs_result.subfields.emplace_back("force_pipe_ttl_ingress_ptp_info", force_pipe_ttl_ingress_ptp_info.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(tunnel_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tunnel_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tunnel_type_and_force_pipe_ttl_ingress_ptp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tunnel_type_and_force_pipe_ttl_ingress_ptp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tx_to_rx_rcy_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 6, unscheduled_recycle_code.pack());
    bv.set_bits(5, 0, unscheduled_recycle_data);
    return bv;
}


void npl_tx_to_rx_rcy_data_t::unpack(bit_vector64_t bv) 
{
    unscheduled_recycle_code.unpack(bv.bits(7, 6));
    unscheduled_recycle_data = bv.bits(5, 0).get_value();
}



field_structure npl_tx_to_rx_rcy_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tx_to_rx_rcy_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("unscheduled_recycle_code", unscheduled_recycle_code.to_field_structure());
    fs_subfield.flat_value = to_hex_string(unscheduled_recycle_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("unscheduled_recycle_data", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_tx_to_rx_rcy_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tx_to_rx_rcy_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector npl_ud_key_t::pack(void) const 
{
    bit_vector bv(0, 4096);
    bv.set_bits(4095, 3968, udfs[31].pack());
    bv.set_bits(3967, 3840, udfs[30].pack());
    bv.set_bits(3839, 3712, udfs[29].pack());
    bv.set_bits(3711, 3584, udfs[28].pack());
    bv.set_bits(3583, 3456, udfs[27].pack());
    bv.set_bits(3455, 3328, udfs[26].pack());
    bv.set_bits(3327, 3200, udfs[25].pack());
    bv.set_bits(3199, 3072, udfs[24].pack());
    bv.set_bits(3071, 2944, udfs[23].pack());
    bv.set_bits(2943, 2816, udfs[22].pack());
    bv.set_bits(2815, 2688, udfs[21].pack());
    bv.set_bits(2687, 2560, udfs[20].pack());
    bv.set_bits(2559, 2432, udfs[19].pack());
    bv.set_bits(2431, 2304, udfs[18].pack());
    bv.set_bits(2303, 2176, udfs[17].pack());
    bv.set_bits(2175, 2048, udfs[16].pack());
    bv.set_bits(2047, 1920, udfs[15].pack());
    bv.set_bits(1919, 1792, udfs[14].pack());
    bv.set_bits(1791, 1664, udfs[13].pack());
    bv.set_bits(1663, 1536, udfs[12].pack());
    bv.set_bits(1535, 1408, udfs[11].pack());
    bv.set_bits(1407, 1280, udfs[10].pack());
    bv.set_bits(1279, 1152, udfs[9].pack());
    bv.set_bits(1151, 1024, udfs[8].pack());
    bv.set_bits(1023, 896, udfs[7].pack());
    bv.set_bits(895, 768, udfs[6].pack());
    bv.set_bits(767, 640, udfs[5].pack());
    bv.set_bits(639, 512, udfs[4].pack());
    bv.set_bits(511, 384, udfs[3].pack());
    bv.set_bits(383, 256, udfs[2].pack());
    bv.set_bits(255, 128, udfs[1].pack());
    bv.set_bits(127, 0, udfs[0].pack());
    return bv;
}


void npl_ud_key_t::unpack(bit_vector bv) 
{
    udfs[31].unpack(bv.bits(4095, 3968));
    udfs[30].unpack(bv.bits(3967, 3840));
    udfs[29].unpack(bv.bits(3839, 3712));
    udfs[28].unpack(bv.bits(3711, 3584));
    udfs[27].unpack(bv.bits(3583, 3456));
    udfs[26].unpack(bv.bits(3455, 3328));
    udfs[25].unpack(bv.bits(3327, 3200));
    udfs[24].unpack(bv.bits(3199, 3072));
    udfs[23].unpack(bv.bits(3071, 2944));
    udfs[22].unpack(bv.bits(2943, 2816));
    udfs[21].unpack(bv.bits(2815, 2688));
    udfs[20].unpack(bv.bits(2687, 2560));
    udfs[19].unpack(bv.bits(2559, 2432));
    udfs[18].unpack(bv.bits(2431, 2304));
    udfs[17].unpack(bv.bits(2303, 2176));
    udfs[16].unpack(bv.bits(2175, 2048));
    udfs[15].unpack(bv.bits(2047, 1920));
    udfs[14].unpack(bv.bits(1919, 1792));
    udfs[13].unpack(bv.bits(1791, 1664));
    udfs[12].unpack(bv.bits(1663, 1536));
    udfs[11].unpack(bv.bits(1535, 1408));
    udfs[10].unpack(bv.bits(1407, 1280));
    udfs[9].unpack(bv.bits(1279, 1152));
    udfs[8].unpack(bv.bits(1151, 1024));
    udfs[7].unpack(bv.bits(1023, 896));
    udfs[6].unpack(bv.bits(895, 768));
    udfs[5].unpack(bv.bits(767, 640));
    udfs[4].unpack(bv.bits(639, 512));
    udfs[3].unpack(bv.bits(511, 384));
    udfs[2].unpack(bv.bits(383, 256));
    udfs[1].unpack(bv.bits(255, 128));
    udfs[0].unpack(bv.bits(127, 0));
}



field_structure npl_ud_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ud_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("udfs[31]", udfs[31].to_field_structure());
    fs_result.subfields.emplace_back("udfs[30]", udfs[30].to_field_structure());
    fs_result.subfields.emplace_back("udfs[29]", udfs[29].to_field_structure());
    fs_result.subfields.emplace_back("udfs[28]", udfs[28].to_field_structure());
    fs_result.subfields.emplace_back("udfs[27]", udfs[27].to_field_structure());
    fs_result.subfields.emplace_back("udfs[26]", udfs[26].to_field_structure());
    fs_result.subfields.emplace_back("udfs[25]", udfs[25].to_field_structure());
    fs_result.subfields.emplace_back("udfs[24]", udfs[24].to_field_structure());
    fs_result.subfields.emplace_back("udfs[23]", udfs[23].to_field_structure());
    fs_result.subfields.emplace_back("udfs[22]", udfs[22].to_field_structure());
    fs_result.subfields.emplace_back("udfs[21]", udfs[21].to_field_structure());
    fs_result.subfields.emplace_back("udfs[20]", udfs[20].to_field_structure());
    fs_result.subfields.emplace_back("udfs[19]", udfs[19].to_field_structure());
    fs_result.subfields.emplace_back("udfs[18]", udfs[18].to_field_structure());
    fs_result.subfields.emplace_back("udfs[17]", udfs[17].to_field_structure());
    fs_result.subfields.emplace_back("udfs[16]", udfs[16].to_field_structure());
    fs_result.subfields.emplace_back("udfs[15]", udfs[15].to_field_structure());
    fs_result.subfields.emplace_back("udfs[14]", udfs[14].to_field_structure());
    fs_result.subfields.emplace_back("udfs[13]", udfs[13].to_field_structure());
    fs_result.subfields.emplace_back("udfs[12]", udfs[12].to_field_structure());
    fs_result.subfields.emplace_back("udfs[11]", udfs[11].to_field_structure());
    fs_result.subfields.emplace_back("udfs[10]", udfs[10].to_field_structure());
    fs_result.subfields.emplace_back("udfs[9]", udfs[9].to_field_structure());
    fs_result.subfields.emplace_back("udfs[8]", udfs[8].to_field_structure());
    fs_result.subfields.emplace_back("udfs[7]", udfs[7].to_field_structure());
    fs_result.subfields.emplace_back("udfs[6]", udfs[6].to_field_structure());
    fs_result.subfields.emplace_back("udfs[5]", udfs[5].to_field_structure());
    fs_result.subfields.emplace_back("udfs[4]", udfs[4].to_field_structure());
    fs_result.subfields.emplace_back("udfs[3]", udfs[3].to_field_structure());
    fs_result.subfields.emplace_back("udfs[2]", udfs[2].to_field_structure());
    fs_result.subfields.emplace_back("udfs[1]", udfs[1].to_field_structure());
    fs_result.subfields.emplace_back("udfs[0]", udfs[0].to_field_structure());
    return fs_result;
}
std::string to_string(npl_ud_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ud_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_unicast_flb_tm_header_padded_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 0, unicast_flb_tm_header.pack());
    return bv;
}


void npl_unicast_flb_tm_header_padded_t::unpack(bit_vector64_t bv) 
{
    unicast_flb_tm_header.unpack(bv.bits(23, 0));
}



field_structure npl_unicast_flb_tm_header_padded_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_unicast_flb_tm_header_padded_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("unicast_flb_tm_header", unicast_flb_tm_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_unicast_flb_tm_header_padded_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_unicast_flb_tm_header_padded_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_unicast_plb_tm_header_padded_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 0, unicast_plb_tm_header.pack());
    return bv;
}


void npl_unicast_plb_tm_header_padded_t::unpack(bit_vector64_t bv) 
{
    unicast_plb_tm_header.unpack(bv.bits(31, 0));
}



field_structure npl_unicast_plb_tm_header_padded_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_unicast_plb_tm_header_padded_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("unicast_plb_tm_header", unicast_plb_tm_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_unicast_plb_tm_header_padded_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_unicast_plb_tm_header_padded_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_g_t::pack(void) const // union
{
    bit_vector64_t bv(0, 48);
    { // union compound field start
        bit_vector64_t tbv = drop_green.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (drop_green_u != 0) {  // union primitive field start
        bv.set_bits(47, 0, drop_green_u);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_g_t::unpack(bit_vector64_t bv) // union
{
    drop_green.unpack(bv.bits(47, 0));
}



field_structure npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_g_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_g_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = drop_green.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("drop_green", drop_green.to_field_structure());
        }
    } // union compound field end
    
    if (drop_green_u != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(drop_green_u);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_g_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_g_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_y_t::pack(void) const // union
{
    bit_vector64_t bv(0, 48);
    { // union compound field start
        bit_vector64_t tbv = drop_yellow.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (drop_yellow_u != 0) {  // union primitive field start
        bv.set_bits(47, 0, drop_yellow_u);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_y_t::unpack(bit_vector64_t bv) // union
{
    drop_yellow.unpack(bv.bits(47, 0));
}



field_structure npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_y_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_y_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = drop_yellow.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("drop_yellow", drop_yellow.to_field_structure());
        }
    } // union compound field end
    
    if (drop_yellow_u != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(drop_yellow_u);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_y_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_drop_y_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_g_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    { // union compound field start
        bit_vector64_t tbv = mark_green.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (mark_green_u != 0) {  // union primitive field start
        bv.set_bits(31, 0, mark_green_u);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_g_t::unpack(bit_vector64_t bv) // union
{
    mark_green.unpack(bv.bits(31, 0));
}



field_structure npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_g_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_g_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = mark_green.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mark_green", mark_green.to_field_structure());
        }
    } // union compound field end
    
    if (mark_green_u != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mark_green_u);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_g_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_g_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_y_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    { // union compound field start
        bit_vector64_t tbv = mark_yellow.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (mark_yellow_u != 0) {  // union primitive field start
        bv.set_bits(31, 0, mark_yellow_u);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_y_t::unpack(bit_vector64_t bv) // union
{
    mark_yellow.unpack(bv.bits(31, 0));
}



field_structure npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_y_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_y_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = mark_yellow.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mark_yellow", mark_yellow.to_field_structure());
        }
    } // union compound field end
    
    if (mark_yellow_u != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(mark_yellow_u);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_y_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t_anonymous_union_mark_y_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_additional_labels_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 100, label_3);
    bv.set_bits(99, 80, label_4);
    bv.set_bits(79, 60, label_5);
    bv.set_bits(59, 40, label_6);
    bv.set_bits(39, 20, label_7);
    bv.set_bits(19, 0, label_8_or_num_labels.pack());
    return bv;
}


void npl_additional_labels_t::unpack(bit_vector128_t bv) 
{
    label_3 = bv.bits(119, 100).get_value();
    label_4 = bv.bits(99, 80).get_value();
    label_5 = bv.bits(79, 60).get_value();
    label_6 = bv.bits(59, 40).get_value();
    label_7 = bv.bits(39, 20).get_value();
    label_8_or_num_labels.unpack(bv.bits(19, 0));
}



field_structure npl_additional_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_additional_labels_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(label_3);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_3", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_4);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_4", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_5);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_5", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_6);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_6", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(label_7);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("label_7", fs_subfield);
    
    fs_result.subfields.emplace_back("label_8_or_num_labels", label_8_or_num_labels.to_field_structure());
    return fs_result;
}
std::string to_string(npl_additional_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_additional_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_bfd_aux_shared_payload_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 88, local_discriminator);
    bv.set_bits(87, 56, remote_discriminator);
    bv.set_bits(55, 48, tos);
    bv.set_bits(47, 43, local_diag_code);
    bv.set_bits(42, 42, requires_inject_up);
    bv.set_bits(41, 40, session_type);
    bv.set_bits(39, 0, prot_shared.pack());
    return bv;
}


void npl_bfd_aux_shared_payload_t::unpack(bit_vector128_t bv) 
{
    local_discriminator = bv.bits(119, 88).get_value();
    remote_discriminator = bv.bits(87, 56).get_value();
    tos = bv.bits(55, 48).get_value();
    local_diag_code = bv.bits(47, 43).get_value();
    requires_inject_up = bv.bits(42, 42).get_value();
    session_type = (npl_bfd_session_type_e)bv.bits(41, 40).get_value();
    prot_shared.unpack(bv.bits(39, 0));
}



field_structure npl_bfd_aux_shared_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_shared_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(local_discriminator);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("local_discriminator", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(remote_discriminator);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("remote_discriminator", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(local_diag_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("local_diag_code", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(requires_inject_up);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("requires_inject_up", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(session_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("session_type", fs_subfield);
    
    fs_result.subfields.emplace_back("prot_shared", prot_shared.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_aux_shared_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_shared_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_em_lookup_t::pack(void) const 
{
    bit_vector64_t bv(0, 44);
    bv.set_bits(43, 43, encap_result);
    // PADDING -  bv.set_bits(42, 40, padding);
    bv.set_bits(39, 36, meter);
    bv.set_bits(35, 16, destination);
    bv.set_bits(15, 0, punt_encap_data.pack());
    return bv;
}


void npl_bfd_em_lookup_t::unpack(bit_vector64_t bv) 
{
    encap_result = bv.bits(43, 43).get_value();
    // PADDING -  padding = bv.bits(42, 40).get_value();
    meter = bv.bits(39, 36).get_value();
    destination = bv.bits(35, 16).get_value();
    punt_encap_data.unpack(bv.bits(15, 0));
}



field_structure npl_bfd_em_lookup_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_em_lookup_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(encap_result);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("encap_result", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(meter);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(destination);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("destination", fs_subfield);
    
    fs_result.subfields.emplace_back("punt_encap_data", punt_encap_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_em_lookup_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_em_lookup_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_flags_state_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 6, state);
    bv.set_bits(5, 0, bfd_flags.pack());
    return bv;
}


void npl_bfd_flags_state_t::unpack(bit_vector64_t bv) 
{
    state = bv.bits(7, 6).get_value();
    bfd_flags.unpack(bv.bits(5, 0));
}



field_structure npl_bfd_flags_state_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_flags_state_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(state);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("state", fs_subfield);
    
    fs_result.subfields.emplace_back("bfd_flags", bfd_flags.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_flags_state_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_flags_state_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_remote_session_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 16, last_time);
    // PADDING -  bv.set_bits(15, 13, padding);
    bv.set_bits(12, 5, remote_info.pack());
    bv.set_bits(4, 1, rmep_profile);
    bv.set_bits(0, 0, rmep_valid);
    return bv;
}


void npl_bfd_remote_session_attributes_t::unpack(bit_vector64_t bv) 
{
    last_time = bv.bits(47, 16).get_value();
    // PADDING -  padding = bv.bits(15, 13).get_value();
    remote_info.unpack(bv.bits(12, 5));
    rmep_profile = bv.bits(4, 1).get_value();
    rmep_valid = bv.bits(0, 0).get_value();
}



field_structure npl_bfd_remote_session_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_remote_session_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(last_time);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("last_time", fs_subfield);
    
    
    fs_result.subfields.emplace_back("remote_info", remote_info.to_field_structure());
    fs_subfield.flat_value = to_hex_string(rmep_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_profile", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(rmep_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rmep_valid", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_bfd_remote_session_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_remote_session_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_cntr_offset_and_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, cntr_offset.pack());
    return bv;
}


void npl_common_cntr_offset_and_padding_t::unpack(bit_vector64_t bv) 
{
    cntr_offset.unpack(bv.bits(3, 0));
}



field_structure npl_common_cntr_offset_and_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_cntr_offset_and_padding_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("cntr_offset", cntr_offset.to_field_structure());
    return fs_result;
}
std::string to_string(npl_common_cntr_offset_and_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_cntr_offset_and_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_common_cntr_offset_packed_t::pack(void) const 
{
    bit_vector64_t bv(0, 4);
    bv.set_bits(3, 0, cntr_offset.pack());
    return bv;
}


void npl_common_cntr_offset_packed_t::unpack(bit_vector64_t bv) 
{
    cntr_offset.unpack(bv.bits(3, 0));
}



field_structure npl_common_cntr_offset_packed_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_common_cntr_offset_packed_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("cntr_offset", cntr_offset.to_field_structure());
    return fs_result;
}
std::string to_string(npl_common_cntr_offset_packed_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_common_cntr_offset_packed_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dlp_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 7);
    bv.set_bits(6, 3, acl_drop_offset.pack());
    bv.set_bits(2, 1, lp_profile);
    bv.set_bits(0, 0, port_mirror_type);
    return bv;
}


void npl_dlp_attributes_t::unpack(bit_vector64_t bv) 
{
    acl_drop_offset.unpack(bv.bits(6, 3));
    lp_profile = bv.bits(2, 1).get_value();
    port_mirror_type = (npl_port_mirror_type_e)bv.bits(0, 0).get_value();
}



field_structure npl_dlp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dlp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("acl_drop_offset", acl_drop_offset.to_field_structure());
    fs_subfield.flat_value = to_hex_string(lp_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_profile", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(port_mirror_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("port_mirror_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_dlp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dlp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_dlp_profile_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (data != 0) {  // union primitive field start
        bv.set_bits(7, 0, data);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = overload_union_user_app_data_defined.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_dlp_profile_union_t::unpack(bit_vector64_t bv) // union
{
    data = bv.bits(7, 0).get_value();
}



field_structure npl_dlp_profile_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_dlp_profile_union_t";
    field_structure fs_subfield;
    //add members to result
    if (data != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(data);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = overload_union_user_app_data_defined.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("overload_union_user_app_data_defined", overload_union_user_app_data_defined.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_dlp_profile_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_dlp_profile_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_ipv6_acl_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 0, sec.pack());
    return bv;
}


void npl_egress_ipv6_acl_result_t::unpack(bit_vector64_t bv) 
{
    sec.unpack(bv.bits(23, 0));
}



field_structure npl_egress_ipv6_acl_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_ipv6_acl_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("sec", sec.to_field_structure());
    return fs_result;
}
std::string to_string(npl_egress_ipv6_acl_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_ipv6_acl_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_egress_qos_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 31);
    bv.set_bits(30, 28, fwd_remark_exp);
    bv.set_bits(27, 27, remark_l2);
    bv.set_bits(26, 26, remark_l3.pack());
    bv.set_bits(25, 22, q_offset.pack());
    bv.set_bits(21, 16, fwd_remark_dscp);
    bv.set_bits(15, 0, encap.pack());
    return bv;
}


void npl_egress_qos_result_t::unpack(bit_vector64_t bv) 
{
    fwd_remark_exp = bv.bits(30, 28).get_value();
    remark_l2 = bv.bits(27, 27).get_value();
    remark_l3.unpack(bv.bits(26, 26));
    q_offset.unpack(bv.bits(25, 22));
    fwd_remark_dscp = bv.bits(21, 16).get_value();
    encap.unpack(bv.bits(15, 0));
}



field_structure npl_egress_qos_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_egress_qos_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(fwd_remark_exp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_remark_exp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(remark_l2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("remark_l2", fs_subfield);
    
    fs_result.subfields.emplace_back("remark_l3", remark_l3.to_field_structure());
    fs_result.subfields.emplace_back("q_offset", q_offset.to_field_structure());
    fs_subfield.flat_value = to_hex_string(fwd_remark_dscp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_remark_dscp", fs_subfield);
    
    fs_result.subfields.emplace_back("encap", encap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_egress_qos_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_egress_qos_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_inject_down_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 0, ene_inject_down_payload.pack());
    return bv;
}


void npl_ene_inject_down_header_t::unpack(bit_vector64_t bv) 
{
    ene_inject_down_payload.unpack(bv.bits(27, 0));
}



field_structure npl_ene_inject_down_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_inject_down_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ene_inject_down_payload", ene_inject_down_payload.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ene_inject_down_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_inject_down_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_sub_code_and_dsp_and_ssp_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    // PADDING -  bv.set_bits(39, 36, padding);
    bv.set_bits(35, 32, ene_punt_sub_code.pack());
    bv.set_bits(31, 0, ene_punt_dsp_and_ssp.pack());
    return bv;
}


void npl_ene_punt_sub_code_and_dsp_and_ssp_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(39, 36).get_value();
    ene_punt_sub_code.unpack(bv.bits(35, 32));
    ene_punt_dsp_and_ssp.unpack(bv.bits(31, 0));
}



field_structure npl_ene_punt_sub_code_and_dsp_and_ssp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_sub_code_and_dsp_and_ssp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("ene_punt_sub_code", ene_punt_sub_code.to_field_structure());
    fs_result.subfields.emplace_back("ene_punt_dsp_and_ssp", ene_punt_dsp_and_ssp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ene_punt_sub_code_and_dsp_and_ssp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_sub_code_and_dsp_and_ssp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ethernet_header_t::pack(void) const 
{
    bit_vector128_t bv(0, 112);
    bv.set_bits(111, 16, mac_addr.pack());
    bv.set_bits(15, 0, ether_type_or_tpid);
    return bv;
}


void npl_ethernet_header_t::unpack(bit_vector128_t bv) 
{
    mac_addr.unpack(bv.bits(111, 16));
    ether_type_or_tpid = bv.bits(15, 0).get_value();
}



field_structure npl_ethernet_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ethernet_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mac_addr", mac_addr.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ether_type_or_tpid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ether_type_or_tpid", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ethernet_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ethernet_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_fi_core_tcam_assoc_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 54);
    bv.set_bits(53, 48, next_macro);
    bv.set_bits(47, 47, last_macro);
    bv.set_bits(46, 46, start_new_header);
    bv.set_bits(45, 45, start_new_layer);
    bv.set_bits(44, 44, advance_data);
    bv.set_bits(43, 36, tcam_mask_alu_header_format.pack());
    bv.set_bits(35, 30, tcam_mask_alu_header_size);
    bv.set_bits(29, 29, tcam_mask_hw_logic_advance_data);
    bv.set_bits(28, 28, tcam_mask_hw_logic_last_macro);
    bv.set_bits(27, 20, tcam_mask_hw_logic_header_format.pack());
    bv.set_bits(19, 14, tcam_mask_hw_logic_header_size);
    bv.set_bits(13, 6, header_format.pack());
    bv.set_bits(5, 0, header_size);
    return bv;
}


void npl_fi_core_tcam_assoc_data_t::unpack(bit_vector64_t bv) 
{
    next_macro = bv.bits(53, 48).get_value();
    last_macro = bv.bits(47, 47).get_value();
    start_new_header = bv.bits(46, 46).get_value();
    start_new_layer = bv.bits(45, 45).get_value();
    advance_data = bv.bits(44, 44).get_value();
    tcam_mask_alu_header_format.unpack(bv.bits(43, 36));
    tcam_mask_alu_header_size = bv.bits(35, 30).get_value();
    tcam_mask_hw_logic_advance_data = bv.bits(29, 29).get_value();
    tcam_mask_hw_logic_last_macro = bv.bits(28, 28).get_value();
    tcam_mask_hw_logic_header_format.unpack(bv.bits(27, 20));
    tcam_mask_hw_logic_header_size = bv.bits(19, 14).get_value();
    header_format.unpack(bv.bits(13, 6));
    header_size = bv.bits(5, 0).get_value();
}



field_structure npl_fi_core_tcam_assoc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_fi_core_tcam_assoc_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(next_macro);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("next_macro", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(last_macro);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("last_macro", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(start_new_header);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("start_new_header", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(start_new_layer);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("start_new_layer", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(advance_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("advance_data", fs_subfield);
    
    fs_result.subfields.emplace_back("tcam_mask_alu_header_format", tcam_mask_alu_header_format.to_field_structure());
    fs_subfield.flat_value = to_hex_string(tcam_mask_alu_header_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_mask_alu_header_size", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tcam_mask_hw_logic_advance_data);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_mask_hw_logic_advance_data", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(tcam_mask_hw_logic_last_macro);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_mask_hw_logic_last_macro", fs_subfield);
    
    fs_result.subfields.emplace_back("tcam_mask_hw_logic_header_format", tcam_mask_hw_logic_header_format.to_field_structure());
    fs_subfield.flat_value = to_hex_string(tcam_mask_hw_logic_header_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("tcam_mask_hw_logic_header_size", fs_subfield);
    
    fs_result.subfields.emplace_back("header_format", header_format.to_field_structure());
    fs_subfield.flat_value = to_hex_string(header_size);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("header_size", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_fi_core_tcam_assoc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_fi_core_tcam_assoc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector npl_flc_payload_t::pack(void) const 
{
    bit_vector bv(0, 642);
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 258;
        size_t max_msb = lsb + 384 - 1;
        size_t msb = 0;
        const uint64_t * p = npu_header;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    bv.set_bits(257, 0, rxpp_pd.pack());
    return bv;
}


void npl_flc_payload_t::unpack(bit_vector bv) 
{
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 258;
        size_t max_msb = lsb + 384 - 1;
        size_t msb = 0;
        uint64_t * p = npu_header;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    rxpp_pd.unpack(bv.bits(257, 0));
}



field_structure npl_flc_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_flc_payload_t";
    field_structure fs_subfield;
    //add members to result
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 258;
        size_t max_msb = lsb + 384 - 1;
        size_t msb = 0;
        const uint64_t * p = npu_header;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    fs_result.subfields.emplace_back("rxpp_pd", rxpp_pd.to_field_structure());
    return fs_result;
}
std::string to_string(npl_flc_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_flc_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_lpts_og_app_config_t::pack(void) const 
{
    bit_vector64_t bv(0, 14);
    bv.set_bits(13, 9, app_data.pack());
    bv.set_bits(8, 0, src.pack());
    return bv;
}


void npl_ingress_lpts_og_app_config_t::unpack(bit_vector64_t bv) 
{
    app_data.unpack(bv.bits(13, 9));
    src.unpack(bv.bits(8, 0));
}



field_structure npl_ingress_lpts_og_app_config_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_lpts_og_app_config_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("app_data", app_data.to_field_structure());
    fs_result.subfields.emplace_back("src", src.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ingress_lpts_og_app_config_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_lpts_og_app_config_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_acl_result_t_anonymous_union_ctr_offest_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 5);
    { // union compound field start
        bit_vector64_t tbv = q_m_offset_5bits.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(4, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = q_m_offset.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(3, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ingress_qos_acl_result_t_anonymous_union_ctr_offest_union_t::unpack(bit_vector64_t bv) // union
{
    q_m_offset_5bits.unpack(bv.bits(4, 0));
}



field_structure npl_ingress_qos_acl_result_t_anonymous_union_ctr_offest_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_acl_result_t_anonymous_union_ctr_offest_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = q_m_offset_5bits.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("q_m_offset_5bits", q_m_offset_5bits.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = q_m_offset.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("q_m_offset", q_m_offset.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_acl_result_t_anonymous_union_ctr_offest_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_acl_result_t_anonymous_union_ctr_offest_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_result_t_anonymous_union_ctr_offest_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 5);
    { // union compound field start
        bit_vector64_t tbv = q_m_offset_5bits.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(4, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = q_m_offset.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(3, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ingress_qos_result_t_anonymous_union_ctr_offest_union_t::unpack(bit_vector64_t bv) // union
{
    q_m_offset_5bits.unpack(bv.bits(4, 0));
}



field_structure npl_ingress_qos_result_t_anonymous_union_ctr_offest_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_result_t_anonymous_union_ctr_offest_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = q_m_offset_5bits.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("q_m_offset_5bits", q_m_offset_5bits.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = q_m_offset.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("q_m_offset", q_m_offset.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_result_t_anonymous_union_ctr_offest_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_result_t_anonymous_union_ctr_offest_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_initial_pd_nw_rx_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 40, init_data.pack());
    bv.set_bits(39, 36, initial_mapping_type);
    // PADDING -  bv.set_bits(35, 35, padding);
    bv.set_bits(34, 34, initial_is_rcy_if);
    bv.set_bits(33, 33, pfc_enable);
    bv.set_bits(32, 32, initial_mac_lp_type);
    bv.set_bits(31, 28, initial_lp_type);
    bv.set_bits(27, 24, initial_vlan_profile);
    bv.set_bits(23, 4, mapping_key.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_initial_pd_nw_rx_data_t::unpack(bit_vector64_t bv) 
{
    init_data.unpack(bv.bits(47, 40));
    initial_mapping_type = (npl_mac_mapping_type_e)bv.bits(39, 36).get_value();
    // PADDING -  padding = bv.bits(35, 35).get_value();
    initial_is_rcy_if = bv.bits(34, 34).get_value();
    pfc_enable = bv.bits(33, 33).get_value();
    initial_mac_lp_type = (npl_mac_lp_type_e)bv.bits(32, 32).get_value();
    initial_lp_type = (npl_l2_lp_type_e)bv.bits(31, 28).get_value();
    initial_vlan_profile = bv.bits(27, 24).get_value();
    mapping_key.unpack(bv.bits(23, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_initial_pd_nw_rx_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_initial_pd_nw_rx_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("init_data", init_data.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(initial_mapping_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_mapping_type", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(initial_is_rcy_if);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_is_rcy_if", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pfc_enable);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pfc_enable", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(initial_mac_lp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_mac_lp_type", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(initial_lp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_lp_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(initial_vlan_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("initial_vlan_profile", fs_subfield);
    
    fs_result.subfields.emplace_back("mapping_key", mapping_key.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_initial_pd_nw_rx_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_initial_pd_nw_rx_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_header_t_anonymous_union_ts_and_cntr_stamp_cmd_t::pack(void) const // union
{
    bit_vector64_t bv(0, 24);
    { // union compound field start
        bit_vector64_t tbv = time_and_cntr_stamp_cmd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_header_t_anonymous_union_ts_and_cntr_stamp_cmd_t::unpack(bit_vector64_t bv) // union
{
    time_and_cntr_stamp_cmd.unpack(bv.bits(23, 0));
}



field_structure npl_inject_header_t_anonymous_union_ts_and_cntr_stamp_cmd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_t_anonymous_union_ts_and_cntr_stamp_cmd_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = time_and_cntr_stamp_cmd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("time_and_cntr_stamp_cmd", time_and_cntr_stamp_cmd.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_header_t_anonymous_union_ts_and_cntr_stamp_cmd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_t_anonymous_union_ts_and_cntr_stamp_cmd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_specific_data_t_anonymous_union_inject_data_t_anonymous_union_inject_down_u_t::pack(void) const // union
{
    bit_vector64_t bv(0, 28);
    { // union compound field start
        bit_vector64_t tbv = inject_down.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ene_inject_down.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_specific_data_t_anonymous_union_inject_data_t_anonymous_union_inject_down_u_t::unpack(bit_vector64_t bv) // union
{
    inject_down.unpack(bv.bits(27, 0));
}



field_structure npl_inject_specific_data_t_anonymous_union_inject_data_t_anonymous_union_inject_down_u_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_specific_data_t_anonymous_union_inject_data_t_anonymous_union_inject_down_u_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = inject_down.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_down", inject_down.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ene_inject_down.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ene_inject_down", ene_inject_down.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_specific_data_t_anonymous_union_inject_data_t_anonymous_union_inject_down_u_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_specific_data_t_anonymous_union_inject_data_t_anonymous_union_inject_down_u_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_eth_header_t_anonymous_union_qos_or_dest_t::pack(void) const // union
{
    bit_vector64_t bv(0, 24);
    { // union compound field start
        bit_vector64_t tbv = inject_up_qos.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_up_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_up_eth_header_t_anonymous_union_qos_or_dest_t::unpack(bit_vector64_t bv) // union
{
    inject_up_qos.unpack(bv.bits(23, 0));
}



field_structure npl_inject_up_eth_header_t_anonymous_union_qos_or_dest_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_eth_header_t_anonymous_union_qos_or_dest_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = inject_up_qos.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_up_qos", inject_up_qos.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_up_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_up_dest", inject_up_dest.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_up_eth_header_t_anonymous_union_qos_or_dest_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_eth_header_t_anonymous_union_qos_or_dest_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ip_encap_data_t_anonymous_union_ip_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = v4.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = v6.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ip_encap_data_t_anonymous_union_ip_t::unpack(bit_vector128_t bv) // union
{
    v4.unpack(bv.bits(79, 0));
}



field_structure npl_ip_encap_data_t_anonymous_union_ip_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_encap_data_t_anonymous_union_ip_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = v4.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("v4", v4.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = v6.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("v6", v6.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ip_encap_data_t_anonymous_union_ip_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_encap_data_t_anonymous_union_ip_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_sgt_em_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 63, result_type);
    // PADDING -  bv.set_bits(62, 62, padding);
    bv.set_bits(61, 0, result.pack());
    return bv;
}


void npl_ip_sgt_em_result_t::unpack(bit_vector64_t bv) 
{
    result_type = (npl_ip_uc_em_result_type_e)bv.bits(63, 63).get_value();
    // PADDING -  padding = bv.bits(62, 62).get_value();
    result.unpack(bv.bits(61, 0));
}



field_structure npl_ip_sgt_em_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_sgt_em_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(result_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("result_type", fs_subfield);
    
    
    fs_result.subfields.emplace_back("result", result.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_sgt_em_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_sgt_em_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ive_profile_and_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 26, main_type);
    bv.set_bits(25, 14, secondary_type_or_vid_2.pack());
    bv.set_bits(13, 12, prf);
    bv.set_bits(11, 0, vid1);
    return bv;
}


void npl_ive_profile_and_data_t::unpack(bit_vector64_t bv) 
{
    main_type = (npl_vlan_edit_command_main_type_e)bv.bits(27, 26).get_value();
    secondary_type_or_vid_2.unpack(bv.bits(25, 14));
    prf = bv.bits(13, 12).get_value();
    vid1 = bv.bits(11, 0).get_value();
}



field_structure npl_ive_profile_and_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ive_profile_and_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(main_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("main_type", fs_subfield);
    
    fs_result.subfields.emplace_back("secondary_type_or_vid_2", secondary_type_or_vid_2.to_field_structure());
    fs_subfield.flat_value = to_hex_string(prf);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prf", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(vid1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vid1", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ive_profile_and_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ive_profile_and_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_relay_id_or_l3_attr_t::pack(void) const // union
{
    bit_vector64_t bv(0, 14);
    { // union compound field start
        bit_vector64_t tbv = relay_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(13, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_lp_additional_attributes.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(10, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (l2_vpn_pwe_id != 0) {  // union primitive field start
        bv.set_bits(13, 0, l2_vpn_pwe_id);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_l2_relay_id_or_l3_attr_t::unpack(bit_vector64_t bv) // union
{
    relay_id.unpack(bv.bits(13, 0));
}



field_structure npl_l2_relay_id_or_l3_attr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_relay_id_or_l3_attr_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = relay_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("relay_id", relay_id.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_lp_additional_attributes.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_lp_additional_attributes", l3_lp_additional_attributes.to_field_structure());
        }
    } // union compound field end
    
    if (l2_vpn_pwe_id != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(l2_vpn_pwe_id);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_l2_relay_id_or_l3_attr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_relay_id_or_l3_attr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_l3_dlp_attributes_t_anonymous_union_l3_dlp_encap_or_te_labels_t::pack(void) const // union
{
    bit_vector128_t bv(0, 72);
    { // union compound field start
        bit_vector128_t tbv = l3_dlp_encap.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ldp_over_te_tunnel_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_l3_dlp_attributes_t_anonymous_union_l3_dlp_encap_or_te_labels_t::unpack(bit_vector128_t bv) // union
{
    l3_dlp_encap.unpack(bv.bits(71, 0));
}



field_structure npl_l3_dlp_attributes_t_anonymous_union_l3_dlp_encap_or_te_labels_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_attributes_t_anonymous_union_l3_dlp_encap_or_te_labels_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = l3_dlp_encap.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_dlp_encap", l3_dlp_encap.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ldp_over_te_tunnel_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ldp_over_te_tunnel_data", ldp_over_te_tunnel_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_l3_dlp_attributes_t_anonymous_union_l3_dlp_encap_or_te_labels_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_attributes_t_anonymous_union_l3_dlp_encap_or_te_labels_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_dlp_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 9);
    bv.set_bits(8, 7, l3_ecn_ctrl.pack());
    bv.set_bits(6, 0, dlp_attributes.pack());
    return bv;
}


void npl_l3_dlp_info_t::unpack(bit_vector64_t bv) 
{
    l3_ecn_ctrl.unpack(bv.bits(8, 7));
    dlp_attributes.unpack(bv.bits(6, 0));
}



field_structure npl_l3_dlp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_ecn_ctrl", l3_ecn_ctrl.to_field_structure());
    fs_result.subfields.emplace_back("dlp_attributes", dlp_attributes.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_dlp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_dlp_qos_and_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 57);
    bv.set_bits(56, 48, l3_dlp_info.pack());
    bv.set_bits(47, 46, qos_counter_comp);
    bv.set_bits(45, 0, qos_attributes.pack());
    return bv;
}


void npl_l3_dlp_qos_and_attributes_t::unpack(bit_vector64_t bv) 
{
    l3_dlp_info.unpack(bv.bits(56, 48));
    qos_counter_comp = (npl_tx_counter_compensation_e)bv.bits(47, 46).get_value();
    qos_attributes.unpack(bv.bits(45, 0));
}



field_structure npl_l3_dlp_qos_and_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_qos_and_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp_info", l3_dlp_info.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(qos_counter_comp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("qos_counter_comp", fs_subfield);
    
    fs_result.subfields.emplace_back("qos_attributes", qos_attributes.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_dlp_qos_and_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_qos_and_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_global_slp_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 14, padding);
    bv.set_bits(13, 0, id.pack());
    return bv;
}


void npl_l3_global_slp_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 14).get_value();
    id.unpack(bv.bits(13, 0));
}



field_structure npl_l3_global_slp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_global_slp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("id", id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_global_slp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_global_slp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_label_or_more_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    if (label != 0) {  // union primitive field start
        bv.set_bits(19, 0, label);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = more.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_label_or_more_t::unpack(bit_vector64_t bv) // union
{
    label = bv.bits(19, 0).get_value();
}



field_structure npl_label_or_more_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_label_or_more_t";
    field_structure fs_subfield;
    //add members to result
    if (label != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(label);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = more.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("more", more.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_label_or_more_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_label_or_more_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lpts_tcam_first_result_encap_data_msb_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 8, encap_punt_code.pack());
    bv.set_bits(7, 4, ingress_punt_src);
    bv.set_bits(3, 0, punt_sub_code.pack());
    return bv;
}


void npl_lpts_tcam_first_result_encap_data_msb_t::unpack(bit_vector64_t bv) 
{
    encap_punt_code.unpack(bv.bits(15, 8));
    ingress_punt_src = (npl_punt_source_e)bv.bits(7, 4).get_value();
    punt_sub_code.unpack(bv.bits(3, 0));
}



field_structure npl_lpts_tcam_first_result_encap_data_msb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lpts_tcam_first_result_encap_data_msb_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("encap_punt_code", encap_punt_code.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(ingress_punt_src);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ingress_punt_src", fs_subfield);
    
    fs_result.subfields.emplace_back("punt_sub_code", punt_sub_code.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lpts_tcam_first_result_encap_data_msb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lpts_tcam_first_result_encap_data_msb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_labels_opt1_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 20, labels_0_1.pack());
    bv.set_bits(19, 0, label_2_or_more.pack());
    return bv;
}


void npl_lsp_labels_opt1_t::unpack(bit_vector64_t bv) 
{
    labels_0_1.unpack(bv.bits(59, 20));
    label_2_or_more.unpack(bv.bits(19, 0));
}



field_structure npl_lsp_labels_opt1_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_labels_opt1_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("labels_0_1", labels_0_1.to_field_structure());
    fs_result.subfields.emplace_back("label_2_or_more", label_2_or_more.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lsp_labels_opt1_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_labels_opt1_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_attributes_inf_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 59);
    bv.set_bits(58, 48, l3_lp_additional_attributes.pack());
    bv.set_bits(47, 14, mac_l2_relay_attributes.pack());
    bv.set_bits(13, 0, l2_relay_id_or_l3_attr_u.pack());
    return bv;
}


void npl_mac_relay_attributes_inf_payload_t::unpack(bit_vector64_t bv) 
{
    l3_lp_additional_attributes.unpack(bv.bits(58, 48));
    mac_l2_relay_attributes.unpack(bv.bits(47, 14));
    l2_relay_id_or_l3_attr_u.unpack(bv.bits(13, 0));
}



field_structure npl_mac_relay_attributes_inf_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_attributes_inf_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_lp_additional_attributes", l3_lp_additional_attributes.to_field_structure());
    fs_result.subfields.emplace_back("mac_l2_relay_attributes", mac_l2_relay_attributes.to_field_structure());
    fs_result.subfields.emplace_back("l2_relay_id_or_l3_attr_u", l2_relay_id_or_l3_attr_u.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_relay_attributes_inf_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_attributes_inf_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 14, payload.pack());
    bv.set_bits(13, 0, l2_relay_id_or_l3_attr_u.pack());
    return bv;
}


void npl_mac_relay_attributes_t::unpack(bit_vector64_t bv) 
{
    payload.unpack(bv.bits(47, 14));
    l2_relay_id_or_l3_attr_u.unpack(bv.bits(13, 0));
}



field_structure npl_mac_relay_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("payload", payload.to_field_structure());
    fs_result.subfields.emplace_back("l2_relay_id_or_l3_attr_u", l2_relay_id_or_l3_attr_u.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_relay_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mc_em_db_result_tx_t::pack(void) const 
{
    bit_vector128_t bv(0, 72);
    bv.set_bits(71, 1, format_0_or_1.pack());
    bv.set_bits(0, 0, format);
    return bv;
}


void npl_mc_em_db_result_tx_t::unpack(bit_vector128_t bv) 
{
    format_0_or_1.unpack(bv.bits(71, 1));
    format = bv.bits(0, 0).get_value();
}



field_structure npl_mc_em_db_result_tx_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_tx_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("format_0_or_1", format_0_or_1.to_field_structure());
    fs_subfield.flat_value = to_hex_string(format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("format", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_tx_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_tx_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_minimal_l3_lp_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 44, l3_relay_id.pack());
    bv.set_bits(43, 24, p_counter.pack());
    bv.set_bits(23, 8, global_slp_id.pack());
    bv.set_bits(7, 7, disable_ipv4_uc);
    bv.set_bits(6, 6, ttl_mode);
    bv.set_bits(5, 5, per_protocol_count);
    bv.set_bits(4, 4, lp_set);
    bv.set_bits(3, 3, disable_ipv6_mc);
    bv.set_bits(2, 2, disable_ipv4_mc);
    bv.set_bits(1, 1, disable_mpls_or_mc_tunnel.pack());
    bv.set_bits(0, 0, disable_ipv6_uc);
    return bv;
}


void npl_minimal_l3_lp_attributes_t::unpack(bit_vector64_t bv) 
{
    l3_relay_id.unpack(bv.bits(55, 44));
    p_counter.unpack(bv.bits(43, 24));
    global_slp_id.unpack(bv.bits(23, 8));
    disable_ipv4_uc = bv.bits(7, 7).get_value();
    ttl_mode = (npl_ttl_mode_e)bv.bits(6, 6).get_value();
    per_protocol_count = bv.bits(5, 5).get_value();
    lp_set = bv.bits(4, 4).get_value();
    disable_ipv6_mc = bv.bits(3, 3).get_value();
    disable_ipv4_mc = bv.bits(2, 2).get_value();
    disable_mpls_or_mc_tunnel.unpack(bv.bits(1, 1));
    disable_ipv6_uc = bv.bits(0, 0).get_value();
}



field_structure npl_minimal_l3_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_minimal_l3_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_relay_id", l3_relay_id.to_field_structure());
    fs_result.subfields.emplace_back("p_counter", p_counter.to_field_structure());
    fs_result.subfields.emplace_back("global_slp_id", global_slp_id.to_field_structure());
    fs_subfield.flat_value = to_hex_string(disable_ipv4_uc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disable_ipv4_uc", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ttl_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ttl_mode", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(per_protocol_count);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("per_protocol_count", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lp_set);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_set", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(disable_ipv6_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disable_ipv6_mc", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(disable_ipv4_mc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disable_ipv4_mc", fs_subfield);
    
    fs_result.subfields.emplace_back("disable_mpls_or_mc_tunnel", disable_mpls_or_mc_tunnel.to_field_structure());
    fs_subfield.flat_value = to_hex_string(disable_ipv6_uc);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disable_ipv6_uc", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_minimal_l3_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_minimal_l3_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mmm_tm_header_padded_t::pack(void) const 
{
    bit_vector64_t bv(0, 24);
    bv.set_bits(23, 0, mmm_tm_header.pack());
    return bv;
}


void npl_mmm_tm_header_padded_t::unpack(bit_vector64_t bv) 
{
    mmm_tm_header.unpack(bv.bits(23, 0));
}



field_structure npl_mmm_tm_header_padded_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mmm_tm_header_padded_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mmm_tm_header", mmm_tm_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mmm_tm_header_padded_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mmm_tm_header_padded_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_l3vpn_t_anonymous_union_vpn_mldp_info_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    { // union compound field start
        bit_vector64_t tbv = mldp_info.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vpn_info.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mpls_termination_l3vpn_t_anonymous_union_vpn_mldp_info_t::unpack(bit_vector64_t bv) // union
{
    mldp_info.unpack(bv.bits(15, 0));
}



field_structure npl_mpls_termination_l3vpn_t_anonymous_union_vpn_mldp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_l3vpn_t_anonymous_union_vpn_mldp_info_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = mldp_info.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mldp_info", mldp_info.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vpn_info.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("vpn_info", vpn_info.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mpls_termination_l3vpn_t_anonymous_union_vpn_mldp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_l3vpn_t_anonymous_union_vpn_mldp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_my_ipv4_table_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 18);
    bv.set_bits(17, 16, ip_termination_type);
    bv.set_bits(15, 0, ip_tunnel_termination_attr_or_slp.pack());
    return bv;
}


void npl_my_ipv4_table_payload_t::unpack(bit_vector64_t bv) 
{
    ip_termination_type = (npl_termination_logical_db_e)bv.bits(17, 16).get_value();
    ip_tunnel_termination_attr_or_slp.unpack(bv.bits(15, 0));
}



field_structure npl_my_ipv4_table_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_my_ipv4_table_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ip_termination_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ip_termination_type", fs_subfield);
    
    fs_result.subfields.emplace_back("ip_tunnel_termination_attr_or_slp", ip_tunnel_termination_attr_or_slp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_my_ipv4_table_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_my_ipv4_table_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_nh_payload_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 68, eve_vid1);
    bv.set_bits(67, 67, l2_port);
    bv.set_bits(66, 66, l2_flood);
    bv.set_bits(65, 54, eve_vid2);
    bv.set_bits(53, 0, l3_sa_vlan_or_l2_dlp_attr.pack());
    return bv;
}


void npl_nh_payload_t::unpack(bit_vector128_t bv) 
{
    eve_vid1 = bv.bits(79, 68).get_value();
    l2_port = bv.bits(67, 67).get_value();
    l2_flood = bv.bits(66, 66).get_value();
    eve_vid2 = bv.bits(65, 54).get_value();
    l3_sa_vlan_or_l2_dlp_attr.unpack(bv.bits(53, 0));
}



field_structure npl_nh_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_nh_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(eve_vid1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eve_vid1", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_port);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_port", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l2_flood);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_flood", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(eve_vid2);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("eve_vid2", fs_subfield);
    
    fs_result.subfields.emplace_back("l3_sa_vlan_or_l2_dlp_attr", l3_sa_vlan_or_l2_dlp_attr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_nh_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_nh_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_encap_header_l3_dlp_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 4, l3_dlp_id.pack());
    bv.set_bits(3, 0, properties.pack());
    return bv;
}


void npl_npu_encap_header_l3_dlp_t::unpack(bit_vector64_t bv) 
{
    l3_dlp_id.unpack(bv.bits(15, 4));
    properties.unpack(bv.bits(3, 0));
}



field_structure npl_npu_encap_header_l3_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_encap_header_l3_dlp_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp_id", l3_dlp_id.to_field_structure());
    fs_result.subfields.emplace_back("properties", properties.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_encap_header_l3_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_encap_header_l3_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_ip_collapsed_mc_encap_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 36, collapsed_mc_encap_type);
    bv.set_bits(35, 20, l3_dlp.pack());
    bv.set_bits(19, 19, punt.pack());
    bv.set_bits(18, 18, resolve_local_mcid.pack());
    bv.set_bits(17, 0, l2_dlp.pack());
    return bv;
}


void npl_npu_ip_collapsed_mc_encap_header_t::unpack(bit_vector64_t bv) 
{
    collapsed_mc_encap_type = (npl_npu_encap_l3_header_type_e)bv.bits(39, 36).get_value();
    l3_dlp.unpack(bv.bits(35, 20));
    punt.unpack(bv.bits(19, 19));
    resolve_local_mcid.unpack(bv.bits(18, 18));
    l2_dlp.unpack(bv.bits(17, 0));
}



field_structure npl_npu_ip_collapsed_mc_encap_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_ip_collapsed_mc_encap_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(collapsed_mc_encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("collapsed_mc_encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
    fs_result.subfields.emplace_back("punt", punt.to_field_structure());
    fs_result.subfields.emplace_back("resolve_local_mcid", resolve_local_mcid.to_field_structure());
    fs_result.subfields.emplace_back("l2_dlp", l2_dlp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_ip_collapsed_mc_encap_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_ip_collapsed_mc_encap_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_l3_common_dlp_nh_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 12, l3_dlp.pack());
    bv.set_bits(11, 0, nh);
    return bv;
}


void npl_npu_l3_common_dlp_nh_encap_t::unpack(bit_vector64_t bv) 
{
    l3_dlp.unpack(bv.bits(27, 12));
    nh = bv.bits(11, 0).get_value();
}



field_structure npl_npu_l3_common_dlp_nh_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_common_dlp_nh_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_npu_l3_common_dlp_nh_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_common_dlp_nh_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_l3_encap_header_t_anonymous_union_encap_ext_t::pack(void) const // union
{
    bit_vector64_t bv(0, 48);
    { // union compound field start
        bit_vector64_t tbv = tunnel_headend.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 2, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lsr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 2, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vxlan.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 16, tbv);
            return bv;
        }
    } // union compound field end
    
    if (gre_tunnel_dlp != 0) {  // union primitive field start
        bv.set_bits(47, 32, gre_tunnel_dlp);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = npu_pif_ifg.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_npu_l3_encap_header_t_anonymous_union_encap_ext_t::unpack(bit_vector64_t bv) // union
{
    tunnel_headend.unpack(bv.bits(47, 2));
}



field_structure npl_npu_l3_encap_header_t_anonymous_union_encap_ext_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_encap_header_t_anonymous_union_encap_ext_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = tunnel_headend.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("tunnel_headend", tunnel_headend.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = lsr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lsr", lsr.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vxlan.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("vxlan", vxlan.to_field_structure());
        }
    } // union compound field end
    
    if (gre_tunnel_dlp != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(gre_tunnel_dlp);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = npu_pif_ifg.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("npu_pif_ifg", npu_pif_ifg.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_npu_l3_encap_header_t_anonymous_union_encap_ext_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_encap_header_t_anonymous_union_encap_ext_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_l3_mc_host_gb_dlp_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    // PADDING -  bv.set_bits(27, 24, padding);
    bv.set_bits(23, 8, mc_host_gb_l3_dlp.pack());
    // PADDING -  bv.set_bits(7, 0, padding);
    return bv;
}


void npl_npu_l3_mc_host_gb_dlp_encap_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(27, 24).get_value();
    mc_host_gb_l3_dlp.unpack(bv.bits(23, 8));
    // PADDING -  padding = bv.bits(7, 0).get_value();
}



field_structure npl_npu_l3_mc_host_gb_dlp_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_mc_host_gb_dlp_encap_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("mc_host_gb_l3_dlp", mc_host_gb_l3_dlp.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_npu_l3_mc_host_gb_dlp_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_mc_host_gb_dlp_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_em_lpm_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 33);
    bv.set_bits(32, 8, lpm_code_or_dest.pack());
    // PADDING -  bv.set_bits(7, 5, padding);
    bv.set_bits(4, 4, is_default_unused);
    bv.set_bits(3, 2, result_type);
    bv.set_bits(1, 1, no_hbm_access);
    // PADDING -  bv.set_bits(0, 0, padding);
    return bv;
}


void npl_og_em_lpm_result_t::unpack(bit_vector64_t bv) 
{
    lpm_code_or_dest.unpack(bv.bits(32, 8));
    // PADDING -  padding = bv.bits(7, 5).get_value();
    is_default_unused = bv.bits(4, 4).get_value();
    result_type = (npl_ip_em_lpm_result_type_e)bv.bits(3, 2).get_value();
    no_hbm_access = bv.bits(1, 1).get_value();
    // PADDING -  padding = bv.bits(0, 0).get_value();
}



field_structure npl_og_em_lpm_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_em_lpm_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("lpm_code_or_dest", lpm_code_or_dest.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(is_default_unused);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_default_unused", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(result_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("result_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_og_em_lpm_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_em_lpm_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_em_result_t_anonymous_union_result_t::pack(void) const // union
{
    bit_vector64_t bv(0, 62);
    { // union compound field start
        bit_vector64_t tbv = lpm_code_or_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(24, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_og_em_result_t_anonymous_union_result_t::unpack(bit_vector64_t bv) // union
{
    lpm_code_or_dest.unpack(bv.bits(24, 0));
}



field_structure npl_og_em_result_t_anonymous_union_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_em_result_t_anonymous_union_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = lpm_code_or_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lpm_code_or_dest", lpm_code_or_dest.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_og_em_result_t_anonymous_union_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_em_result_t_anonymous_union_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pd_rx_nw_app_t_anonymous_union_init_fields_union_t::pack(void) const // union
{
    bit_vector64_t bv(0, 50);
    { // union compound field start
        bit_vector64_t tbv = init_fields.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(49, 2, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_pd_rx_nw_app_t_anonymous_union_init_fields_union_t::unpack(bit_vector64_t bv) // union
{
    init_fields.unpack(bv.bits(49, 2));
}



field_structure npl_pd_rx_nw_app_t_anonymous_union_init_fields_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pd_rx_nw_app_t_anonymous_union_init_fields_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = init_fields.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("init_fields", init_fields.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_pd_rx_nw_app_t_anonymous_union_init_fields_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pd_rx_nw_app_t_anonymous_union_init_fields_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_punt_eth_nw_common_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 92);
    bv.set_bits(91, 44, punt_host_da.pack());
    bv.set_bits(43, 32, padding_or_ipv6_len.pack());
    bv.set_bits(31, 16, sa_or_npuh.pack());
    bv.set_bits(15, 12, punt_if_sa_rewrite_idx);
    bv.set_bits(11, 0, punt_eth_vid.pack());
    return bv;
}


void npl_punt_eth_nw_common_encap_data_t::unpack(bit_vector128_t bv) 
{
    punt_host_da.unpack(bv.bits(91, 44));
    padding_or_ipv6_len.unpack(bv.bits(43, 32));
    sa_or_npuh.unpack(bv.bits(31, 16));
    punt_if_sa_rewrite_idx = bv.bits(15, 12).get_value();
    punt_eth_vid.unpack(bv.bits(11, 0));
}



field_structure npl_punt_eth_nw_common_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_eth_nw_common_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("punt_host_da", punt_host_da.to_field_structure());
    fs_result.subfields.emplace_back("padding_or_ipv6_len", padding_or_ipv6_len.to_field_structure());
    fs_result.subfields.emplace_back("sa_or_npuh", sa_or_npuh.to_field_structure());
    fs_subfield.flat_value = to_hex_string(punt_if_sa_rewrite_idx);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_if_sa_rewrite_idx", fs_subfield);
    
    fs_result.subfields.emplace_back("punt_eth_vid", punt_eth_vid.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_eth_nw_common_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_eth_nw_common_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_l3_lp_t_anonymous_union_id_or_pfc_t::pack(void) const // union
{
    bit_vector64_t bv(0, 16);
    { // union compound field start
        bit_vector64_t tbv = punt_padding_id.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(13, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = sw_pfc.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(14, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_punt_l3_lp_t_anonymous_union_id_or_pfc_t::unpack(bit_vector64_t bv) // union
{
    punt_padding_id.unpack(bv.bits(13, 0));
}



field_structure npl_punt_l3_lp_t_anonymous_union_id_or_pfc_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_l3_lp_t_anonymous_union_id_or_pfc_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = punt_padding_id.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_padding_id", punt_padding_id.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = sw_pfc.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("sw_pfc", sw_pfc.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_punt_l3_lp_t_anonymous_union_id_or_pfc_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_l3_lp_t_anonymous_union_id_or_pfc_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_lsb_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 36, packet_fwd_header_type);
    // PADDING -  bv.set_bits(35, 32, padding);
    bv.set_bits(31, 0, punt_shared_lsb_encap.pack());
    return bv;
}


void npl_punt_lsb_encap_t::unpack(bit_vector64_t bv) 
{
    packet_fwd_header_type = (npl_fwd_header_type_e)bv.bits(39, 36).get_value();
    // PADDING -  padding = bv.bits(35, 32).get_value();
    punt_shared_lsb_encap.unpack(bv.bits(31, 0));
}



field_structure npl_punt_lsb_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_lsb_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(packet_fwd_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("packet_fwd_header_type", fs_subfield);
    
    
    fs_result.subfields.emplace_back("punt_shared_lsb_encap", punt_shared_lsb_encap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_lsb_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_lsb_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_pwe_dlp_specific_t::pack(void) const 
{
    bit_vector64_t bv(0, 52);
    bv.set_bits(51, 24, eve.pack());
    bv.set_bits(23, 4, pwe_label);
    // PADDING -  bv.set_bits(3, 3, padding);
    bv.set_bits(2, 2, lp_set);
    bv.set_bits(1, 1, pwe_fat);
    bv.set_bits(0, 0, pwe_cw);
    return bv;
}


void npl_pwe_dlp_specific_t::unpack(bit_vector64_t bv) 
{
    eve.unpack(bv.bits(51, 24));
    pwe_label = bv.bits(23, 4).get_value();
    // PADDING -  padding = bv.bits(3, 3).get_value();
    lp_set = bv.bits(2, 2).get_value();
    pwe_fat = bv.bits(1, 1).get_value();
    pwe_cw = bv.bits(0, 0).get_value();
}



field_structure npl_pwe_dlp_specific_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pwe_dlp_specific_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("eve", eve.to_field_structure());
    fs_subfield.flat_value = to_hex_string(pwe_label);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pwe_label", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(lp_set);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lp_set", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pwe_fat);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pwe_fat", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(pwe_cw);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pwe_cw", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_pwe_dlp_specific_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pwe_dlp_specific_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_qos_mapping_key_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, key_union.pack());
    return bv;
}


void npl_qos_mapping_key_t::unpack(bit_vector64_t bv) 
{
    key_union.unpack(bv.bits(7, 0));
}



field_structure npl_qos_mapping_key_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_qos_mapping_key_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("key_union", key_union.to_field_structure());
    return fs_result;
}
std::string to_string(npl_qos_mapping_key_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_qos_mapping_key_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_wide_protection_line_t::pack(void) const 
{
    bit_vector192_t bv(0, 145);
    bv.set_bits(144, 144, type);
    bv.set_bits(143, 0, record.pack());
    return bv;
}


void npl_resolution_stage_assoc_data_wide_protection_line_t::unpack(bit_vector192_t bv) 
{
    type = (npl_resolution_state_assoc_data_entry_type_e)bv.bits(144, 144).get_value();
    record.unpack(bv.bits(143, 0));
}



field_structure npl_resolution_stage_assoc_data_wide_protection_line_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_wide_protection_line_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_result.subfields.emplace_back("record", record.to_field_structure());
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_wide_protection_line_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_wide_protection_line_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rpf_compressed_destination_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 19, enable_mc_rpf);
    // PADDING -  bv.set_bits(18, 16, padding);
    bv.set_bits(15, 0, rpf_id_or_lp_id.pack());
    return bv;
}


void npl_rpf_compressed_destination_t::unpack(bit_vector64_t bv) 
{
    enable_mc_rpf = bv.bits(19, 19).get_value();
    // PADDING -  padding = bv.bits(18, 16).get_value();
    rpf_id_or_lp_id.unpack(bv.bits(15, 0));
}



field_structure npl_rpf_compressed_destination_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rpf_compressed_destination_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable_mc_rpf);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_mc_rpf", fs_subfield);
    
    
    fs_result.subfields.emplace_back("rpf_id_or_lp_id", rpf_id_or_lp_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rpf_compressed_destination_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rpf_compressed_destination_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_payload_t_anonymous_union_rtf_result_profile_t::pack(void) const // union
{
    bit_vector64_t bv(0, 62);
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_0.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_1.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_3.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_rtf_payload_t_anonymous_union_rtf_result_profile_t::unpack(bit_vector64_t bv) // union
{
    rtf_result_profile_0.unpack(bv.bits(61, 0));
}



field_structure npl_rtf_payload_t_anonymous_union_rtf_result_profile_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_payload_t_anonymous_union_rtf_result_profile_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_0.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rtf_result_profile_0", rtf_result_profile_0.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_1.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rtf_result_profile_1", rtf_result_profile_1.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rtf_result_profile_2", rtf_result_profile_2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = rtf_result_profile_3.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rtf_result_profile_3", rtf_result_profile_3.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_rtf_payload_t_anonymous_union_rtf_result_profile_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_payload_t_anonymous_union_rtf_result_profile_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_single_label_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 24, udat.pack());
    bv.set_bits(23, 0, v6_label_encap.pack());
    return bv;
}


void npl_single_label_encap_data_t::unpack(bit_vector64_t bv) 
{
    udat.unpack(bv.bits(55, 24));
    v6_label_encap.unpack(bv.bits(23, 0));
}



field_structure npl_single_label_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_single_label_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("udat", udat.to_field_structure());
    fs_result.subfields.emplace_back("v6_label_encap", v6_label_encap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_single_label_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_single_label_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_slp_info_t_anonymous_union_global_slp_id_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = l2_slp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_slp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 4, tbv);
            return bv;
        }
    } // union compound field end
    
    if (is_l2 != 0) {  // union primitive field start
        bv.set_bits(19, 19, is_l2);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_slp_info_t_anonymous_union_global_slp_id_t::unpack(bit_vector64_t bv) // union
{
    l2_slp.unpack(bv.bits(19, 0));
}



field_structure npl_slp_info_t_anonymous_union_global_slp_id_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_slp_info_t_anonymous_union_global_slp_id_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_slp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_slp", l2_slp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_slp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_slp", l3_slp.to_field_structure());
        }
    } // union compound field end
    
    if (is_l2 != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(is_l2);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_slp_info_t_anonymous_union_global_slp_id_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_slp_info_t_anonymous_union_global_slp_id_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_snoop_or_rcy_data_t_anonymous_union_snoop_or_rcy_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 8);
    if (snoop_code != 0) {  // union primitive field start
        bv.set_bits(7, 0, snoop_code);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = tx_to_rx_rcy_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_snoop_or_rcy_data_t_anonymous_union_snoop_or_rcy_data_t::unpack(bit_vector64_t bv) // union
{
    snoop_code = bv.bits(7, 0).get_value();
}



field_structure npl_snoop_or_rcy_data_t_anonymous_union_snoop_or_rcy_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_snoop_or_rcy_data_t_anonymous_union_snoop_or_rcy_data_t";
    field_structure fs_subfield;
    //add members to result
    if (snoop_code != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(snoop_code);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = tx_to_rx_rcy_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("tx_to_rx_rcy_data", tx_to_rx_rcy_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_snoop_or_rcy_data_t_anonymous_union_snoop_or_rcy_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_snoop_or_rcy_data_t_anonymous_union_snoop_or_rcy_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svi_eve_profile_and_data_t_anonymous_union_sub_type_or_vid_2_plus_prf_t::pack(void) const // union
{
    bit_vector64_t bv(0, 14);
    { // union compound field start
        bit_vector64_t tbv = svi_eve_sub_type_plus_pad_plus_prf.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(13, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = svi_eve_vid2_plus_prf_t.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(13, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    if (vid2 != 0) {  // union primitive field start
        bv.set_bits(13, 2, vid2);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_svi_eve_profile_and_data_t_anonymous_union_sub_type_or_vid_2_plus_prf_t::unpack(bit_vector64_t bv) // union
{
    svi_eve_sub_type_plus_pad_plus_prf.unpack(bv.bits(13, 0));
}



field_structure npl_svi_eve_profile_and_data_t_anonymous_union_sub_type_or_vid_2_plus_prf_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svi_eve_profile_and_data_t_anonymous_union_sub_type_or_vid_2_plus_prf_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = svi_eve_sub_type_plus_pad_plus_prf.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("svi_eve_sub_type_plus_pad_plus_prf", svi_eve_sub_type_plus_pad_plus_prf.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = svi_eve_vid2_plus_prf_t.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("svi_eve_vid2_plus_prf_t", svi_eve_vid2_plus_prf_t.to_field_structure());
        }
    } // union compound field end
    
    if (vid2 != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(vid2);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_svi_eve_profile_and_data_t_anonymous_union_sub_type_or_vid_2_plus_prf_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svi_eve_profile_and_data_t_anonymous_union_sub_type_or_vid_2_plus_prf_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svl_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, svl_uc_mc_data.pack());
    return bv;
}


void npl_svl_data_t::unpack(bit_vector64_t bv) 
{
    svl_uc_mc_data.unpack(bv.bits(15, 0));
}



field_structure npl_svl_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svl_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("svl_uc_mc_data", svl_uc_mc_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_svl_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svl_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_term_l2_lp_attributes_t::pack(void) const 
{
    bit_vector64_t bv(0, 34);
    bv.set_bits(33, 33, enable_monitor);
    bv.set_bits(32, 32, mip_exists);
    bv.set_bits(31, 31, mep_exists);
    bv.set_bits(30, 3, ive_profile_and_data.pack());
    bv.set_bits(2, 0, max_mep_level);
    return bv;
}


void npl_term_l2_lp_attributes_t::unpack(bit_vector64_t bv) 
{
    enable_monitor = bv.bits(33, 33).get_value();
    mip_exists = bv.bits(32, 32).get_value();
    mep_exists = bv.bits(31, 31).get_value();
    ive_profile_and_data.unpack(bv.bits(30, 3));
    max_mep_level = bv.bits(2, 0).get_value();
}



field_structure npl_term_l2_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_term_l2_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(enable_monitor);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_monitor", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mip_exists);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mip_exists", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mep_exists);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_exists", fs_subfield);
    
    fs_result.subfields.emplace_back("ive_profile_and_data", ive_profile_and_data.to_field_structure());
    fs_subfield.flat_value = to_hex_string(max_mep_level);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("max_mep_level", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_term_l2_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_term_l2_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tm_headers_template_t_anonymous_union_u_t::pack(void) const // union
{
    bit_vector64_t bv(0, 48);
    { // union compound field start
        bit_vector64_t tbv = unicast_flb.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = unicast_plb.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mmm.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(23, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mum.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_tm_headers_template_t_anonymous_union_u_t::unpack(bit_vector64_t bv) // union
{
    unicast_flb.unpack(bv.bits(23, 0));
}



field_structure npl_tm_headers_template_t_anonymous_union_u_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tm_headers_template_t_anonymous_union_u_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = unicast_flb.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("unicast_flb", unicast_flb.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = unicast_plb.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("unicast_plb", unicast_plb.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mmm.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mmm", mmm.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mum.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mum", mum.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_tm_headers_template_t_anonymous_union_u_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tm_headers_template_t_anonymous_union_u_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_tx_punt_local_var_t_anonymous_union_ene_eth_or_npu_host_data_t::pack(void) const // union
{
    bit_vector128_t bv(0, 124);
    { // union compound field start
        bit_vector128_t tbv = punt_eth_nw_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(91, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = punt_eth_transport_update.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(123, 32, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = punt_npu_host_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_tx_punt_local_var_t_anonymous_union_ene_eth_or_npu_host_data_t::unpack(bit_vector128_t bv) // union
{
    punt_eth_nw_encap_data.unpack(bv.bits(91, 0));
}



field_structure npl_tx_punt_local_var_t_anonymous_union_ene_eth_or_npu_host_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tx_punt_local_var_t_anonymous_union_ene_eth_or_npu_host_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = punt_eth_nw_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_eth_nw_encap_data", punt_eth_nw_encap_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = punt_eth_transport_update.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_eth_transport_update", punt_eth_transport_update.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = punt_npu_host_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_npu_host_data", punt_npu_host_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_tx_punt_local_var_t_anonymous_union_ene_eth_or_npu_host_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tx_punt_local_var_t_anonymous_union_ene_eth_or_npu_host_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t::pack(void) const 
{
    bit_vector192_t bv(0, 176);
    bv.set_bits(175, 144, mark_y.pack());
    bv.set_bits(143, 112, mark_g.pack());
    bv.set_bits(111, 111, evict_to_dram[15].pack());
    bv.set_bits(110, 110, evict_to_dram[14].pack());
    bv.set_bits(109, 109, evict_to_dram[13].pack());
    bv.set_bits(108, 108, evict_to_dram[12].pack());
    bv.set_bits(107, 107, evict_to_dram[11].pack());
    bv.set_bits(106, 106, evict_to_dram[10].pack());
    bv.set_bits(105, 105, evict_to_dram[9].pack());
    bv.set_bits(104, 104, evict_to_dram[8].pack());
    bv.set_bits(103, 103, evict_to_dram[7].pack());
    bv.set_bits(102, 102, evict_to_dram[6].pack());
    bv.set_bits(101, 101, evict_to_dram[5].pack());
    bv.set_bits(100, 100, evict_to_dram[4].pack());
    bv.set_bits(99, 99, evict_to_dram[3].pack());
    bv.set_bits(98, 98, evict_to_dram[2].pack());
    bv.set_bits(97, 97, evict_to_dram[1].pack());
    bv.set_bits(96, 96, evict_to_dram[0].pack());
    bv.set_bits(95, 48, drop_y.pack());
    bv.set_bits(47, 0, drop_g.pack());
    return bv;
}


void npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t::unpack(bit_vector192_t bv) 
{
    mark_y.unpack(bv.bits(175, 144));
    mark_g.unpack(bv.bits(143, 112));
    evict_to_dram[15].unpack(bv.bits(111, 111));
    evict_to_dram[14].unpack(bv.bits(110, 110));
    evict_to_dram[13].unpack(bv.bits(109, 109));
    evict_to_dram[12].unpack(bv.bits(108, 108));
    evict_to_dram[11].unpack(bv.bits(107, 107));
    evict_to_dram[10].unpack(bv.bits(106, 106));
    evict_to_dram[9].unpack(bv.bits(105, 105));
    evict_to_dram[8].unpack(bv.bits(104, 104));
    evict_to_dram[7].unpack(bv.bits(103, 103));
    evict_to_dram[6].unpack(bv.bits(102, 102));
    evict_to_dram[5].unpack(bv.bits(101, 101));
    evict_to_dram[4].unpack(bv.bits(100, 100));
    evict_to_dram[3].unpack(bv.bits(99, 99));
    evict_to_dram[2].unpack(bv.bits(98, 98));
    evict_to_dram[1].unpack(bv.bits(97, 97));
    evict_to_dram[0].unpack(bv.bits(96, 96));
    drop_y.unpack(bv.bits(95, 48));
    drop_g.unpack(bv.bits(47, 0));
}



field_structure npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mark_y", mark_y.to_field_structure());
    fs_result.subfields.emplace_back("mark_g", mark_g.to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[15]", evict_to_dram[15].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[14]", evict_to_dram[14].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[13]", evict_to_dram[13].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[12]", evict_to_dram[12].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[11]", evict_to_dram[11].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[10]", evict_to_dram[10].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[9]", evict_to_dram[9].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[8]", evict_to_dram[8].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[7]", evict_to_dram[7].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[6]", evict_to_dram[6].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[5]", evict_to_dram[5].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[4]", evict_to_dram[4].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[3]", evict_to_dram[3].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[2]", evict_to_dram[2].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[1]", evict_to_dram[1].to_field_structure());
    fs_result.subfields.emplace_back("evict_to_dram[0]", evict_to_dram[0].to_field_structure());
    fs_result.subfields.emplace_back("drop_y", drop_y.to_field_structure());
    fs_result.subfields.emplace_back("drop_g", drop_g.to_field_structure());
    return fs_result;
}
std::string to_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_voq_cgm_slice_buffers_consumption_lut_for_enq_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_vpn_label_encap_data_t::pack(void) const // union
{
    bit_vector128_t bv(0, 76);
    { // union compound field start
        bit_vector64_t tbv = single_label_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(75, 20, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = l2vpn_label_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(75, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_vpn_label_encap_data_t::unpack(bit_vector128_t bv) // union
{
    single_label_encap_data.unpack(bv.bits(75, 20));
}



field_structure npl_vpn_label_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_vpn_label_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = single_label_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("single_label_encap_data", single_label_encap_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = l2vpn_label_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2vpn_label_encap_data", l2vpn_label_encap_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_vpn_label_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_vpn_label_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_app_mc_cud_narrow_t::pack(void) const // union
{
    bit_vector64_t bv(0, 40);
    { // union compound field start
        bit_vector64_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 16, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ip_collapsed_mc.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(39, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_app_mc_cud_narrow_t::unpack(bit_vector64_t bv) // union
{
    l2.unpack(bv.bits(39, 16));
}



field_structure npl_app_mc_cud_narrow_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_mc_cud_narrow_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2", l2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ip_collapsed_mc.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ip_collapsed_mc", ip_collapsed_mc.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_app_mc_cud_narrow_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_mc_cud_narrow_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_base_l3_lp_attributes_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 108, rtf_conf_set_and_stages_or_post_fwd_stage.pack());
    bv.set_bits(107, 104, acl_drop_offset.pack());
    bv.set_bits(103, 102, uc_rpf_mode);
    bv.set_bits(101, 101, l3_lp_mirror_type);
    bv.set_bits(100, 96, mirror_cmd);
    bv.set_bits(95, 40, minimal_l3_lp_attributes.pack());
    bv.set_bits(39, 20, q_counter.pack());
    bv.set_bits(19, 0, m_counter.pack());
    return bv;
}


void npl_base_l3_lp_attributes_t::unpack(bit_vector128_t bv) 
{
    rtf_conf_set_and_stages_or_post_fwd_stage.unpack(bv.bits(119, 108));
    acl_drop_offset.unpack(bv.bits(107, 104));
    uc_rpf_mode = (npl_rpf_mode_e)bv.bits(103, 102).get_value();
    l3_lp_mirror_type = (npl_port_mirror_type_e)bv.bits(101, 101).get_value();
    mirror_cmd = bv.bits(100, 96).get_value();
    minimal_l3_lp_attributes.unpack(bv.bits(95, 40));
    q_counter.unpack(bv.bits(39, 20));
    m_counter.unpack(bv.bits(19, 0));
}



field_structure npl_base_l3_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_base_l3_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("rtf_conf_set_and_stages_or_post_fwd_stage", rtf_conf_set_and_stages_or_post_fwd_stage.to_field_structure());
    fs_result.subfields.emplace_back("acl_drop_offset", acl_drop_offset.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(uc_rpf_mode);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("uc_rpf_mode", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(l3_lp_mirror_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_lp_mirror_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mirror_cmd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mirror_cmd", fs_subfield);
    
    fs_result.subfields.emplace_back("minimal_l3_lp_attributes", minimal_l3_lp_attributes.to_field_structure());
    fs_result.subfields.emplace_back("q_counter", q_counter.to_field_structure());
    fs_result.subfields.emplace_back("m_counter", m_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_base_l3_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_base_l3_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_bfd_aux_payload_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 120, transmit.pack());
    bv.set_bits(119, 0, shared.pack());
    return bv;
}


void npl_bfd_aux_payload_t::unpack(bit_vector192_t bv) 
{
    transmit.unpack(bv.bits(159, 120));
    shared.unpack(bv.bits(119, 0));
}



field_structure npl_bfd_aux_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_aux_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("transmit", transmit.to_field_structure());
    fs_result.subfields.emplace_back("shared", shared.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_aux_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_aux_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_bfd_em_compound_results_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 4, bfd_payload.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_bfd_em_compound_results_t::unpack(bit_vector64_t bv) 
{
    bfd_payload.unpack(bv.bits(47, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_bfd_em_compound_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_em_compound_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("bfd_payload", bfd_payload.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_bfd_em_compound_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_em_compound_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_data_on_npuh_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 60, ene_punt_fwd_header_type);
    bv.set_bits(59, 56, ene_punt_src);
    bv.set_bits(55, 48, ene_current_nw_hdr_offset);
    bv.set_bits(47, 8, ene_punt_sub_code_and_padding_dsp_and_ssp.pack());
    // PADDING -  bv.set_bits(7, 5, padding);
    bv.set_bits(4, 0, ene_punt_next_header_type);
    return bv;
}


void npl_ene_punt_data_on_npuh_t::unpack(bit_vector64_t bv) 
{
    ene_punt_fwd_header_type = (npl_fwd_header_type_e)bv.bits(63, 60).get_value();
    ene_punt_src = (npl_punt_source_e)bv.bits(59, 56).get_value();
    ene_current_nw_hdr_offset = bv.bits(55, 48).get_value();
    ene_punt_sub_code_and_padding_dsp_and_ssp.unpack(bv.bits(47, 8));
    // PADDING -  padding = bv.bits(7, 5).get_value();
    ene_punt_next_header_type = (npl_protocol_type_e)bv.bits(4, 0).get_value();
}



field_structure npl_ene_punt_data_on_npuh_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_data_on_npuh_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(ene_punt_fwd_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_punt_fwd_header_type", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(ene_punt_src);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_punt_src", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ene_current_nw_hdr_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_current_nw_hdr_offset", fs_subfield);
    
    fs_result.subfields.emplace_back("ene_punt_sub_code_and_padding_dsp_and_ssp", ene_punt_sub_code_and_padding_dsp_and_ssp.to_field_structure());
    
    fs_subfield.flat_value = npl_enum_to_string(ene_punt_next_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_punt_next_header_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ene_punt_data_on_npuh_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_data_on_npuh_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_host_nh_mac_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 48, l3_dlp.pack());
    bv.set_bits(47, 0, host_mac);
    return bv;
}


void npl_host_nh_mac_t::unpack(bit_vector64_t bv) 
{
    l3_dlp.unpack(bv.bits(63, 48));
    host_mac = bv.bits(47, 0).get_value();
}



field_structure npl_host_nh_mac_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_host_nh_mac_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(host_mac);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_mac", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_host_nh_mac_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_host_nh_mac_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_host_nh_ptr_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 20, l3_dlp.pack());
    bv.set_bits(19, 0, host_ptr);
    return bv;
}


void npl_host_nh_ptr_t::unpack(bit_vector64_t bv) 
{
    l3_dlp.unpack(bv.bits(35, 20));
    host_ptr = bv.bits(19, 0).get_value();
}



field_structure npl_host_nh_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_host_nh_ptr_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(host_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("host_ptr", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_host_nh_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_host_nh_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_punt_mc_expand_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 24, npu_mirror_or_redirect_encapsulation_type);
    bv.set_bits(23, 8, lpts_tcam_first_result_encap_data_msb.pack());
    bv.set_bits(7, 0, current_nw_hdr_offset);
    return bv;
}


void npl_ingress_punt_mc_expand_encap_t::unpack(bit_vector64_t bv) 
{
    npu_mirror_or_redirect_encapsulation_type = (npl_npu_mirror_or_redirect_encap_type_e)bv.bits(27, 24).get_value();
    lpts_tcam_first_result_encap_data_msb.unpack(bv.bits(23, 8));
    current_nw_hdr_offset = bv.bits(7, 0).get_value();
}



field_structure npl_ingress_punt_mc_expand_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_punt_mc_expand_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(npu_mirror_or_redirect_encapsulation_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("npu_mirror_or_redirect_encapsulation_type", fs_subfield);
    
    fs_result.subfields.emplace_back("lpts_tcam_first_result_encap_data_msb", lpts_tcam_first_result_encap_data_msb.to_field_structure());
    fs_subfield.flat_value = to_hex_string(current_nw_hdr_offset);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("current_nw_hdr_offset", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ingress_punt_mc_expand_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_punt_mc_expand_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_acl_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 31, override_phb);
    bv.set_bits(30, 30, override_qos);
    bv.set_bits(29, 29, meter);
    bv.set_bits(28, 24, phb.pack());
    bv.set_bits(23, 19, ctr_offest_union.pack());
    bv.set_bits(18, 0, ingress_qos_remark.pack());
    return bv;
}


void npl_ingress_qos_acl_result_t::unpack(bit_vector64_t bv) 
{
    override_phb = bv.bits(31, 31).get_value();
    override_qos = bv.bits(30, 30).get_value();
    meter = (npl_q_or_meter_cntr_e)bv.bits(29, 29).get_value();
    phb.unpack(bv.bits(28, 24));
    ctr_offest_union.unpack(bv.bits(23, 19));
    ingress_qos_remark.unpack(bv.bits(18, 0));
}



field_structure npl_ingress_qos_acl_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_acl_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(override_phb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_phb", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(override_qos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_qos", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(meter);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter", fs_subfield);
    
    fs_result.subfields.emplace_back("phb", phb.to_field_structure());
    fs_result.subfields.emplace_back("ctr_offest_union", ctr_offest_union.to_field_structure());
    fs_result.subfields.emplace_back("ingress_qos_remark", ingress_qos_remark.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ingress_qos_acl_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_acl_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ingress_qos_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 31, override_qos);
    bv.set_bits(30, 30, enable_ingress_remark);
    bv.set_bits(29, 25, ctr_offest_union.pack());
    bv.set_bits(24, 20, phb.pack());
    bv.set_bits(19, 16, encap_mpls_exp.pack());
    bv.set_bits(15, 8, fwd_class_qos_group_u.pack());
    bv.set_bits(7, 7, meter);
    bv.set_bits(6, 0, fwd_qos_tag);
    return bv;
}


void npl_ingress_qos_result_t::unpack(bit_vector64_t bv) 
{
    override_qos = bv.bits(31, 31).get_value();
    enable_ingress_remark = bv.bits(30, 30).get_value();
    ctr_offest_union.unpack(bv.bits(29, 25));
    phb.unpack(bv.bits(24, 20));
    encap_mpls_exp.unpack(bv.bits(19, 16));
    fwd_class_qos_group_u.unpack(bv.bits(15, 8));
    meter = bv.bits(7, 7).get_value();
    fwd_qos_tag = bv.bits(6, 0).get_value();
}



field_structure npl_ingress_qos_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ingress_qos_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(override_qos);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("override_qos", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(enable_ingress_remark);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("enable_ingress_remark", fs_subfield);
    
    fs_result.subfields.emplace_back("ctr_offest_union", ctr_offest_union.to_field_structure());
    fs_result.subfields.emplace_back("phb", phb.to_field_structure());
    fs_result.subfields.emplace_back("encap_mpls_exp", encap_mpls_exp.to_field_structure());
    fs_result.subfields.emplace_back("fwd_class_qos_group_u", fwd_class_qos_group_u.to_field_structure());
    fs_subfield.flat_value = to_hex_string(meter);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meter", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(fwd_qos_tag);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("fwd_qos_tag", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ingress_qos_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ingress_qos_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_down_encap_dlp_and_nh_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 16, down_l3_dlp.pack());
    bv.set_bits(15, 4, down_nh);
    bv.set_bits(3, 0, down_pcp_dei.pack());
    return bv;
}


void npl_inject_down_encap_dlp_and_nh_t::unpack(bit_vector64_t bv) 
{
    down_l3_dlp.unpack(bv.bits(31, 16));
    down_nh = bv.bits(15, 4).get_value();
    down_pcp_dei.unpack(bv.bits(3, 0));
}



field_structure npl_inject_down_encap_dlp_and_nh_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_down_encap_dlp_and_nh_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("down_l3_dlp", down_l3_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(down_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("down_nh", fs_subfield);
    
    fs_result.subfields.emplace_back("down_pcp_dei", down_pcp_dei.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_down_encap_dlp_and_nh_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_down_encap_dlp_and_nh_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_down_encap_ptr_or_dlp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    if (inject_down_encap_ptr != 0) {  // union primitive field start
        bv.set_bits(31, 24, inject_down_encap_ptr);
        return bv;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_down_encap_nh.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_down_encap_ptr_or_dlp_t::unpack(bit_vector64_t bv) // union
{
    inject_down_encap_ptr = bv.bits(31, 24).get_value();
}



field_structure npl_inject_down_encap_ptr_or_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_down_encap_ptr_or_dlp_t";
    field_structure fs_subfield;
    //add members to result
    if (inject_down_encap_ptr != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(inject_down_encap_ptr);
        return union_found;
    }// union primitive field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_down_encap_nh.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_down_encap_nh", inject_down_encap_nh.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_down_encap_ptr_or_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_down_encap_ptr_or_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_header_specific_data_t_anonymous_union_inject_header_encap_hdr_ptr_t::pack(void) const // union
{
    bit_vector64_t bv(0, 32);
    { // union compound field start
        bit_vector64_t tbv = inject_down_encap_ptr_or_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(31, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_header_specific_data_t_anonymous_union_inject_header_encap_hdr_ptr_t::unpack(bit_vector64_t bv) // union
{
    inject_down_encap_ptr_or_dlp.unpack(bv.bits(31, 0));
}



field_structure npl_inject_header_specific_data_t_anonymous_union_inject_header_encap_hdr_ptr_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_specific_data_t_anonymous_union_inject_header_encap_hdr_ptr_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = inject_down_encap_ptr_or_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_down_encap_ptr_or_dlp", inject_down_encap_ptr_or_dlp.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_header_specific_data_t_anonymous_union_inject_header_encap_hdr_ptr_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_specific_data_t_anonymous_union_inject_header_encap_hdr_ptr_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_up_eth_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 12, qos_or_dest.pack());
    bv.set_bits(11, 0, from_port.pack());
    return bv;
}


void npl_inject_up_eth_header_t::unpack(bit_vector64_t bv) 
{
    qos_or_dest.unpack(bv.bits(35, 12));
    from_port.unpack(bv.bits(11, 0));
}



field_structure npl_inject_up_eth_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_eth_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("qos_or_dest", qos_or_dest.to_field_structure());
    fs_result.subfields.emplace_back("from_port", from_port.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_up_eth_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_eth_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ip_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 40, ip.pack());
    bv.set_bits(39, 0, upper_layer.pack());
    return bv;
}


void npl_ip_encap_data_t::unpack(bit_vector128_t bv) 
{
    ip.unpack(bv.bits(119, 40));
    upper_layer.unpack(bv.bits(39, 0));
}



field_structure npl_ip_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ip", ip.to_field_structure());
    fs_result.subfields.emplace_back("upper_layer", upper_layer.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_mc_result_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    // PADDING -  bv.set_bits(61, 56, padding);
    bv.set_bits(55, 40, local_mcid.pack());
    bv.set_bits(39, 20, rpf_destination.pack());
    bv.set_bits(19, 19, punt_on_rpf_fail);
    bv.set_bits(18, 18, punt_and_fwd);
    bv.set_bits(17, 0, global_mcid.pack());
    return bv;
}


void npl_ip_mc_result_payload_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(61, 56).get_value();
    local_mcid.unpack(bv.bits(55, 40));
    rpf_destination.unpack(bv.bits(39, 20));
    punt_on_rpf_fail = bv.bits(19, 19).get_value();
    punt_and_fwd = bv.bits(18, 18).get_value();
    global_mcid.unpack(bv.bits(17, 0));
}



field_structure npl_ip_mc_result_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_mc_result_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("local_mcid", local_mcid.to_field_structure());
    fs_result.subfields.emplace_back("rpf_destination", rpf_destination.to_field_structure());
    fs_subfield.flat_value = to_hex_string(punt_on_rpf_fail);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_on_rpf_fail", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(punt_and_fwd);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_and_fwd", fs_subfield);
    
    fs_result.subfields.emplace_back("global_mcid", global_mcid.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_mc_result_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_mc_result_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_mc_result_payload_with_format_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 63, format);
    // PADDING -  bv.set_bits(62, 62, padding);
    bv.set_bits(61, 0, mc_result_payload.pack());
    return bv;
}


void npl_ip_mc_result_payload_with_format_t::unpack(bit_vector64_t bv) 
{
    format = bv.bits(63, 63).get_value();
    // PADDING -  padding = bv.bits(62, 62).get_value();
    mc_result_payload.unpack(bv.bits(61, 0));
}



field_structure npl_ip_mc_result_payload_with_format_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_mc_result_payload_with_format_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("format", fs_subfield);
    
    
    fs_result.subfields.emplace_back("mc_result_payload", mc_result_payload.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_mc_result_payload_with_format_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_mc_result_payload_with_format_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ip_sgt_em_padded_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 68);
    bv.set_bits(67, 4, ip_sgt_em_result.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_ip_sgt_em_padded_result_t::unpack(bit_vector128_t bv) 
{
    ip_sgt_em_result.unpack(bv.bits(67, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_ip_sgt_em_padded_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_sgt_em_padded_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ip_sgt_em_result", ip_sgt_em_result.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_ip_sgt_em_padded_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_sgt_em_padded_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_adj_sid_nhlfe_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 32, l3_dlp_nh_encap.pack());
    bv.set_bits(31, 16, prefix);
    bv.set_bits(15, 0, dsp);
    return bv;
}


void npl_l2_adj_sid_nhlfe_t::unpack(bit_vector64_t bv) 
{
    l3_dlp_nh_encap.unpack(bv.bits(59, 32));
    prefix = bv.bits(31, 16).get_value();
    dsp = bv.bits(15, 0).get_value();
}



field_structure npl_l2_adj_sid_nhlfe_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_adj_sid_nhlfe_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp_nh_encap", l3_dlp_nh_encap.to_field_structure());
    fs_subfield.flat_value = to_hex_string(prefix);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("prefix", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_adj_sid_nhlfe_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_adj_sid_nhlfe_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_l2_lp_attributes_t::pack(void) const 
{
    bit_vector192_t bv(0, 142);
    bv.set_bits(141, 140, learn_type);
    bv.set_bits(139, 139, learn_prob);
    bv.set_bits(138, 105, term.pack());
    bv.set_bits(104, 0, shared.pack());
    return bv;
}


void npl_l2_lp_attributes_t::unpack(bit_vector192_t bv) 
{
    learn_type = (npl_learn_type_e)bv.bits(141, 140).get_value();
    learn_prob = (npl_learn_prob_e)bv.bits(139, 139).get_value();
    term.unpack(bv.bits(138, 105));
    shared.unpack(bv.bits(104, 0));
}



field_structure npl_l2_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(learn_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("learn_type", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(learn_prob);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("learn_prob", fs_subfield);
    
    fs_result.subfields.emplace_back("term", term.to_field_structure());
    fs_result.subfields.emplace_back("shared", shared.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_l2_pwe_encap_t::pack(void) const 
{
    bit_vector128_t bv(0, 68);
    bv.set_bits(67, 52, l3_dlp.pack());
    bv.set_bits(51, 40, nh);
    bv.set_bits(39, 20, lsp_destination.pack());
    bv.set_bits(19, 0, l2_dlp.pack());
    return bv;
}


void npl_l2_pwe_encap_t::unpack(bit_vector128_t bv) 
{
    l3_dlp.unpack(bv.bits(67, 52));
    nh = bv.bits(51, 40).get_value();
    lsp_destination.unpack(bv.bits(39, 20));
    l2_dlp.unpack(bv.bits(19, 0));
}



field_structure npl_l2_pwe_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_pwe_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh", fs_subfield);
    
    fs_result.subfields.emplace_back("lsp_destination", lsp_destination.to_field_structure());
    fs_result.subfields.emplace_back("l2_dlp", l2_dlp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l2_pwe_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_pwe_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_relay_and_l3_lp_attributes_payload_t::pack(void) const // union
{
    bit_vector64_t bv(0, 59);
    { // union compound field start
        bit_vector64_t tbv = relay_att_inf_payload.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(58, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mac_relay_attributes.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = relay_att_table_payload.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(58, 14, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_l2_relay_and_l3_lp_attributes_payload_t::unpack(bit_vector64_t bv) // union
{
    relay_att_inf_payload.unpack(bv.bits(58, 0));
}



field_structure npl_l2_relay_and_l3_lp_attributes_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_relay_and_l3_lp_attributes_payload_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = relay_att_inf_payload.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("relay_att_inf_payload", relay_att_inf_payload.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mac_relay_attributes.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mac_relay_attributes", mac_relay_attributes.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = relay_att_table_payload.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("relay_att_table_payload", relay_att_table_payload.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_l2_relay_and_l3_lp_attributes_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_relay_and_l3_lp_attributes_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_vxlan_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 60);
    bv.set_bits(59, 44, l3_dlp.pack());
    bv.set_bits(43, 32, nh);
    bv.set_bits(31, 12, tunnel_dlp.pack());
    // PADDING -  bv.set_bits(11, 10, padding);
    bv.set_bits(9, 0, overlay_nh);
    return bv;
}


void npl_l2_vxlan_encap_t::unpack(bit_vector64_t bv) 
{
    l3_dlp.unpack(bv.bits(59, 44));
    nh = bv.bits(43, 32).get_value();
    tunnel_dlp.unpack(bv.bits(31, 12));
    // PADDING -  padding = bv.bits(11, 10).get_value();
    overlay_nh = bv.bits(9, 0).get_value();
}



field_structure npl_l2_vxlan_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_vxlan_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
    fs_subfield.flat_value = to_hex_string(nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh", fs_subfield);
    
    fs_result.subfields.emplace_back("tunnel_dlp", tunnel_dlp.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(overlay_nh);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("overlay_nh", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_vxlan_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_vxlan_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_l3_dlp_attributes_t::pack(void) const 
{
    bit_vector192_t bv(0, 141);
    bv.set_bits(140, 140, svi_dhcp_snooping);
    bv.set_bits(139, 68, l3_dlp_encap_or_te_labels.pack());
    bv.set_bits(67, 67, disabled);
    bv.set_bits(66, 65, nh_ene_macro_code);
    bv.set_bits(64, 8, l3_dlp_qos_and_attributes.pack());
    bv.set_bits(7, 0, tx_to_rx_rcy_data.pack());
    return bv;
}


void npl_l3_dlp_attributes_t::unpack(bit_vector192_t bv) 
{
    svi_dhcp_snooping = bv.bits(140, 140).get_value();
    l3_dlp_encap_or_te_labels.unpack(bv.bits(139, 68));
    disabled = bv.bits(67, 67).get_value();
    nh_ene_macro_code = (npl_nh_ene_macro_code_e)bv.bits(66, 65).get_value();
    l3_dlp_qos_and_attributes.unpack(bv.bits(64, 8));
    tx_to_rx_rcy_data.unpack(bv.bits(7, 0));
}



field_structure npl_l3_dlp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_dlp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(svi_dhcp_snooping);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("svi_dhcp_snooping", fs_subfield);
    
    fs_result.subfields.emplace_back("l3_dlp_encap_or_te_labels", l3_dlp_encap_or_te_labels.to_field_structure());
    fs_subfield.flat_value = to_hex_string(disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disabled", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(nh_ene_macro_code);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh_ene_macro_code", fs_subfield);
    
    fs_result.subfields.emplace_back("l3_dlp_qos_and_attributes", l3_dlp_qos_and_attributes.to_field_structure());
    fs_result.subfields.emplace_back("tx_to_rx_rcy_data", tx_to_rx_rcy_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_dlp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_dlp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_l3_lp_attributes_t::pack(void) const 
{
    bit_vector192_t bv(0, 131);
    bv.set_bits(130, 120, additional.pack());
    bv.set_bits(119, 0, base.pack());
    return bv;
}


void npl_l3_lp_attributes_t::unpack(bit_vector192_t bv) 
{
    additional.unpack(bv.bits(130, 120));
    base.unpack(bv.bits(119, 0));
}



field_structure npl_l3_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("additional", additional.to_field_structure());
    fs_result.subfields.emplace_back("base", base.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_lsp_encap_mapping_data_payload_t_anonymous_union_label_stack_t::pack(void) const // union
{
    bit_vector64_t bv(0, 60);
    { // union compound field start
        bit_vector64_t tbv = opt3.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(59, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = opt2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(59, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = opt1.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(59, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_lsp_encap_mapping_data_payload_t_anonymous_union_label_stack_t::unpack(bit_vector64_t bv) // union
{
    opt3.unpack(bv.bits(59, 0));
}



field_structure npl_lsp_encap_mapping_data_payload_t_anonymous_union_label_stack_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_encap_mapping_data_payload_t_anonymous_union_label_stack_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = opt3.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("opt3", opt3.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = opt2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("opt2", opt2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = opt1.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("opt1", opt1.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_lsp_encap_mapping_data_payload_t_anonymous_union_label_stack_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_encap_mapping_data_payload_t_anonymous_union_label_stack_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mac_l3_lp_attributes_t::pack(void) const 
{
    bit_vector192_t bv(0, 142);
    bv.set_bits(141, 137, l3_lp_mymac_da_prefix);
    bv.set_bits(136, 136, mldp_budnode_terminate);
    bv.set_bits(135, 120, l3_lp_mymac_da_lsb);
    bv.set_bits(119, 0, base.pack());
    return bv;
}


void npl_mac_l3_lp_attributes_t::unpack(bit_vector192_t bv) 
{
    l3_lp_mymac_da_prefix = bv.bits(141, 137).get_value();
    mldp_budnode_terminate = bv.bits(136, 136).get_value();
    l3_lp_mymac_da_lsb = bv.bits(135, 120).get_value();
    base.unpack(bv.bits(119, 0));
}



field_structure npl_mac_l3_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_l3_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(l3_lp_mymac_da_prefix);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_lp_mymac_da_prefix", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mldp_budnode_terminate);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mldp_budnode_terminate", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(l3_lp_mymac_da_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_lp_mymac_da_lsb", fs_subfield);
    
    fs_result.subfields.emplace_back("base", base.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_l3_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_l3_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mac_lp_attributes_payload_t_anonymous_union_layer_t::pack(void) const // union
{
    bit_vector192_t bv(0, 142);
    { // union compound field start
        bit_vector192_t tbv = two.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(141, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = three.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(141, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = pd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(141, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mac_lp_attributes_payload_t_anonymous_union_layer_t::unpack(bit_vector192_t bv) // union
{
    two.unpack(bv.bits(141, 0));
}



field_structure npl_mac_lp_attributes_payload_t_anonymous_union_layer_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_lp_attributes_payload_t_anonymous_union_layer_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = two.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("two", two.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = three.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("three", three.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = pd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pd", pd.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mac_lp_attributes_payload_t_anonymous_union_layer_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_lp_attributes_payload_t_anonymous_union_layer_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_qos_macro_pack_table_fields_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    // PADDING -  bv.set_bits(15, 15, padding);
    bv.set_bits(14, 8, pd_qos_mapping_7b);
    bv.set_bits(7, 0, l3_qos_mapping_key.pack());
    return bv;
}


void npl_mac_qos_macro_pack_table_fields_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(15, 15).get_value();
    pd_qos_mapping_7b = bv.bits(14, 8).get_value();
    l3_qos_mapping_key.unpack(bv.bits(7, 0));
}



field_structure npl_mac_qos_macro_pack_table_fields_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_qos_macro_pack_table_fields_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = to_hex_string(pd_qos_mapping_7b);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("pd_qos_mapping_7b", fs_subfield);
    
    fs_result.subfields.emplace_back("l3_qos_mapping_key", l3_qos_mapping_key.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_qos_macro_pack_table_fields_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_qos_macro_pack_table_fields_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_mc_em_db_result_t::pack(void) const // union
{
    bit_vector128_t bv(0, 72);
    { // union compound field start
        bit_vector128_t tbv = rx.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = tx.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(71, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mc_em_db_result_t::unpack(bit_vector128_t bv) // union
{
    rx.unpack(bv.bits(71, 0));
}



field_structure npl_mc_em_db_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mc_em_db_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = rx.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("rx", rx.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = tx.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("tx", tx.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mc_em_db_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mc_em_db_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_l3vpn_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 36, l3_relay_id.pack());
    bv.set_bits(35, 20, vpn_mldp_info.pack());
    bv.set_bits(19, 0, vpn_p_counter.pack());
    return bv;
}


void npl_mpls_termination_l3vpn_t::unpack(bit_vector64_t bv) 
{
    l3_relay_id.unpack(bv.bits(47, 36));
    vpn_mldp_info.unpack(bv.bits(35, 20));
    vpn_p_counter.unpack(bv.bits(19, 0));
}



field_structure npl_mpls_termination_l3vpn_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_l3vpn_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_relay_id", l3_relay_id.to_field_structure());
    fs_result.subfields.emplace_back("vpn_mldp_info", vpn_mldp_info.to_field_structure());
    fs_result.subfields.emplace_back("vpn_p_counter", vpn_p_counter.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mpls_termination_l3vpn_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_l3vpn_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_result_t_anonymous_union_pwe_vpn_mldp_info_t::pack(void) const // union
{
    bit_vector64_t bv(0, 48);
    { // union compound field start
        bit_vector64_t tbv = l3vpn_info.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pwe_info.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 1, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mpls_termination_result_t_anonymous_union_pwe_vpn_mldp_info_t::unpack(bit_vector64_t bv) // union
{
    l3vpn_info.unpack(bv.bits(47, 0));
}



field_structure npl_mpls_termination_result_t_anonymous_union_pwe_vpn_mldp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_result_t_anonymous_union_pwe_vpn_mldp_info_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l3vpn_info.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3vpn_info", l3vpn_info.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pwe_info.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pwe_info", pwe_info.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mpls_termination_result_t_anonymous_union_pwe_vpn_mldp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_result_t_anonymous_union_pwe_vpn_mldp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_nh_and_svi_payload_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    // PADDING -  bv.set_bits(159, 128, padding);
    bv.set_bits(127, 48, nh_payload.pack());
    bv.set_bits(47, 0, nh_da);
    return bv;
}


void npl_nh_and_svi_payload_t::unpack(bit_vector192_t bv) 
{
    // PADDING -  padding = bv.bits(159, 128).get_value();
    nh_payload.unpack(bv.bits(127, 48));
    nh_da = bv.bits(47, 0).get_value();
}



field_structure npl_nh_and_svi_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_nh_and_svi_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("nh_payload", nh_payload.to_field_structure());
    fs_subfield.flat_value = to_hex_string(nh_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("nh_da", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_nh_and_svi_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_nh_and_svi_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_nhlfe_t_anonymous_union_nhlfe_payload_t::pack(void) const // union
{
    bit_vector64_t bv(0, 60);
    { // union compound field start
        bit_vector64_t tbv = te_headend.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = te_midpoint.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(59, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l2_adj_sid.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(59, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_nhlfe_t_anonymous_union_nhlfe_payload_t::unpack(bit_vector64_t bv) // union
{
    te_headend.unpack(bv.bits(27, 0));
}



field_structure npl_nhlfe_t_anonymous_union_nhlfe_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_nhlfe_t_anonymous_union_nhlfe_payload_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = te_headend.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("te_headend", te_headend.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = te_midpoint.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("te_midpoint", te_midpoint.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l2_adj_sid.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_adj_sid", l2_adj_sid.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_nhlfe_t_anonymous_union_nhlfe_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_nhlfe_t_anonymous_union_nhlfe_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_encap_header_ip_host_t_anonymous_union_next_hop_t::pack(void) const // union
{
    bit_vector64_t bv(0, 64);
    { // union compound field start
        bit_vector64_t tbv = host_nh_mac.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(63, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_npu_encap_header_ip_host_t_anonymous_union_next_hop_t::unpack(bit_vector64_t bv) // union
{
    host_nh_mac.unpack(bv.bits(63, 0));
}



field_structure npl_npu_encap_header_ip_host_t_anonymous_union_next_hop_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_encap_header_ip_host_t_anonymous_union_next_hop_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = host_nh_mac.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("host_nh_mac", host_nh_mac.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_npu_encap_header_ip_host_t_anonymous_union_next_hop_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_encap_header_ip_host_t_anonymous_union_next_hop_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_npu_l2_encap_header_t_anonymous_union_l2_dlp_type_t::pack(void) const // union
{
    bit_vector128_t bv(0, 68);
    { // union compound field start
        bit_vector64_t tbv = ac.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(67, 48, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = pwe.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(67, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vxlan.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(67, 8, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_npu_l2_encap_header_t_anonymous_union_l2_dlp_type_t::unpack(bit_vector128_t bv) // union
{
    ac.unpack(bv.bits(67, 48));
}



field_structure npl_npu_l2_encap_header_t_anonymous_union_l2_dlp_type_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l2_encap_header_t_anonymous_union_l2_dlp_type_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ac.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ac", ac.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = pwe.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pwe", pwe.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = vxlan.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("vxlan", vxlan.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_npu_l2_encap_header_t_anonymous_union_l2_dlp_type_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l2_encap_header_t_anonymous_union_l2_dlp_type_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_l3_common_encap_header_t_anonymous_union_l3_dlp_nh_encap_t::pack(void) const // union
{
    bit_vector64_t bv(0, 28);
    { // union compound field start
        bit_vector64_t tbv = npu_l3_common_dlp_nh_encap.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = npu_l3_mc_host_gb_dlp_encap.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = npu_l3_mc_accounting_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 8, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_npu_l3_common_encap_header_t_anonymous_union_l3_dlp_nh_encap_t::unpack(bit_vector64_t bv) // union
{
    npu_l3_common_dlp_nh_encap.unpack(bv.bits(27, 0));
}



field_structure npl_npu_l3_common_encap_header_t_anonymous_union_l3_dlp_nh_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_common_encap_header_t_anonymous_union_l3_dlp_nh_encap_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = npu_l3_common_dlp_nh_encap.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("npu_l3_common_dlp_nh_encap", npu_l3_common_dlp_nh_encap.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = npu_l3_mc_host_gb_dlp_encap.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("npu_l3_mc_host_gb_dlp_encap", npu_l3_mc_host_gb_dlp_encap.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = npu_l3_mc_accounting_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("npu_l3_mc_accounting_encap_data", npu_l3_mc_accounting_encap_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_npu_l3_common_encap_header_t_anonymous_union_l3_dlp_nh_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_common_encap_header_t_anonymous_union_l3_dlp_nh_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_og_em_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 63, result_type);
    // PADDING -  bv.set_bits(62, 62, padding);
    bv.set_bits(61, 0, result.pack());
    return bv;
}


void npl_og_em_result_t::unpack(bit_vector64_t bv) 
{
    result_type = (npl_ip_uc_em_result_type_e)bv.bits(63, 63).get_value();
    // PADDING -  padding = bv.bits(62, 62).get_value();
    result.unpack(bv.bits(61, 0));
}



field_structure npl_og_em_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_em_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(result_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("result_type", fs_subfield);
    
    
    fs_result.subfields.emplace_back("result", result.to_field_structure());
    return fs_result;
}
std::string to_string(npl_og_em_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_em_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_l3_lp_t::pack(void) const 
{
    bit_vector64_t bv(0, 16);
    bv.set_bits(15, 0, id_or_pfc.pack());
    return bv;
}


void npl_punt_l3_lp_t::unpack(bit_vector64_t bv) 
{
    id_or_pfc.unpack(bv.bits(15, 0));
}



field_structure npl_punt_l3_lp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_l3_lp_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("id_or_pfc", id_or_pfc.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_l3_lp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_l3_lp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_msb_encap_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 12, punt_encap_msb.pack());
    bv.set_bits(11, 0, punt_lm_cmd.pack());
    return bv;
}


void npl_punt_msb_encap_t::unpack(bit_vector64_t bv) 
{
    punt_encap_msb.unpack(bv.bits(39, 12));
    punt_lm_cmd.unpack(bv.bits(11, 0));
}



field_structure npl_punt_msb_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_msb_encap_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("punt_encap_msb", punt_encap_msb.to_field_structure());
    fs_result.subfields.emplace_back("punt_lm_cmd", punt_lm_cmd.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_msb_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_msb_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_stage_assoc_data_result_t::pack(void) const // union
{
    bit_vector192_t bv(0, 145);
    { // union compound field start
        bit_vector192_t tbv = raw.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(144, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = narrow.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(144, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = wide.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(144, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = narrow_protection.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(144, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = wide_protection.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(144, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_resolution_stage_assoc_data_result_t::unpack(bit_vector192_t bv) // union
{
    raw.unpack(bv.bits(144, 0));
}



field_structure npl_resolution_stage_assoc_data_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_stage_assoc_data_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = raw.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("raw", raw.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = narrow.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("narrow", narrow.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = wide.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("wide", wide.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = narrow_protection.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("narrow_protection", narrow_protection.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = wide_protection.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("wide_protection", wide_protection.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_resolution_stage_assoc_data_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_stage_assoc_data_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_rtf_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    // PADDING -  bv.set_bits(63, 63, padding);
    bv.set_bits(62, 62, rtf_profile_index);
    bv.set_bits(61, 0, rtf_result_profile.pack());
    return bv;
}


void npl_rtf_payload_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(63, 63).get_value();
    rtf_profile_index = (npl_rtf_profile_type_e)bv.bits(62, 62).get_value();
    rtf_result_profile.unpack(bv.bits(61, 0));
}



field_structure npl_rtf_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_rtf_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = npl_enum_to_string(rtf_profile_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("rtf_profile_index", fs_subfield);
    
    fs_result.subfields.emplace_back("rtf_result_profile", rtf_result_profile.to_field_structure());
    return fs_result;
}
std::string to_string(npl_rtf_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_rtf_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_slp_info_t::pack(void) const 
{
    bit_vector64_t bv(0, 22);
    bv.set_bits(21, 20, slp_profile);
    bv.set_bits(19, 0, global_slp_id.pack());
    return bv;
}


void npl_slp_info_t::unpack(bit_vector64_t bv) 
{
    slp_profile = bv.bits(21, 20).get_value();
    global_slp_id.unpack(bv.bits(19, 0));
}



field_structure npl_slp_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_slp_info_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(slp_profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("slp_profile", fs_subfield);
    
    fs_result.subfields.emplace_back("global_slp_id", global_slp_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_slp_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_slp_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_snoop_or_rcy_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 8);
    bv.set_bits(7, 0, snoop_or_rcy_data.pack());
    return bv;
}


void npl_snoop_or_rcy_data_t::unpack(bit_vector64_t bv) 
{
    snoop_or_rcy_data.unpack(bv.bits(7, 0));
}



field_structure npl_snoop_or_rcy_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_snoop_or_rcy_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("snoop_or_rcy_data", snoop_or_rcy_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_snoop_or_rcy_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_snoop_or_rcy_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_std_ip_em_lpm_result_host_and_l3_dlp_t::pack(void) const 
{
    bit_vector128_t bv(0, 124);
    bv.set_bits(123, 84, lpm_payload);
    bv.set_bits(83, 20, host_nh_mac.pack());
    bv.set_bits(19, 0, dest_or_dest_with_class_id.pack());
    return bv;
}


void npl_std_ip_em_lpm_result_host_and_l3_dlp_t::unpack(bit_vector128_t bv) 
{
    lpm_payload = bv.bits(123, 84).get_value();
    host_nh_mac.unpack(bv.bits(83, 20));
    dest_or_dest_with_class_id.unpack(bv.bits(19, 0));
}



field_structure npl_std_ip_em_lpm_result_host_and_l3_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_std_ip_em_lpm_result_host_and_l3_dlp_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(lpm_payload);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lpm_payload", fs_subfield);
    
    fs_result.subfields.emplace_back("host_nh_mac", host_nh_mac.to_field_structure());
    fs_result.subfields.emplace_back("dest_or_dest_with_class_id", dest_or_dest_with_class_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_std_ip_em_lpm_result_host_and_l3_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_std_ip_em_lpm_result_host_and_l3_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_std_ip_em_lpm_result_ptr_and_l3_dlp_t::pack(void) const 
{
    bit_vector128_t bv(0, 124);
    bv.set_bits(55, 20, host_ptr.pack());
    bv.set_bits(19, 0, destination.pack());
    return bv;
}


void npl_std_ip_em_lpm_result_ptr_and_l3_dlp_t::unpack(bit_vector128_t bv) 
{
    host_ptr.unpack(bv.bits(55, 20));
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_std_ip_em_lpm_result_ptr_and_l3_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_std_ip_em_lpm_result_ptr_and_l3_dlp_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("host_ptr", host_ptr.to_field_structure());
    fs_result.subfields.emplace_back("destination", destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_std_ip_em_lpm_result_ptr_and_l3_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_std_ip_em_lpm_result_ptr_and_l3_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_std_ip_uc_lpm_results_t_anonymous_union_result_t::pack(void) const // union
{
    bit_vector128_t bv(0, 124);
    { // union compound field start
        bit_vector128_t tbv = ptr_and_l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(123, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = host_and_l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(123, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = destination_from_lpm.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(123, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mc_result.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(63, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = sgt_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_std_ip_uc_lpm_results_t_anonymous_union_result_t::unpack(bit_vector128_t bv) // union
{
    ptr_and_l3_dlp.unpack(bv.bits(123, 0));
}



field_structure npl_std_ip_uc_lpm_results_t_anonymous_union_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_std_ip_uc_lpm_results_t_anonymous_union_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = ptr_and_l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ptr_and_l3_dlp", ptr_and_l3_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = host_and_l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("host_and_l3_dlp", host_and_l3_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = destination_from_lpm.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("destination_from_lpm", destination_from_lpm.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mc_result.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mc_result", mc_result.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = sgt_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("sgt_data", sgt_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_std_ip_uc_lpm_results_t_anonymous_union_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_std_ip_uc_lpm_results_t_anonymous_union_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_svi_eve_profile_and_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 28);
    bv.set_bits(27, 26, main_type);
    bv.set_bits(25, 12, sub_type_or_vid_2_plus_prf.pack());
    bv.set_bits(11, 0, vid1);
    return bv;
}


void npl_svi_eve_profile_and_data_t::unpack(bit_vector64_t bv) 
{
    main_type = (npl_vlan_edit_command_main_type_e)bv.bits(27, 26).get_value();
    sub_type_or_vid_2_plus_prf.unpack(bv.bits(25, 12));
    vid1 = bv.bits(11, 0).get_value();
}



field_structure npl_svi_eve_profile_and_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_svi_eve_profile_and_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(main_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("main_type", fs_subfield);
    
    fs_result.subfields.emplace_back("sub_type_or_vid_2_plus_prf", sub_type_or_vid_2_plus_prf.to_field_structure());
    fs_subfield.flat_value = to_hex_string(vid1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vid1", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_svi_eve_profile_and_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_svi_eve_profile_and_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_tm_headers_template_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 0, u.pack());
    return bv;
}


void npl_tm_headers_template_t::unpack(bit_vector64_t bv) 
{
    u.unpack(bv.bits(47, 0));
}



field_structure npl_tm_headers_template_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_tm_headers_template_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("u", u.to_field_structure());
    return fs_result;
}
std::string to_string(npl_tm_headers_template_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_tm_headers_template_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ac_dlp_specific_t_anonymous_union_eve_types_t::pack(void) const // union
{
    bit_vector64_t bv(0, 28);
    { // union compound field start
        bit_vector64_t tbv = eve.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = eve_svi.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(27, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ac_dlp_specific_t_anonymous_union_eve_types_t::unpack(bit_vector64_t bv) // union
{
    eve.unpack(bv.bits(27, 0));
}



field_structure npl_ac_dlp_specific_t_anonymous_union_eve_types_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ac_dlp_specific_t_anonymous_union_eve_types_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = eve.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("eve", eve.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = eve_svi.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("eve_svi", eve_svi.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ac_dlp_specific_t_anonymous_union_eve_types_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ac_dlp_specific_t_anonymous_union_eve_types_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_app_mc_cud_narrow_even_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 60, raw);
    bv.set_bits(59, 20, app_mc_cud_narrow.pack());
    bv.set_bits(19, 0, raw1);
    return bv;
}


void npl_app_mc_cud_narrow_even_t::unpack(bit_vector128_t bv) 
{
    raw = bv.bits(119, 60).get_value();
    app_mc_cud_narrow.unpack(bv.bits(59, 20));
    raw1 = bv.bits(19, 0).get_value();
}



field_structure npl_app_mc_cud_narrow_even_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_mc_cud_narrow_even_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(raw);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("raw", fs_subfield);
    
    fs_result.subfields.emplace_back("app_mc_cud_narrow", app_mc_cud_narrow.to_field_structure());
    fs_subfield.flat_value = to_hex_string(raw1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("raw1", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_app_mc_cud_narrow_even_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_mc_cud_narrow_even_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_app_mc_cud_narrow_odd_and_even_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 80, odd.pack());
    bv.set_bits(79, 60, raw);
    bv.set_bits(59, 20, even.pack());
    bv.set_bits(19, 0, raw1);
    return bv;
}


void npl_app_mc_cud_narrow_odd_and_even_t::unpack(bit_vector128_t bv) 
{
    odd.unpack(bv.bits(119, 80));
    raw = bv.bits(79, 60).get_value();
    even.unpack(bv.bits(59, 20));
    raw1 = bv.bits(19, 0).get_value();
}



field_structure npl_app_mc_cud_narrow_odd_and_even_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_mc_cud_narrow_odd_and_even_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("odd", odd.to_field_structure());
    fs_subfield.flat_value = to_hex_string(raw);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("raw", fs_subfield);
    
    fs_result.subfields.emplace_back("even", even.to_field_structure());
    fs_subfield.flat_value = to_hex_string(raw1);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("raw1", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_app_mc_cud_narrow_odd_and_even_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_mc_cud_narrow_odd_and_even_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_app_mc_cud_narrow_odd_t::pack(void) const 
{
    bit_vector128_t bv(0, 120);
    bv.set_bits(119, 80, app_mc_cud_narrow.pack());
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = reserved;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
    return bv;
}


void npl_app_mc_cud_narrow_odd_t::unpack(bit_vector128_t bv) 
{
    app_mc_cud_narrow.unpack(bv.bits(119, 80));
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        uint64_t * p = reserved;
        while (msb < max_msb) {
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            *p = bv.bits(msb, lsb).get_value();
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
    } // array field end
    
}



field_structure npl_app_mc_cud_narrow_odd_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_mc_cud_narrow_odd_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("app_mc_cud_narrow", app_mc_cud_narrow.to_field_structure());
    { // array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 40;
        size_t max_msb = lsb + 80 - 1;
        size_t msb = 0;
        const uint64_t * p = reserved;
        int i = 0;
        while (msb < max_msb) {
            field_structure fs_sub;
            fs_sub.field_type = "int";
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            fs_sub.flat_value = to_hex_string(*p);
            fs_result.subfields.emplace_back("primitive_" + std::to_string(i), fs_sub);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            i++;
            p++;
        }
    } // array field end
    
    return fs_result;
}
std::string to_string(npl_app_mc_cud_narrow_odd_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_mc_cud_narrow_odd_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_base_l3_lp_attr_union_t::pack(void) const // union
{
    bit_vector128_t bv(0, 120);
    { // union compound field start
        bit_vector128_t tbv = update.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = base.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_base_l3_lp_attr_union_t::unpack(bit_vector128_t bv) // union
{
    update.unpack(bv.bits(119, 0));
}



field_structure npl_base_l3_lp_attr_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_base_l3_lp_attr_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = update.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("update", update.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = base.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("base", base.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_base_l3_lp_attr_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_base_l3_lp_attr_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_em_result_ptr_and_l3_dlp_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    bv.set_bits(61, 26, host_ptr.pack());
    // PADDING -  bv.set_bits(25, 20, padding);
    bv.set_bits(19, 0, destination.pack());
    return bv;
}


void npl_em_result_ptr_and_l3_dlp_t::unpack(bit_vector64_t bv) 
{
    host_ptr.unpack(bv.bits(61, 26));
    // PADDING -  padding = bv.bits(25, 20).get_value();
    destination.unpack(bv.bits(19, 0));
}



field_structure npl_em_result_ptr_and_l3_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_em_result_ptr_and_l3_dlp_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("host_ptr", host_ptr.to_field_structure());
    
    fs_result.subfields.emplace_back("destination", destination.to_field_structure());
    return fs_result;
}
std::string to_string(npl_em_result_ptr_and_l3_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_em_result_ptr_and_l3_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_inject_down_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 48, bfd_ih_down.pack());
    bv.set_bits(47, 20, inject_down.pack());
    bv.set_bits(19, 0, counter_ptr.pack());
    return bv;
}


void npl_inject_down_data_t::unpack(bit_vector128_t bv) 
{
    bfd_ih_down.unpack(bv.bits(79, 48));
    inject_down.unpack(bv.bits(47, 20));
    counter_ptr.unpack(bv.bits(19, 0));
}



field_structure npl_inject_down_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_down_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("bfd_ih_down", bfd_ih_down.to_field_structure());
    fs_result.subfields.emplace_back("inject_down", inject_down.to_field_structure());
    fs_result.subfields.emplace_back("counter_ptr", counter_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_down_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_down_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_specific_data_t_anonymous_union_inject_data_t::pack(void) const // union
{
    bit_vector64_t bv(0, 36);
    { // union compound field start
        bit_vector64_t tbv = inject_down_u.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 8, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_up_eth.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_up_none_routable_mc_lpts.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 16, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_vxlan_mc_up.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(35, 8, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_inject_specific_data_t_anonymous_union_inject_data_t::unpack(bit_vector64_t bv) // union
{
    inject_down_u.unpack(bv.bits(35, 8));
}



field_structure npl_inject_specific_data_t_anonymous_union_inject_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_specific_data_t_anonymous_union_inject_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = inject_down_u.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_down_u", inject_down_u.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_up_eth.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_up_eth", inject_up_eth.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_up_none_routable_mc_lpts.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_up_none_routable_mc_lpts", inject_up_none_routable_mc_lpts.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = inject_vxlan_mc_up.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_vxlan_mc_up", inject_vxlan_mc_up.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_inject_specific_data_t_anonymous_union_inject_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_specific_data_t_anonymous_union_inject_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_em_result_t_anonymous_union_result_t::pack(void) const // union
{
    bit_vector64_t bv(0, 63);
    { // union compound field start
        bit_vector64_t tbv = em_dest.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(62, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ptr_and_l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dsp_host.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(62, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dsp_host_w_class.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(62, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dsp_host_wo_class.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(62, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mc_result.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(61, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ip_em_result_t_anonymous_union_result_t::unpack(bit_vector64_t bv) // union
{
    em_dest.unpack(bv.bits(62, 0));
}



field_structure npl_ip_em_result_t_anonymous_union_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_em_result_t_anonymous_union_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = em_dest.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("em_dest", em_dest.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ptr_and_l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ptr_and_l3_dlp", ptr_and_l3_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dsp_host.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("dsp_host", dsp_host.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dsp_host_w_class.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("dsp_host_w_class", dsp_host_w_class.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dsp_host_wo_class.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("dsp_host_wo_class", dsp_host_wo_class.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = mc_result.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mc_result", mc_result.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ip_em_result_t_anonymous_union_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_em_result_t_anonymous_union_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_mc_result_em_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 62);
    bv.set_bits(61, 0, raw_payload.pack());
    return bv;
}


void npl_ip_mc_result_em_payload_t::unpack(bit_vector64_t bv) 
{
    raw_payload.unpack(bv.bits(61, 0));
}



field_structure npl_ip_mc_result_em_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_mc_result_em_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("raw_payload", raw_payload.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_mc_result_em_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_mc_result_em_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_lp_extra_data_with_padding_t_anonymous_union_l3_punt_info_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = l3_lp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(15, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pfc.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(14, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_l3_lp_extra_data_with_padding_t_anonymous_union_l3_punt_info_t::unpack(bit_vector64_t bv) // union
{
    l3_lp.unpack(bv.bits(15, 0));
}



field_structure npl_l3_lp_extra_data_with_padding_t_anonymous_union_l3_punt_info_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_lp_extra_data_with_padding_t_anonymous_union_l3_punt_info_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l3_lp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_lp", l3_lp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pfc.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pfc", pfc.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_l3_lp_extra_data_with_padding_t_anonymous_union_l3_punt_info_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_lp_extra_data_with_padding_t_anonymous_union_l3_punt_info_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_lp_with_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    // PADDING -  bv.set_bits(19, 16, padding);
    bv.set_bits(15, 0, l3_lp.pack());
    return bv;
}


void npl_l3_lp_with_padding_t::unpack(bit_vector64_t bv) 
{
    // PADDING -  padding = bv.bits(19, 16).get_value();
    l3_lp.unpack(bv.bits(15, 0));
}



field_structure npl_l3_lp_with_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_lp_with_padding_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_result.subfields.emplace_back("l3_lp", l3_lp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_lp_with_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_lp_with_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_lsp_encap_mapping_data_payload_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 20, label_stack.pack());
    bv.set_bits(19, 0, counter_and_flag.pack());
    return bv;
}


void npl_lsp_encap_mapping_data_payload_t::unpack(bit_vector128_t bv) 
{
    label_stack.unpack(bv.bits(79, 20));
    counter_and_flag.unpack(bv.bits(19, 0));
}



field_structure npl_lsp_encap_mapping_data_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_lsp_encap_mapping_data_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("label_stack", label_stack.to_field_structure());
    fs_result.subfields.emplace_back("counter_and_flag", counter_and_flag.to_field_structure());
    return fs_result;
}
std::string to_string(npl_lsp_encap_mapping_data_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_lsp_encap_mapping_data_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mac_lp_attributes_payload_t::pack(void) const 
{
    bit_vector192_t bv(0, 144);
    // PADDING -  bv.set_bits(143, 143, padding);
    bv.set_bits(142, 142, mac_lp_type);
    bv.set_bits(141, 0, layer.pack());
    return bv;
}


void npl_mac_lp_attributes_payload_t::unpack(bit_vector192_t bv) 
{
    // PADDING -  padding = bv.bits(143, 143).get_value();
    mac_lp_type = (npl_mac_lp_type_e)bv.bits(142, 142).get_value();
    layer.unpack(bv.bits(141, 0));
}



field_structure npl_mac_lp_attributes_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_lp_attributes_payload_t";
    field_structure fs_subfield;
    //add members to result
    
    fs_subfield.flat_value = npl_enum_to_string(mac_lp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mac_lp_type", fs_subfield);
    
    fs_result.subfields.emplace_back("layer", layer.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_lp_attributes_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_lp_attributes_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mac_lp_attributes_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 16, payload.pack());
    bv.set_bits(15, 0, local_slp_id.pack());
    return bv;
}


void npl_mac_lp_attributes_t::unpack(bit_vector192_t bv) 
{
    payload.unpack(bv.bits(159, 16));
    local_slp_id.unpack(bv.bits(15, 0));
}



field_structure npl_mac_lp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_lp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("payload", payload.to_field_structure());
    fs_result.subfields.emplace_back("local_slp_id", local_slp_id.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_lp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_lp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mac_lp_attributes_table_payload_t::pack(void) const // union
{
    bit_vector192_t bv(0, 144);
    { // union compound field start
        bit_vector192_t tbv = lp_attr.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(143, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mac_lp_attributes_table_payload_t::unpack(bit_vector192_t bv) // union
{
    lp_attr.unpack(bv.bits(143, 0));
}



field_structure npl_mac_lp_attributes_table_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_lp_attributes_table_payload_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = lp_attr.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lp_attr", lp_attr.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mac_lp_attributes_table_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_lp_attributes_table_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mac_relay_pack_table_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 29);
    bv.set_bits(28, 22, local_mapped_qos_group);
    bv.set_bits(21, 0, muxed_slp_info.pack());
    return bv;
}


void npl_mac_relay_pack_table_payload_t::unpack(bit_vector64_t bv) 
{
    local_mapped_qos_group = bv.bits(28, 22).get_value();
    muxed_slp_info.unpack(bv.bits(21, 0));
}



field_structure npl_mac_relay_pack_table_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mac_relay_pack_table_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(local_mapped_qos_group);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("local_mapped_qos_group", fs_subfield);
    
    fs_result.subfields.emplace_back("muxed_slp_info", muxed_slp_info.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mac_relay_pack_table_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mac_relay_pack_table_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 50);
    bv.set_bits(49, 48, service);
    bv.set_bits(47, 0, pwe_vpn_mldp_info.pack());
    return bv;
}


void npl_mpls_termination_result_t::unpack(bit_vector64_t bv) 
{
    service = (npl_mpls_service_e)bv.bits(49, 48).get_value();
    pwe_vpn_mldp_info.unpack(bv.bits(47, 0));
}



field_structure npl_mpls_termination_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(service);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("service", fs_subfield);
    
    fs_result.subfields.emplace_back("pwe_vpn_mldp_info", pwe_vpn_mldp_info.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mpls_termination_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_nhlfe_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 60, type);
    bv.set_bits(59, 0, nhlfe_payload.pack());
    return bv;
}


void npl_nhlfe_t::unpack(bit_vector64_t bv) 
{
    type = (npl_nhlfe_type_e)bv.bits(63, 60).get_value();
    nhlfe_payload.unpack(bv.bits(59, 0));
}



field_structure npl_nhlfe_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_nhlfe_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("type", fs_subfield);
    
    fs_result.subfields.emplace_back("nhlfe_payload", nhlfe_payload.to_field_structure());
    return fs_result;
}
std::string to_string(npl_nhlfe_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_nhlfe_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_npu_encap_header_ip_host_t::pack(void) const 
{
    bit_vector128_t bv(0, 68);
    bv.set_bits(67, 64, l3_encapsulation_type);
    bv.set_bits(63, 0, next_hop.pack());
    return bv;
}


void npl_npu_encap_header_ip_host_t::unpack(bit_vector128_t bv) 
{
    l3_encapsulation_type = (npl_npu_encap_l3_header_type_e)bv.bits(67, 64).get_value();
    next_hop.unpack(bv.bits(63, 0));
}



field_structure npl_npu_encap_header_ip_host_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_encap_header_ip_host_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(l3_encapsulation_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_encapsulation_type", fs_subfield);
    
    fs_result.subfields.emplace_back("next_hop", next_hop.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_encap_header_ip_host_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_encap_header_ip_host_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_npu_l2_encap_header_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 76, l2_encapsulation_type);
    bv.set_bits(75, 8, l2_dlp_type.pack());
    bv.set_bits(7, 0, npu_pif_ifg.pack());
    return bv;
}


void npl_npu_l2_encap_header_t::unpack(bit_vector128_t bv) 
{
    l2_encapsulation_type = (npl_npu_encap_l2_header_type_e)bv.bits(79, 76).get_value();
    l2_dlp_type.unpack(bv.bits(75, 8));
    npu_pif_ifg.unpack(bv.bits(7, 0));
}



field_structure npl_npu_l2_encap_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l2_encap_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(l2_encapsulation_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l2_encapsulation_type", fs_subfield);
    
    fs_result.subfields.emplace_back("l2_dlp_type", l2_dlp_type.to_field_structure());
    fs_result.subfields.emplace_back("npu_pif_ifg", npu_pif_ifg.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_l2_encap_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l2_encap_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_npu_l3_common_encap_header_t::pack(void) const 
{
    bit_vector64_t bv(0, 32);
    bv.set_bits(31, 28, l3_encap_type);
    bv.set_bits(27, 0, l3_dlp_nh_encap.pack());
    return bv;
}


void npl_npu_l3_common_encap_header_t::unpack(bit_vector64_t bv) 
{
    l3_encap_type = (npl_npu_encap_l3_header_type_e)bv.bits(31, 28).get_value();
    l3_dlp_nh_encap.unpack(bv.bits(27, 0));
}



field_structure npl_npu_l3_common_encap_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_common_encap_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(l3_encap_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("l3_encap_type", fs_subfield);
    
    fs_result.subfields.emplace_back("l3_dlp_nh_encap", l3_dlp_nh_encap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_l3_common_encap_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_common_encap_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_npu_l3_encap_header_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 48, l3_common_encap.pack());
    bv.set_bits(47, 0, encap_ext.pack());
    return bv;
}


void npl_npu_l3_encap_header_t::unpack(bit_vector128_t bv) 
{
    l3_common_encap.unpack(bv.bits(79, 48));
    encap_ext.unpack(bv.bits(47, 0));
}



field_structure npl_npu_l3_encap_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_l3_encap_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_common_encap", l3_common_encap.to_field_structure());
    fs_result.subfields.emplace_back("encap_ext", encap_ext.to_field_structure());
    return fs_result;
}
std::string to_string(npl_npu_l3_encap_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_l3_encap_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_og_em_padded_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 68);
    bv.set_bits(67, 4, og_em_result.pack());
    // PADDING -  bv.set_bits(3, 0, padding);
    return bv;
}


void npl_og_em_padded_result_t::unpack(bit_vector128_t bv) 
{
    og_em_result.unpack(bv.bits(67, 4));
    // PADDING -  padding = bv.bits(3, 0).get_value();
}



field_structure npl_og_em_padded_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_og_em_padded_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("og_em_result", og_em_result.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_og_em_padded_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_og_em_padded_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_punt_encap_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 40, punt_msb_encap.pack());
    bv.set_bits(39, 0, punt_lsb_encap.pack());
    return bv;
}


void npl_punt_encap_data_t::unpack(bit_vector128_t bv) 
{
    punt_msb_encap.unpack(bv.bits(79, 40));
    punt_lsb_encap.unpack(bv.bits(39, 0));
}



field_structure npl_punt_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("punt_msb_encap", punt_msb_encap.to_field_structure());
    fs_result.subfields.emplace_back("punt_lsb_encap", punt_lsb_encap.to_field_structure());
    return fs_result;
}
std::string to_string(npl_punt_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_header_t_anonymous_union_slp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = l2_slp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_slp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_punt_header_t_anonymous_union_slp_t::unpack(bit_vector64_t bv) // union
{
    l2_slp.unpack(bv.bits(19, 0));
}



field_structure npl_punt_header_t_anonymous_union_slp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_header_t_anonymous_union_slp_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_slp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_slp", l2_slp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_slp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_slp", l3_slp.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_punt_header_t_anonymous_union_slp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_header_t_anonymous_union_slp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_raw_ip_mc_result_t::pack(void) const 
{
    bit_vector128_t bv(0, 66);
    bv.set_bits(65, 4, result_payload.pack());
    bv.set_bits(3, 0, raw);
    return bv;
}


void npl_raw_ip_mc_result_t::unpack(bit_vector128_t bv) 
{
    result_payload.unpack(bv.bits(65, 4));
    raw = bv.bits(3, 0).get_value();
}



field_structure npl_raw_ip_mc_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_raw_ip_mc_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("result_payload", result_payload.to_field_structure());
    fs_subfield.flat_value = to_hex_string(raw);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("raw", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_raw_ip_mc_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_raw_ip_mc_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_resolution_result_enc_data_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = l3.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ip_collapsed_mc_encap_header.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 40, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = mpls_mc_host_encap_header.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 12, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dlp_attributes.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pif_ifg_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(7, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_resolution_result_enc_data_t::unpack(bit_vector128_t bv) // union
{
    l2.unpack(bv.bits(79, 0));
}



field_structure npl_resolution_result_enc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_result_enc_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = l2.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2", l2.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = l3.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3", l3.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = ip_collapsed_mc_encap_header.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ip_collapsed_mc_encap_header", ip_collapsed_mc_encap_header.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = mpls_mc_host_encap_header.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mpls_mc_host_encap_header", mpls_mc_host_encap_header.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = dlp_attributes.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("dlp_attributes", dlp_attributes.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pif_ifg_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pif_ifg_data", pif_ifg_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_resolution_result_enc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_result_enc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_std_ip_uc_lpm_results_t::pack(void) const 
{
    bit_vector128_t bv(0, 128);
    bv.set_bits(127, 4, result.pack());
    // PADDING -  bv.set_bits(3, 1, padding);
    bv.set_bits(0, 0, is_default_unused);
    return bv;
}


void npl_std_ip_uc_lpm_results_t::unpack(bit_vector128_t bv) 
{
    result.unpack(bv.bits(127, 4));
    // PADDING -  padding = bv.bits(3, 1).get_value();
    is_default_unused = bv.bits(0, 0).get_value();
}



field_structure npl_std_ip_uc_lpm_results_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_std_ip_uc_lpm_results_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("result", result.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(is_default_unused);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("is_default_unused", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_std_ip_uc_lpm_results_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_std_ip_uc_lpm_results_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_wrap_nhlfe_t::pack(void) const 
{
    bit_vector128_t bv(0, 68);
    bv.set_bits(67, 4, nhlfe.pack());
    bv.set_bits(3, 0, reserved);
    return bv;
}


void npl_wrap_nhlfe_t::unpack(bit_vector128_t bv) 
{
    nhlfe.unpack(bv.bits(67, 4));
    reserved = bv.bits(3, 0).get_value();
}



field_structure npl_wrap_nhlfe_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_wrap_nhlfe_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("nhlfe", nhlfe.to_field_structure());
    fs_subfield.flat_value = to_hex_string(reserved);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reserved", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_wrap_nhlfe_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_wrap_nhlfe_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ac_dlp_specific_t::pack(void) const 
{
    bit_vector64_t bv(0, 52);
    bv.set_bits(51, 32, vlan_after_eve_format);
    bv.set_bits(31, 4, eve_types.pack());
    bv.set_bits(3, 3, mep_exists);
    bv.set_bits(2, 0, max_mep_level);
    return bv;
}


void npl_ac_dlp_specific_t::unpack(bit_vector64_t bv) 
{
    vlan_after_eve_format = bv.bits(51, 32).get_value();
    eve_types.unpack(bv.bits(31, 4));
    mep_exists = bv.bits(3, 3).get_value();
    max_mep_level = bv.bits(2, 0).get_value();
}



field_structure npl_ac_dlp_specific_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ac_dlp_specific_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(vlan_after_eve_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("vlan_after_eve_format", fs_subfield);
    
    fs_result.subfields.emplace_back("eve_types", eve_types.to_field_structure());
    fs_subfield.flat_value = to_hex_string(mep_exists);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_exists", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(max_mep_level);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("max_mep_level", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_ac_dlp_specific_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ac_dlp_specific_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_app_mc_cud_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 0, npu_encap_data.pack());
    return bv;
}


void npl_app_mc_cud_t::unpack(bit_vector128_t bv) 
{
    npu_encap_data.unpack(bv.bits(79, 0));
}



field_structure npl_app_mc_cud_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_mc_cud_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("npu_encap_data", npu_encap_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_app_mc_cud_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_mc_cud_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_slp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = l2_slp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_slp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_slp_t::unpack(bit_vector64_t bv) // union
{
    l2_slp.unpack(bv.bits(19, 0));
}



field_structure npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_slp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_slp_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_slp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_slp", l2_slp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_slp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_slp", l3_slp.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_slp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_slp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_specific_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 36);
    bv.set_bits(35, 0, inject_data.pack());
    return bv;
}


void npl_inject_specific_data_t::unpack(bit_vector64_t bv) 
{
    inject_data.unpack(bv.bits(35, 0));
}



field_structure npl_inject_specific_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_specific_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("inject_data", inject_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_specific_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_specific_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_ip_em_lpm_result_t_anonymous_union_result_t::pack(void) const // union
{
    bit_vector128_t bv(0, 128);
    { // union compound field start
        bit_vector128_t tbv = lpm_result.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(127, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = destination_with_default.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(87, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ip_em_lpm_result_t_anonymous_union_result_t::unpack(bit_vector128_t bv) // union
{
    lpm_result.unpack(bv.bits(127, 0));
}



field_structure npl_ip_em_lpm_result_t_anonymous_union_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_em_lpm_result_t_anonymous_union_result_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = lpm_result.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("lpm_result", lpm_result.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = destination_with_default.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("destination_with_default", destination_with_default.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ip_em_lpm_result_t_anonymous_union_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_em_lpm_result_t_anonymous_union_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ip_em_result_t::pack(void) const 
{
    bit_vector64_t bv(0, 64);
    bv.set_bits(63, 63, result_type);
    bv.set_bits(62, 0, result.pack());
    return bv;
}


void npl_ip_em_result_t::unpack(bit_vector64_t bv) 
{
    result_type = (npl_ip_uc_em_result_type_e)bv.bits(63, 63).get_value();
    result.unpack(bv.bits(62, 0));
}



field_structure npl_ip_em_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_em_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(result_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("result_type", fs_subfield);
    
    fs_result.subfields.emplace_back("result", result.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ip_em_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_em_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l2_dlp_specific_t::pack(void) const // union
{
    bit_vector64_t bv(0, 52);
    { // union compound field start
        bit_vector64_t tbv = ac.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(51, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pwe.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(51, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_l2_dlp_specific_t::unpack(bit_vector64_t bv) // union
{
    ac.unpack(bv.bits(51, 0));
}



field_structure npl_l2_dlp_specific_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_dlp_specific_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = ac.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("ac", ac.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = pwe.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pwe", pwe.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_l2_dlp_specific_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_dlp_specific_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_l3_lp_extra_data_with_padding_t::pack(void) const 
{
    bit_vector64_t bv(0, 20);
    bv.set_bits(19, 0, l3_punt_info.pack());
    return bv;
}


void npl_l3_lp_extra_data_with_padding_t::unpack(bit_vector64_t bv) 
{
    l3_punt_info.unpack(bv.bits(19, 0));
}



field_structure npl_l3_lp_extra_data_with_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l3_lp_extra_data_with_padding_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("l3_punt_info", l3_punt_info.to_field_structure());
    return fs_result;
}
std::string to_string(npl_l3_lp_extra_data_with_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l3_lp_extra_data_with_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_mpls_termination_res_t::pack(void) const 
{
    bit_vector64_t bv(0, 50);
    bv.set_bits(49, 0, result.pack());
    return bv;
}


void npl_mpls_termination_res_t::unpack(bit_vector64_t bv) 
{
    result.unpack(bv.bits(49, 0));
}



field_structure npl_mpls_termination_res_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mpls_termination_res_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("result", result.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mpls_termination_res_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mpls_termination_res_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_punt_app_encap_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = punt_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = fabric_mc_ibm_cmd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 56, tbv);
            return bv;
        }
    } // union compound field end
    
    if (dcf_data != 0) {  // union primitive field start
        bv.set_bits(79, 42, dcf_data);
        return bv;
    }// union primitive field end
    
    return bv;
}


void npl_punt_app_encap_t::unpack(bit_vector128_t bv) // union
{
    punt_encap_data.unpack(bv.bits(79, 0));
}



field_structure npl_punt_app_encap_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_app_encap_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = punt_encap_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("punt_encap_data", punt_encap_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = fabric_mc_ibm_cmd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("fabric_mc_ibm_cmd", fabric_mc_ibm_cmd.to_field_structure());
        }
    } // union compound field end
    
    if (dcf_data != 0) {  // union primitive field start
        field_structure union_found;
        union_found.field_type = "int";
        union_found.flat_value = to_hex_string(dcf_data);
        return union_found;
    }// union primitive field end
    
    return fs_result;
}
std::string to_string(npl_punt_app_encap_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_app_encap_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_punt_header_t_anonymous_union_dlp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = l2_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_punt_header_t_anonymous_union_dlp_t::unpack(bit_vector64_t bv) // union
{
    l2_dlp.unpack(bv.bits(19, 0));
}



field_structure npl_punt_header_t_anonymous_union_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_header_t_anonymous_union_dlp_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_dlp", l2_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_punt_header_t_anonymous_union_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_header_t_anonymous_union_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_resolution_result_dest_and_enc_data_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 80, enc.pack());
    bv.set_bits(79, 0, dest.pack());
    return bv;
}


void npl_resolution_result_dest_and_enc_data_t::unpack(bit_vector192_t bv) 
{
    enc.unpack(bv.bits(159, 80));
    dest.unpack(bv.bits(79, 0));
}



field_structure npl_resolution_result_dest_and_enc_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_resolution_result_dest_and_enc_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("enc", enc.to_field_structure());
    fs_result.subfields.emplace_back("dest", dest.to_field_structure());
    return fs_result;
}
std::string to_string(npl_resolution_result_dest_and_enc_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_resolution_result_dest_and_enc_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_app_mirror_cud_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = mirror_cud_encap.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_app_mirror_cud_t::unpack(bit_vector128_t bv) // union
{
    mirror_cud_encap.unpack(bv.bits(79, 0));
}



field_structure npl_app_mirror_cud_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_app_mirror_cud_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = mirror_cud_encap.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mirror_cud_encap", mirror_cud_encap.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_app_mirror_cud_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_app_mirror_cud_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_cud_mapping_local_vars_t_anonymous_union_mapped_cud_t::pack(void) const // union
{
    bit_vector128_t bv(0, 120);
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 40, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud_narrow_odd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud_narrow_even.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud_narrow_odd_and_even.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = mirror.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(119, 40, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 120 - 1;
        size_t msb = 0;
        const uint64_t * p = raw;
        bool is_found = false;
        while (msb < max_msb) {
            if (*p != 0)
            is_found = true;
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
        if (is_found)
        return bv;
    } // union array field end
    
    return bv;
}


void npl_cud_mapping_local_vars_t_anonymous_union_mapped_cud_t::unpack(bit_vector128_t bv) // union
{
    app_mc_cud.unpack(bv.bits(119, 40));
}



field_structure npl_cud_mapping_local_vars_t_anonymous_union_mapped_cud_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_cud_mapping_local_vars_t_anonymous_union_mapped_cud_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("app_mc_cud", app_mc_cud.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud_narrow_odd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("app_mc_cud_narrow_odd", app_mc_cud_narrow_odd.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud_narrow_even.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("app_mc_cud_narrow_even", app_mc_cud_narrow_even.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud_narrow_odd_and_even.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("app_mc_cud_narrow_odd_and_even", app_mc_cud_narrow_odd_and_even.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = mirror.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mirror", mirror.to_field_structure());
        }
    } // union compound field end
    
    { // union array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 120 - 1;
        size_t msb = 0;
        const uint64_t * p = raw;
        int i = 0;
        bool is_found = false;
        while (msb < max_msb) {
            if (*p != 0){
                is_found = true;
                field_structure fs_sub;
                fs_sub.field_type = "int";
                msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
                fs_sub.flat_value = to_hex_string(*p);
                fs_result.subfields.emplace_back("raw_" + std::to_string(i), fs_sub);
                lsb += sizeof(uint64_t) * BITS_PER_BYTE;
                i++;
            }
            p++;
            
        }
        if (is_found)
        {
            return fs_result;
        }
    } // union array field end
    
    return fs_result;
}
std::string to_string(npl_cud_mapping_local_vars_t_anonymous_union_mapped_cud_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_cud_mapping_local_vars_t_anonymous_union_mapped_cud_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_cud_mapping_local_vars_t_anonymous_union_wide_mc_cud_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = mirror.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_cud_mapping_local_vars_t_anonymous_union_wide_mc_cud_t::unpack(bit_vector128_t bv) // union
{
    app_mc_cud.unpack(bv.bits(79, 0));
}



field_structure npl_cud_mapping_local_vars_t_anonymous_union_wide_mc_cud_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_cud_mapping_local_vars_t_anonymous_union_wide_mc_cud_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = app_mc_cud.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("app_mc_cud", app_mc_cud.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = mirror.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("mirror", mirror.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_cud_mapping_local_vars_t_anonymous_union_wide_mc_cud_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_cud_mapping_local_vars_t_anonymous_union_wide_mc_cud_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_dlp_t::pack(void) const // union
{
    bit_vector64_t bv(0, 20);
    { // union compound field start
        bit_vector64_t tbv = l2_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(19, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_dlp_t::unpack(bit_vector64_t bv) // union
{
    l2_dlp.unpack(bv.bits(19, 0));
}



field_structure npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_dlp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_dlp_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector64_t tbv = l2_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l2_dlp", l2_dlp.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = l3_dlp.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("l3_dlp", l3_dlp.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_dlp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_dlp_and_slp_t_anonymous_union_ene_dlp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_ibm_encap_header_on_direct_t::pack(void) const 
{
    bit_vector192_t bv(0, 129);
    bv.set_bits(128, 128, wide_bit);
    // PADDING -  bv.set_bits(127, 80, padding);
    bv.set_bits(79, 0, ibm_encap_header.pack());
    return bv;
}


void npl_ibm_encap_header_on_direct_t::unpack(bit_vector192_t bv) 
{
    wide_bit = bv.bits(128, 128).get_value();
    // PADDING -  padding = bv.bits(127, 80).get_value();
    ibm_encap_header.unpack(bv.bits(79, 0));
}



field_structure npl_ibm_encap_header_on_direct_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ibm_encap_header_on_direct_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(wide_bit);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("wide_bit", fs_subfield);
    
    
    fs_result.subfields.emplace_back("ibm_encap_header", ibm_encap_header.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ibm_encap_header_on_direct_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ibm_encap_header_on_direct_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_inject_header_app_specific_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 56);
    bv.set_bits(55, 20, inject_specific_data.pack());
    bv.set_bits(19, 0, counter_ptr.pack());
    return bv;
}


void npl_inject_header_app_specific_data_t::unpack(bit_vector64_t bv) 
{
    inject_specific_data.unpack(bv.bits(55, 20));
    counter_ptr.unpack(bv.bits(19, 0));
}



field_structure npl_inject_header_app_specific_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_app_specific_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("inject_specific_data", inject_specific_data.to_field_structure());
    fs_result.subfields.emplace_back("counter_ptr", counter_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_header_app_specific_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_app_specific_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_inject_header_specific_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 88);
    bv.set_bits(87, 32, inject_header_app_specific_data.pack());
    bv.set_bits(31, 0, inject_header_encap_hdr_ptr.pack());
    return bv;
}


void npl_inject_header_specific_data_t::unpack(bit_vector128_t bv) 
{
    inject_header_app_specific_data.unpack(bv.bits(87, 32));
    inject_header_encap_hdr_ptr.unpack(bv.bits(31, 0));
}



field_structure npl_inject_header_specific_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_specific_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("inject_header_app_specific_data", inject_header_app_specific_data.to_field_structure());
    fs_result.subfields.emplace_back("inject_header_encap_hdr_ptr", inject_header_encap_hdr_ptr.to_field_structure());
    return fs_result;
}
std::string to_string(npl_inject_header_specific_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_specific_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_inject_header_t::pack(void) const 
{
    bit_vector192_t bv(0, 136);
    bv.set_bits(135, 128, inject_header_type);
    bv.set_bits(127, 40, inject_header_specific_data.pack());
    bv.set_bits(39, 16, ts_and_cntr_stamp_cmd.pack());
    bv.set_bits(15, 8, npl_internal_info.pack());
    bv.set_bits(7, 0, inject_header_trailer_type);
    return bv;
}


void npl_inject_header_t::unpack(bit_vector192_t bv) 
{
    inject_header_type = (npl_inject_header_type_e)bv.bits(135, 128).get_value();
    inject_header_specific_data.unpack(bv.bits(127, 40));
    ts_and_cntr_stamp_cmd.unpack(bv.bits(39, 16));
    npl_internal_info.unpack(bv.bits(15, 8));
    inject_header_trailer_type = (npl_inject_header_trailer_type_e)bv.bits(7, 0).get_value();
}



field_structure npl_inject_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(inject_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_header_type", fs_subfield);
    
    fs_result.subfields.emplace_back("inject_header_specific_data", inject_header_specific_data.to_field_structure());
    fs_result.subfields.emplace_back("ts_and_cntr_stamp_cmd", ts_and_cntr_stamp_cmd.to_field_structure());
    fs_result.subfields.emplace_back("npl_internal_info", npl_internal_info.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(inject_header_trailer_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_header_trailer_type", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_inject_header_with_time_t::pack(void) const 
{
    bit_vector192_t bv(0, 168);
    bv.set_bits(167, 32, base_inject_header.pack());
    bv.set_bits(31, 0, time_extension);
    return bv;
}


void npl_inject_header_with_time_t::unpack(bit_vector192_t bv) 
{
    base_inject_header.unpack(bv.bits(167, 32));
    time_extension = bv.bits(31, 0).get_value();
}



field_structure npl_inject_header_with_time_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_header_with_time_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("base_inject_header", base_inject_header.to_field_structure());
    fs_subfield.flat_value = to_hex_string(time_extension);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("time_extension", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_header_with_time_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_header_with_time_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_inject_up_data_t::pack(void) const 
{
    bit_vector128_t bv(0, 80);
    bv.set_bits(79, 24, bfd_ih_app.pack());
    // PADDING -  bv.set_bits(23, 12, padding);
    bv.set_bits(11, 0, inject_vlan_id);
    return bv;
}


void npl_inject_up_data_t::unpack(bit_vector128_t bv) 
{
    bfd_ih_app.unpack(bv.bits(79, 24));
    // PADDING -  padding = bv.bits(23, 12).get_value();
    inject_vlan_id = bv.bits(11, 0).get_value();
}



field_structure npl_inject_up_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_inject_up_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("bfd_ih_app", bfd_ih_app.to_field_structure());
    
    fs_subfield.flat_value = to_hex_string(inject_vlan_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_vlan_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_inject_up_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_inject_up_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_ip_em_lpm_result_t::pack(void) const 
{
    bit_vector192_t bv(0, 132);
    bv.set_bits(131, 4, result.pack());
    bv.set_bits(3, 2, result_type);
    bv.set_bits(1, 1, no_hbm_access);
    // PADDING -  bv.set_bits(0, 0, padding);
    return bv;
}


void npl_ip_em_lpm_result_t::unpack(bit_vector192_t bv) 
{
    result.unpack(bv.bits(131, 4));
    result_type = bv.bits(3, 2).get_value();
    no_hbm_access = bv.bits(1, 1).get_value();
    // PADDING -  padding = bv.bits(0, 0).get_value();
}



field_structure npl_ip_em_lpm_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ip_em_lpm_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("result", result.to_field_structure());
    fs_subfield.flat_value = to_hex_string(result_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("result_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(no_hbm_access);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("no_hbm_access", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_ip_em_lpm_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ip_em_lpm_result_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_l2_dlp_attributes_t::pack(void) const 
{
    bit_vector128_t bv(0, 121);
    bv.set_bits(120, 120, disabled);
    bv.set_bits(119, 119, stp_state_is_block);
    bv.set_bits(118, 112, dlp_attributes.pack());
    bv.set_bits(111, 104, tx_to_rx_rcy_data.pack());
    bv.set_bits(103, 52, l2_dlp_specific.pack());
    // PADDING -  bv.set_bits(51, 50, padding);
    bv.set_bits(49, 4, qos_attributes.pack());
    bv.set_bits(3, 0, acl_id);
    return bv;
}


void npl_l2_dlp_attributes_t::unpack(bit_vector128_t bv) 
{
    disabled = bv.bits(120, 120).get_value();
    stp_state_is_block = bv.bits(119, 119).get_value();
    dlp_attributes.unpack(bv.bits(118, 112));
    tx_to_rx_rcy_data.unpack(bv.bits(111, 104));
    l2_dlp_specific.unpack(bv.bits(103, 52));
    // PADDING -  padding = bv.bits(51, 50).get_value();
    qos_attributes.unpack(bv.bits(49, 4));
    acl_id = bv.bits(3, 0).get_value();
}



field_structure npl_l2_dlp_attributes_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_l2_dlp_attributes_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(disabled);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("disabled", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(stp_state_is_block);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("stp_state_is_block", fs_subfield);
    
    fs_result.subfields.emplace_back("dlp_attributes", dlp_attributes.to_field_structure());
    fs_result.subfields.emplace_back("tx_to_rx_rcy_data", tx_to_rx_rcy_data.to_field_structure());
    fs_result.subfields.emplace_back("l2_dlp_specific", l2_dlp_specific.to_field_structure());
    
    fs_result.subfields.emplace_back("qos_attributes", qos_attributes.to_field_structure());
    fs_subfield.flat_value = to_hex_string(acl_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("acl_id", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_l2_dlp_attributes_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_l2_dlp_attributes_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_pfc_mp_table_shared_payload_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 24, inj_header.pack());
    bv.set_bits(23, 20, inject_ifg_id);
    // PADDING -  bv.set_bits(19, 18, padding);
    bv.set_bits(17, 16, profile);
    // PADDING -  bv.set_bits(15, 0, padding);
    return bv;
}


void npl_pfc_mp_table_shared_payload_t::unpack(bit_vector192_t bv) 
{
    inj_header.unpack(bv.bits(159, 24));
    inject_ifg_id = bv.bits(23, 20).get_value();
    // PADDING -  padding = bv.bits(19, 18).get_value();
    profile = bv.bits(17, 16).get_value();
    // PADDING -  padding = bv.bits(15, 0).get_value();
}



field_structure npl_pfc_mp_table_shared_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_pfc_mp_table_shared_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("inj_header", inj_header.to_field_structure());
    fs_subfield.flat_value = to_hex_string(inject_ifg_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_ifg_id", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(profile);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("profile", fs_subfield);
    
    
    return fs_result;
}
std::string to_string(npl_pfc_mp_table_shared_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_pfc_mp_table_shared_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_punt_header_t::pack(void) const 
{
    bit_vector384_t bv(0, 224);
    bv.set_bits(223, 219, punt_next_header);
    bv.set_bits(218, 215, punt_fwd_header_type);
    bv.set_bits(214, 212, reserved);
    bv.set_bits(211, 204, pl_header_offset.pack());
    bv.set_bits(203, 192, punt_src_and_code.pack());
    bv.set_bits(191, 184, punt_sub_code.pack());
    bv.set_bits(183, 168, ssp);
    bv.set_bits(167, 152, dsp);
    bv.set_bits(151, 132, slp.pack());
    bv.set_bits(131, 112, dlp.pack());
    // PADDING -  bv.set_bits(111, 110, padding);
    bv.set_bits(109, 96, punt_relay_id.pack());
    bv.set_bits(95, 32, time_stamp_val);
    bv.set_bits(31, 0, receive_time);
    return bv;
}


void npl_punt_header_t::unpack(bit_vector384_t bv) 
{
    punt_next_header = (npl_protocol_type_e)bv.bits(223, 219).get_value();
    punt_fwd_header_type = (npl_fwd_header_type_e)bv.bits(218, 215).get_value();
    reserved = bv.bits(214, 212).get_value();
    pl_header_offset.unpack(bv.bits(211, 204));
    punt_src_and_code.unpack(bv.bits(203, 192));
    punt_sub_code.unpack(bv.bits(191, 184));
    ssp = bv.bits(183, 168).get_value();
    dsp = bv.bits(167, 152).get_value();
    slp.unpack(bv.bits(151, 132));
    dlp.unpack(bv.bits(131, 112));
    // PADDING -  padding = bv.bits(111, 110).get_value();
    punt_relay_id.unpack(bv.bits(109, 96));
    time_stamp_val = bv.bits(95, 32).get_value();
    receive_time = bv.bits(31, 0).get_value();
}



field_structure npl_punt_header_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_punt_header_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = npl_enum_to_string(punt_next_header);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_next_header", fs_subfield);
    
    fs_subfield.flat_value = npl_enum_to_string(punt_fwd_header_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("punt_fwd_header_type", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(reserved);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("reserved", fs_subfield);
    
    fs_result.subfields.emplace_back("pl_header_offset", pl_header_offset.to_field_structure());
    fs_result.subfields.emplace_back("punt_src_and_code", punt_src_and_code.to_field_structure());
    fs_result.subfields.emplace_back("punt_sub_code", punt_sub_code.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ssp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ssp", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dsp);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dsp", fs_subfield);
    
    fs_result.subfields.emplace_back("slp", slp.to_field_structure());
    fs_result.subfields.emplace_back("dlp", dlp.to_field_structure());
    
    fs_result.subfields.emplace_back("punt_relay_id", punt_relay_id.to_field_structure());
    fs_subfield.flat_value = to_hex_string(time_stamp_val);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("time_stamp_val", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(receive_time);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("receive_time", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_punt_header_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_punt_header_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_bfd_mp_table_shared_lsb_t_anonymous_union_inject_data_t::pack(void) const // union
{
    bit_vector128_t bv(0, 80);
    { // union compound field start
        bit_vector128_t tbv = inject_down_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = inject_up_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(79, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_bfd_mp_table_shared_lsb_t_anonymous_union_inject_data_t::unpack(bit_vector128_t bv) // union
{
    inject_down_data.unpack(bv.bits(79, 0));
}



field_structure npl_bfd_mp_table_shared_lsb_t_anonymous_union_inject_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_shared_lsb_t_anonymous_union_inject_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector128_t tbv = inject_down_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_down_data", inject_down_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector128_t tbv = inject_up_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("inject_up_data", inject_up_data.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_shared_lsb_t_anonymous_union_inject_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_shared_lsb_t_anonymous_union_inject_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_dlp_and_slp_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 20, ene_slp.pack());
    bv.set_bits(19, 0, ene_dlp.pack());
    return bv;
}


void npl_ene_punt_dlp_and_slp_t::unpack(bit_vector64_t bv) 
{
    ene_slp.unpack(bv.bits(39, 20));
    ene_dlp.unpack(bv.bits(19, 0));
}



field_structure npl_ene_punt_dlp_and_slp_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_dlp_and_slp_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ene_slp", ene_slp.to_field_structure());
    fs_result.subfields.emplace_back("ene_dlp", ene_dlp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ene_punt_dlp_and_slp_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_dlp_and_slp_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_encap_data_t::pack(void) const 
{
    bit_vector64_t bv(0, 40);
    bv.set_bits(39, 0, ene_punt_dlp_and_slp.pack());
    return bv;
}


void npl_ene_punt_encap_data_t::unpack(bit_vector64_t bv) 
{
    ene_punt_dlp_and_slp.unpack(bv.bits(39, 0));
}



field_structure npl_ene_punt_encap_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_encap_data_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("ene_punt_dlp_and_slp", ene_punt_dlp_and_slp.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ene_punt_encap_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_encap_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_eth_mp_table_shared_payload_t::pack(void) const 
{
    bit_vector128_t bv(0, 100);
    bv.set_bits(99, 92, punt_code.pack());
    // PADDING -  bv.set_bits(91, 89, padding);
    bv.set_bits(88, 88, meg_id_format);
    // PADDING -  bv.set_bits(87, 85, padding);
    bv.set_bits(84, 84, dmr_lmr_da);
    // PADDING -  bv.set_bits(83, 83, padding);
    bv.set_bits(82, 80, md_level);
    // PADDING -  bv.set_bits(79, 79, padding);
    bv.set_bits(78, 76, ccm_period);
    bv.set_bits(75, 60, mep_address_lsb);
    // PADDING -  bv.set_bits(59, 59, padding);
    bv.set_bits(58, 58, per_tc_count);
    bv.set_bits(57, 56, mep_address_prefix_index);
    bv.set_bits(55, 0, inject_header_data.pack());
    return bv;
}


void npl_eth_mp_table_shared_payload_t::unpack(bit_vector128_t bv) 
{
    punt_code.unpack(bv.bits(99, 92));
    // PADDING -  padding = bv.bits(91, 89).get_value();
    meg_id_format = (npl_meg_id_format_e)bv.bits(88, 88).get_value();
    // PADDING -  padding = bv.bits(87, 85).get_value();
    dmr_lmr_da = (npl_eth_oam_da_e)bv.bits(84, 84).get_value();
    // PADDING -  padding = bv.bits(83, 83).get_value();
    md_level = bv.bits(82, 80).get_value();
    // PADDING -  padding = bv.bits(79, 79).get_value();
    ccm_period = bv.bits(78, 76).get_value();
    mep_address_lsb = bv.bits(75, 60).get_value();
    // PADDING -  padding = bv.bits(59, 59).get_value();
    per_tc_count = bv.bits(58, 58).get_value();
    mep_address_prefix_index = bv.bits(57, 56).get_value();
    inject_header_data.unpack(bv.bits(55, 0));
}



field_structure npl_eth_mp_table_shared_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_mp_table_shared_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("punt_code", punt_code.to_field_structure());
    
    fs_subfield.flat_value = npl_enum_to_string(meg_id_format);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("meg_id_format", fs_subfield);
    
    
    fs_subfield.flat_value = npl_enum_to_string(dmr_lmr_da);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dmr_lmr_da", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(md_level);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("md_level", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(ccm_period);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ccm_period", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mep_address_lsb);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_address_lsb", fs_subfield);
    
    
    fs_subfield.flat_value = to_hex_string(per_tc_count);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("per_tc_count", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mep_address_prefix_index);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mep_address_prefix_index", fs_subfield);
    
    fs_result.subfields.emplace_back("inject_header_data", inject_header_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_eth_mp_table_shared_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_mp_table_shared_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector128_t npl_bfd_mp_table_shared_lsb_t::pack(void) const 
{
    bit_vector128_t bv(0, 100);
    bv.set_bits(99, 96, inject_ifg_id);
    bv.set_bits(95, 80, udp_checksum);
    bv.set_bits(79, 0, inject_data.pack());
    return bv;
}


void npl_bfd_mp_table_shared_lsb_t::unpack(bit_vector128_t bv) 
{
    inject_ifg_id = bv.bits(99, 96).get_value();
    udp_checksum = bv.bits(95, 80).get_value();
    inject_data.unpack(bv.bits(79, 0));
}



field_structure npl_bfd_mp_table_shared_lsb_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_shared_lsb_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(inject_ifg_id);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("inject_ifg_id", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(udp_checksum);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("udp_checksum", fs_subfield);
    
    fs_result.subfields.emplace_back("inject_data", inject_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_shared_lsb_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_shared_lsb_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_bfd_mp_table_shared_payload_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 100, shared_msb.pack());
    bv.set_bits(99, 0, shared_lsb.pack());
    return bv;
}


void npl_bfd_mp_table_shared_payload_t::unpack(bit_vector192_t bv) 
{
    shared_msb.unpack(bv.bits(159, 100));
    shared_lsb.unpack(bv.bits(99, 0));
}



field_structure npl_bfd_mp_table_shared_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_shared_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("shared_msb", shared_msb.to_field_structure());
    fs_result.subfields.emplace_back("shared_lsb", shared_lsb.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_shared_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_shared_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector64_t npl_ene_punt_encap_data_and_misc_pack_payload_t::pack(void) const 
{
    bit_vector64_t bv(0, 48);
    bv.set_bits(47, 40, ene_bytes_to_remove);
    bv.set_bits(39, 0, ene_punt_encap_data.pack());
    return bv;
}


void npl_ene_punt_encap_data_and_misc_pack_payload_t::unpack(bit_vector64_t bv) 
{
    ene_bytes_to_remove = bv.bits(47, 40).get_value();
    ene_punt_encap_data.unpack(bv.bits(39, 0));
}



field_structure npl_ene_punt_encap_data_and_misc_pack_payload_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_ene_punt_encap_data_and_misc_pack_payload_t";
    field_structure fs_subfield;
    //add members to result
    fs_subfield.flat_value = to_hex_string(ene_bytes_to_remove);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ene_bytes_to_remove", fs_subfield);
    
    fs_result.subfields.emplace_back("ene_punt_encap_data", ene_punt_encap_data.to_field_structure());
    return fs_result;
}
std::string to_string(npl_ene_punt_encap_data_and_misc_pack_payload_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_ene_punt_encap_data_and_misc_pack_payload_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_eth_mp_table_app_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 100, transmit_a.pack());
    bv.set_bits(99, 0, shared.pack());
    return bv;
}


void npl_eth_mp_table_app_t::unpack(bit_vector192_t bv) 
{
    transmit_a.unpack(bv.bits(159, 100));
    shared.unpack(bv.bits(99, 0));
}



field_structure npl_eth_mp_table_app_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_eth_mp_table_app_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("transmit_a", transmit_a.to_field_structure());
    fs_result.subfields.emplace_back("shared", shared.to_field_structure());
    return fs_result;
}
std::string to_string(npl_eth_mp_table_app_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_eth_mp_table_app_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_bfd_mp_table_app_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 0, shared.pack());
    return bv;
}


void npl_bfd_mp_table_app_t::unpack(bit_vector192_t bv) 
{
    shared.unpack(bv.bits(159, 0));
}



field_structure npl_bfd_mp_table_app_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_bfd_mp_table_app_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("shared", shared.to_field_structure());
    return fs_result;
}
std::string to_string(npl_bfd_mp_table_app_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_bfd_mp_table_app_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mp_table_rd_app_t_anonymous_union_mp_data_union_t::pack(void) const // union
{
    bit_vector192_t bv(0, 160);
    { // union compound field start
        bit_vector192_t tbv = eth.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(159, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = bfd.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(159, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = bfd_extra.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(47, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = pfc.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(159, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mp_table_rd_app_t_anonymous_union_mp_data_union_t::unpack(bit_vector192_t bv) // union
{
    eth.unpack(bv.bits(159, 0));
}



field_structure npl_mp_table_rd_app_t_anonymous_union_mp_data_union_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mp_table_rd_app_t_anonymous_union_mp_data_union_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = eth.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("eth", eth.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = bfd.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("bfd", bfd.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector64_t tbv = bfd_extra.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("bfd_extra", bfd_extra.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = pfc.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("pfc", pfc.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mp_table_rd_app_t_anonymous_union_mp_data_union_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mp_table_rd_app_t_anonymous_union_mp_data_union_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mp_table_rd_app_t::pack(void) const 
{
    bit_vector192_t bv(0, 160);
    bv.set_bits(159, 0, mp_data_union.pack());
    return bv;
}


void npl_mp_table_rd_app_t::unpack(bit_vector192_t bv) 
{
    mp_data_union.unpack(bv.bits(159, 0));
}



field_structure npl_mp_table_rd_app_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mp_table_rd_app_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mp_data_union", mp_data_union.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mp_table_rd_app_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mp_table_rd_app_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mp_table_app_t::pack(void) const 
{
    bit_vector192_t bv(0, 180);
    bv.set_bits(179, 20, mp_rd_data.pack());
    bv.set_bits(19, 16, mp_type);
    bv.set_bits(15, 0, mp2_data_union.pack());
    return bv;
}


void npl_mp_table_app_t::unpack(bit_vector192_t bv) 
{
    mp_rd_data.unpack(bv.bits(179, 20));
    mp_type = (npl_mp_type_e)bv.bits(19, 16).get_value();
    mp2_data_union.unpack(bv.bits(15, 0));
}



field_structure npl_mp_table_app_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mp_table_app_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("mp_rd_data", mp_rd_data.to_field_structure());
    fs_subfield.flat_value = npl_enum_to_string(mp_type);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_type", fs_subfield);
    
    fs_result.subfields.emplace_back("mp2_data_union", mp2_data_union.to_field_structure());
    return fs_result;
}
std::string to_string(npl_mp_table_app_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mp_table_app_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_overload_union_npu_host_mp_data_t_app_defined_t::pack(void) const // union
{
    bit_vector192_t bv(0, 180);
    { // union compound field start
        bit_vector192_t tbv = app.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(179, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 180 - 1;
        size_t msb = 0;
        const uint64_t * p = app_defined;
        bool is_found = false;
        while (msb < max_msb) {
            if (*p != 0)
            is_found = true;
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
        if (is_found)
        return bv;
    } // union array field end
    
    return bv;
}


void npl_overload_union_npu_host_mp_data_t_app_defined_t::unpack(bit_vector192_t bv) // union
{
    app.unpack(bv.bits(179, 0));
}



field_structure npl_overload_union_npu_host_mp_data_t_app_defined_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_overload_union_npu_host_mp_data_t_app_defined_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = app.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("app", app.to_field_structure());
        }
    } // union compound field end
    
    { // union array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 180 - 1;
        size_t msb = 0;
        const uint64_t * p = app_defined;
        int i = 0;
        bool is_found = false;
        while (msb < max_msb) {
            if (*p != 0){
                is_found = true;
                field_structure fs_sub;
                fs_sub.field_type = "int";
                msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
                fs_sub.flat_value = to_hex_string(*p);
                fs_result.subfields.emplace_back("app_defined_" + std::to_string(i), fs_sub);
                lsb += sizeof(uint64_t) * BITS_PER_BYTE;
                i++;
            }
            p++;
            
        }
        if (is_found)
        {
            return fs_result;
        }
    } // union array field end
    
    return fs_result;
}
std::string to_string(npl_overload_union_npu_host_mp_data_t_app_defined_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_overload_union_npu_host_mp_data_t_app_defined_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_npu_host_mp_data_t::pack(void) const // union
{
    bit_vector192_t bv(0, 180);
    { // union compound field start
        bit_vector192_t tbv = overload_union_app_defined.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(179, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 180 - 1;
        size_t msb = 0;
        const uint64_t * p = raw;
        bool is_found = false;
        while (msb < max_msb) {
            if (*p != 0)
            is_found = true;
            msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
            bv.set_bits(msb, lsb, *p);
            lsb += sizeof(uint64_t) * BITS_PER_BYTE;
            p++;
        }
        if (is_found)
        return bv;
    } // union array field end
    
    return bv;
}


void npl_npu_host_mp_data_t::unpack(bit_vector192_t bv) // union
{
    overload_union_app_defined.unpack(bv.bits(179, 0));
}



field_structure npl_npu_host_mp_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_host_mp_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = overload_union_app_defined.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("overload_union_app_defined", overload_union_app_defined.to_field_structure());
        }
    } // union compound field end
    
    { // union array field start
        const size_t BITS_PER_BYTE = 8;
        size_t lsb = 0;
        size_t max_msb = lsb + 180 - 1;
        size_t msb = 0;
        const uint64_t * p = raw;
        int i = 0;
        bool is_found = false;
        while (msb < max_msb) {
            if (*p != 0){
                is_found = true;
                field_structure fs_sub;
                fs_sub.field_type = "int";
                msb = std::min(max_msb, lsb + sizeof(uint64_t) * BITS_PER_BYTE - 1);
                fs_sub.flat_value = to_hex_string(*p);
                fs_result.subfields.emplace_back("raw_" + std::to_string(i), fs_sub);
                lsb += sizeof(uint64_t) * BITS_PER_BYTE;
                i++;
            }
            p++;
            
        }
        if (is_found)
        {
            return fs_result;
        }
    } // union array field end
    
    return fs_result;
}
std::string to_string(npl_npu_host_mp_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_host_mp_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_npu_host_mp_data_with_padding_t::pack(void) const 
{
    bit_vector192_t bv(0, 181);
    bv.set_bits(180, 1, host_data.pack());
    // PADDING -  bv.set_bits(0, 0, padding);
    return bv;
}


void npl_npu_host_mp_data_with_padding_t::unpack(bit_vector192_t bv) 
{
    host_data.unpack(bv.bits(180, 1));
    // PADDING -  padding = bv.bits(0, 0).get_value();
}



field_structure npl_npu_host_mp_data_with_padding_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_npu_host_mp_data_with_padding_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("host_data", host_data.to_field_structure());
    
    return fs_result;
}
std::string to_string(npl_npu_host_mp_data_with_padding_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_npu_host_mp_data_with_padding_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector192_t npl_mp_data_result_t_anonymous_union_npu_host_mp_data_t::pack(void) const // union
{
    bit_vector192_t bv(0, 181);
    { // union compound field start
        bit_vector192_t tbv = npu_host_mp_data.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(180, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = npu_host_data_res_count_phase.pack();
        if ( ! tbv.is_zero() ) {
            bv.set_bits(180, 0, tbv);
            return bv;
        }
    } // union compound field end
    
    return bv;
}


void npl_mp_data_result_t_anonymous_union_npu_host_mp_data_t::unpack(bit_vector192_t bv) // union
{
    npu_host_mp_data.unpack(bv.bits(180, 0));
}



field_structure npl_mp_data_result_t_anonymous_union_npu_host_mp_data_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mp_data_result_t_anonymous_union_npu_host_mp_data_t";
    field_structure fs_subfield;
    //add members to result
    { // union compound field start
        bit_vector192_t tbv = npu_host_mp_data.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("npu_host_mp_data", npu_host_mp_data.to_field_structure());
        }
    } // union compound field end
    
    { // union compound field start
        bit_vector192_t tbv = npu_host_data_res_count_phase.pack();
        if ( ! tbv.is_zero() ) {
            fs_result.subfields.emplace_back("npu_host_data_res_count_phase", npu_host_data_res_count_phase.to_field_structure());
        }
    } // union compound field end
    
    return fs_result;
}
std::string to_string(npl_mp_data_result_t_anonymous_union_npu_host_mp_data_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mp_data_result_t_anonymous_union_npu_host_mp_data_t element)
{
    return to_short_string(element.to_field_structure());
}

bit_vector384_t npl_mp_data_result_t::pack(void) const 
{
    bit_vector384_t bv(0, 200);
    bv.set_bits(199, 19, npu_host_mp_data.pack());
    bv.set_bits(18, 16, ccm_period);
    bv.set_bits(15, 15, dm_valid);
    bv.set_bits(14, 14, lm_valid);
    bv.set_bits(13, 13, ccm_valid);
    bv.set_bits(12, 1, aux_ptr);
    bv.set_bits(0, 0, mp_valid);
    return bv;
}


void npl_mp_data_result_t::unpack(bit_vector384_t bv) 
{
    npu_host_mp_data.unpack(bv.bits(199, 19));
    ccm_period = bv.bits(18, 16).get_value();
    dm_valid = bv.bits(15, 15).get_value();
    lm_valid = bv.bits(14, 14).get_value();
    ccm_valid = bv.bits(13, 13).get_value();
    aux_ptr = bv.bits(12, 1).get_value();
    mp_valid = bv.bits(0, 0).get_value();
}



field_structure npl_mp_data_result_t::to_field_structure(void) const
{
    field_structure fs_result;
    fs_result.flat_value = pack().to_string();
    fs_result.field_type = "npl_mp_data_result_t";
    field_structure fs_subfield;
    //add members to result
    fs_result.subfields.emplace_back("npu_host_mp_data", npu_host_mp_data.to_field_structure());
    fs_subfield.flat_value = to_hex_string(ccm_period);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ccm_period", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(dm_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("dm_valid", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(lm_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("lm_valid", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(ccm_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("ccm_valid", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(aux_ptr);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("aux_ptr", fs_subfield);
    
    fs_subfield.flat_value = to_hex_string(mp_valid);
    fs_subfield.field_type = "int";
    fs_result.subfields.emplace_back("mp_valid", fs_subfield);
    
    return fs_result;
}
std::string to_string(npl_mp_data_result_t element)
{
    return to_string(element.to_field_structure());
}

std::string to_short_string(npl_mp_data_result_t element)
{
    return to_short_string(element.to_field_structure());
}

