// BEGIN_LEGAL
//
// Copyright (c) 2016-current, Cisco Systems, Inc. ("Cisco"). All Rights Reserved.
//
// This file and all technical concepts, proprietary knowledge, algorithms and
// intellectual property rights it contains (collectively the "Confidential Information"),
// are the sole propriety information of Cisco and shall remain at Cisco's ownership.
// You shall not disclose the Confidential Information to any third party and you
// shall use it solely in connection with operating and/or maintaining of Cisco's
// products and pursuant to the terms and conditions of the license agreement you
// entered into with Cisco.
//
// THE SOURCE CODE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
// IN NO EVENT SHALL CISCO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
// THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// END_LEGAL

#ifndef __NPL_TABLE_H__
#define __NPL_TABLE_H__

#include <algorithm>
#include <set>
#include <string.h>

#include "api/types/la_status_info_types.h"
#include "common/defines.h"
#include "common/gen_operators.h"
#include "common/la_status.h"
#include "common/logger.h"
#include "common/resource_monitor.h"
#include "common/weak_ptr_unsafe.h"
#include "nplapi/npl_table_translator_base.h"
#include "nplapi/npl_tables_enum.h"

namespace silicon_one
{

/// @brief NPL table
///
/// Provides basic facilities for maintaining NPL tables: insert, erase, lookup, etc.
template <class _Trait>
class npl_table : public std::enable_shared_from_this<npl_table<_Trait> >
{

    CEREAL_SUPPORT_PRIVATE_MEMBERS

public:
    typedef _Trait trait_type;

    typedef typename _Trait::key_type key_type;
    typedef typename _Trait::value_type value_type;

    /// @brief NPL table entry, consists of a <key, value> pair.
    /// Key and Value types are typically auto-generated by the NPL compiler.
    class entry : public std::enable_shared_from_this<entry>
    {

        CEREAL_SUPPORT_PRIVATE_MEMBERS

    public:
        typedef npl_table<_Trait> table_type;
        friend table_type;

        entry(weak_ptr_unsafe<table_type> table, const key_type& key, const value_type& value);

        const key_type& key() const;
        const value_type& value() const;
        la_status update(value_type const& value);

    private:
        entry() = default; // For serialization purposes only.
        template <class Archive>
        void serialize(Archive& ar)
        {
            ar(m_key);
            ar(m_value);
            ar(m_table);
        }
        weak_ptr_unsafe<table_type> m_table;
        key_type m_key;
        value_type m_value;
    };

    typedef entry entry_type;
    typedef std::shared_ptr<entry_type> entry_sptr_type;
    typedef weak_ptr_unsafe<entry_type> entry_wptr_type;
    typedef entry* entry_pointer_type;
    typedef entry& entry_type_reference;

    typedef npl_table_translator_base<_Trait> table_translator_t;
    typedef std::shared_ptr<table_translator_t> table_translator_sptr_t;
    typedef std::vector<table_translator_t*> table_translator_vec_t;
    typedef std::vector<table_translator_sptr_t> table_translator_sptr_vec_t;

    /// @brief Comparator for NPL table entries
    struct entry_less {
        bool operator()(const entry_sptr_type lhs, const entry_sptr_type rhs) const;
    };

    typedef std::set<entry_sptr_type, entry_less> container_type;

    npl_table();
    ~npl_table();

    /// @brief Initialize the table object.
    ///
    /// @param[in] translators          Translators to be updated on insert/update/erase operations.
    ///
    /// @retval LA_STATUS_SUCCESS       Success
    /// @retval LA_STATUS_EEXIST        Double initialization
    /// @retval LA_STATUS_EUNKONWN      Internal error
    la_status initialize(table_translator_sptr_vec_t& translators);

    /// @brief Add a new entry to the table.
    ///
    /// If key already exists, out_entry will point to the existing entry in the table
    ///
    /// @param[in]  key                         The key of the new entry.
    /// @param[in]  value                       The value of the new entry.
    ///
    /// @param[out] out_entry                   Host representation of the new entry.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized.
    /// @retval     LA_STATUS_EEXIST            Entry already exists in the table. out_entry points to the existing entry.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status insert(const key_type& key, const value_type& value, entry_pointer_type& out_entry);
    la_status insert(const key_type& key, const value_type& value, entry_wptr_type& out_entry);

    /// @brief Set table value.
    ///
    /// If key does not exist, insert new entry to table.
    /// If key exists, overwrite existing entry.
    ///
    /// @param[in]  key                          Key for entry to be inserted/modified.
    /// @param[in]  value                        Value to be set.
    ///
    /// @param[out] out_entry                    Host representation of inserted/modified entry.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_EUNKONWN           Internal error.
    la_status set(const key_type& key, const value_type& value, entry_pointer_type& out_entry);
    la_status set(const key_type& key, const value_type& value, entry_wptr_type& out_entry);

    /// @brief Remove a specific entry in the table
    ///
    /// @param[in]  key                          The key of the removed entry.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table.
    /// @retval     LA_STATUS_EUNKONWN           Internal error.
    la_status erase(const key_type& key);

    /// @brief Retrive a specific entry from the table
    ///
    /// @param[in]  key                          The key of entry.
    /// @param[out] out_result_entry             Host representation of the entry.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table.
    la_status lookup(const key_type& key, entry_pointer_type& out_result_entry);
    la_status lookup(const key_type& key, entry_wptr_type& out_result_entry);

    /// @brief Retrieve the number of entries in the table.
    ///
    /// @retval Number of entries.
    size_t size() const;

    /// @brief Retrieve the maximum number of entries in the table.
    ///
    /// @retval Table size.
    size_t max_size() const;

    /// @brief Retrieve percentage of the physical usage out of the total physical resource based on the table's type and it's
    /// number of logical entries.
    ///
    /// @param[out]  out_physical_usage      Percentage of the physical usage.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTIMPLEMENTED   Function not yet implemented.
    la_status get_physical_usage(size_t& out_physical_usage) const;

    /// @brief Retrieve number of available free entries for the table.
    ///
    /// @param[out]  out_available_space      Number of available free entries for the table.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTIMPLEMENTED   Function not yet implemented.
    la_status get_available_entries(size_t& out_available_space) const;

    /// @brief Retrieve entries from the table
    ///
    /// @param[in]  max_entries     Max number of elements that can fit in the provided buffer.
    ///
    /// @param[out] out_entries     Buffer where the retrieved entries are written to.
    ///
    /// @retval Number of entries retrieved.
    size_t get_entries(entry_pointer_type* out_entries, size_t max_entries);

    /// @brief Modify the value of a specific entry in the table
    ///
    /// @param[in]  Key                          The key of the modified entry.
    /// @param[in]  Value                        The new value.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_EUNKONWN           Internal error.
    la_status set_entry_value(const entry_pointer_type entry_ref, const value_type& value);
    la_status set_entry_value(const entry_wptr_type& entry_ref, const value_type& value);

    /// @brief Set resource monitor.
    ///
    /// @param[in]  resource_monitor           Resource monitor.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status set_resource_monitor(const resource_monitor_sptr& monitor);

    /// @brief Get resource monitor.
    ///
    /// @param[out] out_resource_monitor        Resource monitor to populate.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status get_resource_monitor(resource_monitor_sptr& out_monitor) const;

    /// @brief Retrieve the table's type.
    ///
    /// @retval The table's type.
    npl_tables_e get_table_type() const;

    /// @brief Retrieve the table's name.
    ///
    /// @retval The table's name.
    std::string get_name() const;

private:
    template <class Archive>
    void serialize(Archive& ar)
    {
        ar(m_entries);
        ar(m_is_initialized);
        ar(m_table_translators);
        ar(m_resource_monitor);
    }

    container_type m_entries;
    bool m_is_initialized;

    table_translator_sptr_vec_t m_table_translators;

    resource_monitor_sptr m_resource_monitor;

    la_status attach_table_info_to_la_status(la_status& status) const;
};

// npl_table_entry implementation
template <class _Trait>
npl_table<_Trait>::entry::entry(weak_ptr_unsafe<table_type> table, const key_type& key, const value_type& value)
{
    memset(this, 0, sizeof(*this));
    m_table = table;
    m_key = key;
    m_value = value;
}

template <class _Trait>
const typename npl_table<_Trait>::key_type&
npl_table<_Trait>::entry::key() const
{
    return m_key;
}

template <class _Trait>
const typename npl_table<_Trait>::value_type&
npl_table<_Trait>::entry::value() const
{
    return m_value;
}

template <class _Trait>
la_status
npl_table<_Trait>::entry::update(value_type const& value)
{
    la_status status = m_table->set_entry_value(this, value);
    return_on_error(status);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
bool
npl_table<_Trait>::entry_less::operator()(const entry_sptr_type lhs, const entry_sptr_type rhs) const
{
    return memcmp(&lhs->key(), &rhs->key(), sizeof(key_type)) < 0;
}

// npl_table implementation
template <class _Trait>
npl_table<_Trait>::npl_table() : m_is_initialized(false), m_resource_monitor(nullptr)
{
}

template <class _Trait>
npl_table<_Trait>::~npl_table()
{
}

template <class _Trait>
la_status
npl_table<_Trait>::initialize(table_translator_sptr_vec_t& translators)
{
    if (translators.empty() && (!m_is_initialized)) {
        log_debug(NPLAPI, "%s didn't get any translator", _Trait::get_table_name().c_str());
    }

    for (auto trans : translators) {
        m_table_translators.push_back(trans);
    }

    m_is_initialized = true;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::insert(const key_type& key, const value_type& value, entry_pointer_type& out_entry)
{
    entry_wptr_type entry_wptr;
    auto status = insert(key, value, entry_wptr);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::insert(const key_type& key, const value_type& value, entry_wptr_type& out_entry)
{
    log_debug(NPLAPI,
              "%s::insert(key=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              to_short_string(key).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    auto new_entry = std::make_shared<entry_type>(this->shared_from_this(), key, value);

    // Check if new entry already exists
    auto it = m_entries.find(new_entry);
    if (it != m_entries.end()) {
        new_entry = nullptr;
        out_entry = *it;

        return LA_STATUS_EEXIST;
    }

    // Update hw table
    for (auto translator : m_table_translators) {
        la_status status = translator->insert(key, value);
        if (status != LA_STATUS_SUCCESS) {
            new_entry = nullptr;
            attach_table_info_to_la_status(status);
            return status;
        }
    }

    // HW table updated successfully, update the functional model
    m_entries.insert(new_entry);
    out_entry = new_entry;

    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::set(const key_type& key, const value_type& value, entry_pointer_type& out_entry)
{
    entry_wptr_type entry_wptr;
    auto status = set(key, value, entry_wptr);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::set(const key_type& key, const value_type& value, entry_wptr_type& out_entry)
{
    log_debug(NPLAPI,
              "%s::set(key=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              to_short_string(key).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    la_status stat = insert(key, value, out_entry);
    if (stat == LA_STATUS_EEXIST) {
        stat = set_entry_value(out_entry, value);
    }
    return stat;
}

template <class _Trait>
la_status
npl_table<_Trait>::erase(const key_type& key)
{
    log_debug(NPLAPI, "%s::erase(key=%s)", _Trait::get_table_name().c_str(), to_short_string(key).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    auto temp_entry = std::make_shared<entry_type>(this->shared_from_this(), key, value_type());
    // check whether entry exists in table
    auto it = m_entries.find(temp_entry);
    if (it == m_entries.end()) {
        return LA_STATUS_ENOTFOUND;
    }

    auto table_entry = *it;

    // updating HW table
    for (auto translator : m_table_translators) {
        la_status status = translator->erase(table_entry->m_key, table_entry->m_value);
        attach_table_info_to_la_status(status);
        return_on_error(status);
    }

    // HW table updated successfully, updating functional model
    m_entries.erase(it);

    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::lookup(const key_type& key, entry_pointer_type& out_result_entry)
{
    entry_wptr_type entry_wptr;
    auto status = lookup(key, entry_wptr);
    return_on_error(status);
    out_result_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::lookup(const key_type& key, entry_wptr_type& out_result_entry)
{
    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    auto temp_entry = std::make_shared<entry_type>(this->shared_from_this(), key, value_type());
    auto it = m_entries.find(temp_entry);

    if (it == m_entries.end()) {
        return LA_STATUS_ENOTFOUND;
    }

    out_result_entry = (*it);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
size_t
npl_table<_Trait>::size() const
{
    return m_entries.size();
}

template <class _Trait>
size_t
npl_table<_Trait>::max_size() const
{
    if (m_table_translators.empty()) {
        return 1;
    }

    auto translator = std::min_element(
        m_table_translators.begin(),
        m_table_translators.end(),
        [](table_translator_sptr_t const& lhs, table_translator_sptr_t const& rhs) { return lhs->max_size() < rhs->max_size(); });

    return (*translator)->max_size();
}

template <class _Trait>
la_status
npl_table<_Trait>::get_physical_usage(size_t& out_physical_usage) const
{
    size_t max_num_physical_entries = 0;
    size_t number_of_logical_entries = size();
    for (auto translator : m_table_translators) {
        size_t translator_physical_entries;
        la_status status = translator->get_physical_usage(number_of_logical_entries, translator_physical_entries);
        return_on_error(status);
        max_num_physical_entries = std::max(max_num_physical_entries, translator_physical_entries);
    }
    out_physical_usage = max_num_physical_entries;
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::get_available_entries(size_t& out_available_entries) const
{
    if (m_table_translators.size() == 0) {
        out_available_entries = 0;
        return LA_STATUS_SUCCESS;
    }
    size_t min_available_entries = std::numeric_limits<size_t>::max();
    for (auto translator : m_table_translators) {
        size_t translator_available_entries;
        la_status status = translator->get_available_entries(translator_available_entries);
        return_on_error(status);
        min_available_entries = std::min(min_available_entries, translator_available_entries);
    }
    out_available_entries = min_available_entries;
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
size_t
npl_table<_Trait>::get_entries(entry_pointer_type* out_entries, size_t max_entries)
{
    size_t i = 0;
    for (const auto& entry : m_entries) {
        out_entries[i] = entry.get();
        i++;

        if (i >= max_entries) {
            break;
        }
    }

    return i;
}

template <class _Trait>
la_status
npl_table<_Trait>::set_entry_value(const entry_pointer_type entry_ref, const value_type& value)
{
    entry_wptr_type entry_wptr = entry_ref->shared_from_this();
    auto status = set_entry_value(entry_wptr, value);
    return_on_error(status);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::set_entry_value(const entry_wptr_type& entry_ref, const value_type& value)
{
    log_debug(NPLAPI,
              "%s::set_entry_value(key=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              to_short_string(entry_ref->key()).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // updating hw table
    key_type key(entry_ref->key());

    for (auto translator : m_table_translators) {
        la_status status = translator->set_entry_value(key, value);
        attach_table_info_to_la_status(status);
        return_on_error(status);
    }

    // hw table updated successfully, updating functional model
    entry_ref->m_value = value;
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::attach_table_info_to_la_status(la_status& status) const
{
    if (status == LA_STATUS_ERESOURCE) {
        la_resource_descriptor::type_e resource_type;
        std::shared_ptr<la_status_info_e_resource_table> table_info;
        if (m_resource_monitor != nullptr) {
            resource_type = static_cast<la_resource_descriptor::type_e>(m_resource_monitor->get_resource_type());
            table_info
                = std::make_shared<la_status_info_e_resource_table>(resource_type,                                  // resource enum
                                                                    _Trait::get_table_name(),                       // name
                                                                    m_resource_monitor->get_resource_instance_idx() // instance_id
                                                                    );
        } else {
            resource_type = la_resource_descriptor::type_e::UNSPECIFIED;
            table_info = std::make_shared<la_status_info_e_resource_table>(resource_type,                     // resource enum
                                                                           _Trait::get_table_name(),          // name
                                                                           LA_RESOURCE_INSTANCE_INDEX_INVALID // instance_id
                                                                           );
        }
        la_status set_info_status = status.set_info(table_info);
        return_on_error(set_info_status);
    }
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
npl_tables_e
npl_table<_Trait>::get_table_type() const
{
    return _Trait::table_id;
}

template <class _Trait>
std::string
npl_table<_Trait>::get_name() const
{
    return _Trait::get_table_name();
}

template <class _Trait>
la_status
npl_table<_Trait>::set_resource_monitor(const resource_monitor_sptr& monitor)
{
    m_resource_monitor = monitor;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_table<_Trait>::get_resource_monitor(resource_monitor_sptr& out_monitor) const
{
    out_monitor = m_resource_monitor;

    return LA_STATUS_SUCCESS;
}
}

#endif
