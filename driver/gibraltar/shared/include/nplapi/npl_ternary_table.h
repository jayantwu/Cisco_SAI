// BEGIN_LEGAL
//
// Copyright (c) 2016-current, Cisco Systems, Inc. ("Cisco"). All Rights Reserved.
//
// This file and all technical concepts, proprietary knowledge, algorithms and
// intellectual property rights it contains (collectively the "Confidential Information"),
// are the sole propriety information of Cisco and shall remain at Cisco's ownership.
// You shall not disclose the Confidential Information to any third party and you
// shall use it solely in connection with operating and/or maintaining of Cisco's
// products and pursuant to the terms and conditions of the license agreement you
// entered into with Cisco.
//
// THE SOURCE CODE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
// IN NO EVENT SHALL CISCO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
// THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// END_LEGAL

#ifndef __NPL_TERNARY_TABLE_H__
#define __NPL_TERNARY_TABLE_H__

#include "api/types/la_status_info_types.h"
#include "common/defines.h"
#include "common/gen_operators.h"
#include "common/la_status.h"
#include "common/resource_monitor.h"
#include "common/weak_ptr_unsafe.h"
#include "nplapi/npl_ternary_table_translator_base.h"

#include "nplapi/npl_tables_enum.h"

#include <algorithm>
#include <deque>
#include <string.h>
#include <vector>

namespace silicon_one
{

/// @brief NPL table
/// Provides basic facilities for maintaining NPL tables: insert, erase, lookup, etc.
template <class _Trait>
class npl_ternary_table : public std::enable_shared_from_this<npl_ternary_table<_Trait> >
{

    CEREAL_SUPPORT_PRIVATE_MEMBERS

public:
    typedef _Trait trait_type;

    typedef typename _Trait::key_type key_type;
    typedef typename _Trait::value_type value_type;

    /// @brief NPL ternary table entry, consists of a <key, mask, value> tupple.
    /// Key and Value types are typically auto-generated by the NPL compiler.
    /// The mask's type is always same as the key's.
    class entry : public std::enable_shared_from_this<entry>
    {

        CEREAL_SUPPORT_PRIVATE_MEMBERS

    public:
        typedef npl_ternary_table<_Trait> table_type;
        friend table_type;

        entry(weak_ptr_unsafe<table_type> table, size_t line, const key_type& key, const key_type& mask, const value_type& value);

        size_t line() const;
        const key_type& key() const;
        const key_type& mask() const;
        const value_type& value() const;

        la_status update(value_type const& value);

    private:
        entry() = default; // For serialization purposes only.
        template <class Archive>
        void serialize(Archive& ar)
        {
            ar(m_line);
            ar(m_phy_line);
            ar(m_key);
            ar(m_mask);
            ar(m_value);
            ar(m_table);
        }
        weak_ptr_unsafe<table_type> m_table;
        size_t m_line = -1;
        size_t m_phy_line = -1;
        key_type m_key;
        key_type m_mask;
        value_type m_value;
    };

    typedef entry entry_type;
    typedef entry_type* entry_pointer_type;
    typedef entry_type& entry_type_reference;
    typedef std::shared_ptr<entry_type> entry_sptr_type;
    typedef weak_ptr_unsafe<entry_type> entry_wptr_type;
    typedef std::vector<entry_sptr_type> container_type;

    typedef npl_ternary_table_translator_base<_Trait> table_translator_t;
    typedef std::shared_ptr<table_translator_t> table_translator_sptr_t;
    typedef std::vector<table_translator_t*> table_translator_vec_t;
    typedef std::vector<std::shared_ptr<table_translator_t> > table_translator_sptr_vec_t;
    typedef typename table_translator_t::npl_translator_entry_desc npl_entry_desc;

    npl_ternary_table();
    ~npl_ternary_table();

    /// @brief Initialize the table object.
    ///
    /// @param[in] translators          Translators to be updated on insert/update/erase operations.
    ///
    /// @retval LA_STATUS_SUCCESS       Success
    /// @retval LA_STATUS_EEXIST        Double initialization with different index
    /// @retval LA_STATUS_EUNKONWN      Internal error
    la_status initialize(table_translator_sptr_vec_t& translators);

    /// @brief Insert a new entry to the table
    ///
    /// @param[in]  location                  The row into which the entry should be inserted
    /// @param[in]  key                       The key of the new entry
    /// @param[in]  mask                      The mask of the new entry
    /// @param[in]  value                     The value of the new entry
    /// @param[out] out_entry                 Host representation of the new entry
    ///
    /// @retval     LA_STATUS_SUCCESS         Success
    /// @retval     LA_STATUS_ENOTINITIALIZED Table object was not initialized
    /// @retval     LA_STATUS_EEXIST          Entry already exists in the table
    /// @retval     LA_STATUS_EOUTOFRANGE     Given location is out of bound
    /// @retval     LA_STATUS_EUNKNOWN        Internal error
    la_status insert(size_t location,
                     const key_type& key,
                     const key_type& mask,
                     const value_type& value,
                     entry_pointer_type& out_entry);
    la_status insert(size_t location,
                     const key_type& key,
                     const key_type& mask,
                     const value_type& value,
                     entry_wptr_type& out_entry);

    /// @brief Set table value.
    ///
    /// If entry at the specified location does not exist - insert new.
    /// If exists - overwrite existing entry.
    ///
    /// @param[in]  location                  The row into which the entry should be inserted
    /// @param[in]  key                       The key of the new entry
    /// @param[in]  mask                      The mask of the new entry
    /// @param[in]  value                     The value of the new entry
    /// @param[out] out_entry                 Host representation of the new entry
    ///
    /// @retval     LA_STATUS_SUCCESS         Success
    /// @retval     LA_STATUS_ENOTINITIALIZED Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND       Entry not in the table
    /// @retval     LA_STATUS_EUNKNOWN        Internal error
    la_status set(size_t location,
                  const key_type& key,
                  const key_type& mask,
                  const value_type& value,
                  entry_pointer_type& out_entry);
    la_status set(size_t location, const key_type& key, const key_type& mask, const value_type& value, entry_wptr_type& out_entry);

    /// @brief Insert a new entry to the table, pushing entries down to make space for it if necessary
    ///
    /// @param[in]  location                     The row into which the entry should be inserted
    /// @param[in]  key                          The key of the new entry
    /// @param[in]  mask                         The mask of the new entry
    /// @param[in]  value                        The value of the new entry
    /// @param[out] out_entry                    Host representation of the new entry
    ///
    /// @retval     LA_STATUS_SUCCESS            Success
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized
    /// @retval     LA_STATUS_ERESOURCE          No free entries in the table
    /// @retval     LA_STATUS_EOUTOFRANGE        Given location is out of bound
    /// @retval     LA_STATUS_EUNKNOWN           Internal error
    la_status push(size_t location,
                   const key_type& key,
                   const key_type& mask,
                   const value_type& value,
                   entry_pointer_type& out_entry);
    la_status push(size_t location, const key_type& key, const key_type& mask, const value_type& value, entry_wptr_type& out_entry);

    /// @brief Remove a specific entry in the table
    ///
    /// @param[in]  location                    The row where the entry should be removed
    ///
    /// @retval     LA_STATUS_SUCCESS            Success
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table
    /// @retval     LA_STATUS_EOUTOFRANGE        Given location is out of bound
    /// @retval     LA_STATUS_EUNKNOWN           Internal error
    la_status erase(size_t location);

    /// @brief Remove a specific entry in the table, moving all following to cover its space
    ///
    /// @param[in]  location                    The row where the entry should be removed
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND         Entry not in the table
    /// @retval     LA_STATUS_EOUTOFRANGE       Given location is out of bound
    /// @retval     LA_STATUS_EUNKNOWN          Internal error
    la_status pop(size_t location);

    /// @brief Retrieve table entry from given location
    ///
    /// @param[in]   location                   Row entry should be fetched from
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_ENOTFOUND         Row is unused.
    /// @retval     LA_STATUS_EUNKNOWN          Internal error.
    la_status get_entry(size_t location, entry_pointer_type& entry);
    la_status get_entry(size_t location, entry_wptr_type& entry);

    /// @brief Retrieve table entry matching a ternary table lookup for given key.
    ///
    /// @param[in]   key                        Key to be searched
    /// @param[out] out_result_entry            Host representation of the entry
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND         Entry not in the table
    la_status lookup(const key_type& key, entry_pointer_type& out_result_entry);
    la_status lookup(const key_type& key, entry_wptr_type& out_result_entry);

    /// @brief Retrieve the first table entry with the given key/mask
    ///
    /// @param[in]  key                         Key to be searched
    /// @param[in]  mask                        Mask to be searched
    /// @param[out] out_entry                   Host representation of the entry
    /// @param[out] out_location                Location of the entry in the table
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND         Entry not in the table
    la_status find(const key_type& key, const key_type& mask, entry_pointer_type& out_entry, size_t& out_location);
    la_status find(const key_type& key, const key_type& mask, entry_wptr_type& out_entry, size_t& out_location);

    /// @brief Get the location of the first free entry in the table >= start_location
    ///
    /// @param[in]  start_location              Location at or after which we will look
    /// @param[out] out_location                Location of the entry in the table
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND         No free entries after the given location
    la_status locate_free_entry(size_t start_location, size_t& out_location) const;

    /// @brief Get the location of the first free entry in the table.
    ///
    /// @param[out] out_location                Location of the entry in the table
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND         No free entries in the table
    la_status locate_first_free_entry(size_t& out_location) const;

    /// @brief Retrieve the number of entries in the table
    ///
    /// @retval Number of entries
    size_t size() const;

    /// @brief Retrieve maximum table size.
    ///
    /// @retval Maximum number of entries supported by table.
    size_t max_size() const;

    /// @brief Retrieve maximum scale for table (maximum amount of entries that can be added).
    ///
    /// @param[out]  out_max_scale               Maximum scale for table
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTIMPLEMENTED   Function not yet implemented.
    la_status get_available_entries(size_t& out_available_space) const;

    /// @brief Retrieve the number of used lines in the table.
    ///
    /// @param[out]  out_physical_usage              Number of used lines.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTIMPLEMENTED   Function not yet implemented.
    la_status get_physical_usage(size_t& out_physical_usage) const;

    /// @brief Retrieve entries from the table
    ///
    /// @param[out] out_entries   Buffer where the retrieved entries are written to
    /// @param[in]  max_entries   Max number of elements that can fit in the provided buffer
    ///
    /// @retval    Number of entries retrieved
    size_t get_entries(entry_pointer_type* out_entries, size_t max_entries);

    /// @brief Modify the value of a specific entry in the table
    ///
    /// @param[in]  entry_ref                   Modified entry
    /// @param[in]  Value                       The new value
    ///
    /// @retval     LA_STATUS_SUCCESS            Success
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table
    /// @retval     LA_STATUS_EUNKNOWN           Internal error
    la_status set_entry_value(const entry_pointer_type entry, const value_type& value);
    la_status set_entry_value(const entry_wptr_type& entry, const value_type& value);

    /// @brief Set resource monitor.
    ///
    /// @param[in]  resource_monitor            Resource monitor.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status set_resource_monitor(const resource_monitor_sptr& monitor);

    /// @brief Get resource monitor.
    ///
    /// @param[out] out_resource_monitor        Resource monitor to populate.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status get_resource_monitor(resource_monitor_sptr& out_monitor) const;

    /// @brief Retrieve the table's type.
    ///
    /// @retval The table's type
    npl_tables_e get_table_type() const;

    la_status set_trans_info(void* trans_info);
    /// @brief Get the locations of the first free entries in the table after the last occupied entry
    ///
    /// @param[out] out_location       Buffer where the retrieved locations are written to
    /// @param[in]  entries_num         Number of free entries locations to search for
    /// @param[in]  start_location      Location at or after which we will look
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_EOUTOFRANGE       No free entry after the last occupied entry
    la_status get_free_tcam_line_after_last_entry(size_t& out_location);

    /// @brief Push bulk table values.
    ///
    /// If entries at the specified locations don't exist - insert new ones.
    /// If exist - overwrite existing entries.
    ///
    /// @param[in]  first_location            The first row from which the entries should be pushed
    /// @param[in]  entries_num               The number of entries to push
    /// @param[in]  entries_info              The keys, masks and values of the new entries
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized
    /// @retval     LA_STATUS_EOUTOFRANGE       Entry location is out of bounds
    /// @retval     LA_STATUS_ERESOURCE         Not enough space for entries
    /// @retval     LA_STATUS_EUNKNOWN          Internal error
    la_status push_bulk(size_t first_location, size_t entries_num, const vector_alloc<npl_entry_desc>& entries_info);

private:
    template <class Archive>
    void serialize(Archive& ar)
    {
        ar(m_entries);
        ar(m_phy_entries);
        ar(m_is_initialized);
        ar(m_max_size);
        ar(m_table_translators);
        ar(m_resource_monitor);
    }

    la_status get_logical_index(size_t logical_location, size_t& out_logical_index);

    size_t get_logical_next_free_slot(size_t location);

    size_t get_next_free_slot(const container_type& entries, size_t location, size_t slots_number);

    la_status get_physical_location(size_t logical_location, size_t& out_physical_location);

    la_status get_physical_first_location(size_t logical_location, size_t& out_physical_location, int& out_last_empty_slot);

    size_t get_physical_next_free_slot(size_t physical_location);

    la_status insert_physical(size_t physical_location,
                              entry_sptr_type& entry,
                              const key_type& key,
                              const key_type& mask,
                              const value_type& value);

    la_status push_physical(size_t location,
                            entry_sptr_type& entry,
                            const key_type& key,
                            const key_type& mask,
                            const value_type& value);

    la_status push_physical_bulk(size_t first_location,
                                 size_t entries_num,
                                 const vector_alloc<npl_entry_desc>& entries_info,
                                 vector_alloc<entry_sptr_type>& entry_sptrs);

    la_status insert_physical_bulk(size_t physical_location,
                                   size_t entries_num,
                                   const vector_alloc<npl_entry_desc>& entries_info,
                                   vector_alloc<entry_sptr_type>& entry_sptrs);

    la_status erase_physical(size_t location);

    void insert_logical(size_t location, entry_sptr_type entry);

    void push_logical(size_t location, size_t next_free_slot, entry_sptr_type& entry);

    void push_logical_bulk(size_t first_location, size_t entries_num, size_t free_slot, vector_alloc<entry_sptr_type>& entries);

    void pop_logical(size_t location);

    void erase_logical(size_t location);

    // Writes line to functional table.
    void set_logical(size_t location, entry_sptr_type entry);

    entry_sptr_type set_physical(size_t physical_location, const key_type& key, const key_type& mask, const value_type& value);

    // Removes line from functional table.
    void clear_entry(size_t location);

    // Move entry to the new location.
    void move_logical(entry_sptr_type entry, size_t new_location);

    void move_physical(entry_sptr_type entry, size_t new_physical_location);

    void clear_logical(size_t location);

    void clear_physical(size_t physical_location);

    size_t physical_size() const;

    const std::shared_ptr<la_status_info> create_e_resource_table_info() const;

    la_status attach_table_info_to_la_status(la_status& status) const;

private:
    container_type m_entries;
    container_type m_phy_entries;
    bool m_is_initialized;
    size_t m_max_size;

    table_translator_sptr_vec_t m_table_translators;

    resource_monitor_sptr m_resource_monitor;
};

template <class _Trait>
npl_ternary_table<_Trait>::entry::entry(weak_ptr_unsafe<table_type> table,
                                        size_t line,
                                        const key_type& key,
                                        const key_type& mask,
                                        const value_type& value)
{
    memset(this, 0, sizeof(*this));
    m_table = table;
    m_phy_line = line;
    m_key = key;
    m_mask = mask;
    m_value = value;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::entry::line() const
{
    return m_line;
}

template <class _Trait>
const typename npl_ternary_table<_Trait>::key_type&
npl_ternary_table<_Trait>::entry::key() const
{
    return m_key;
}

template <class _Trait>
const typename npl_ternary_table<_Trait>::key_type&
npl_ternary_table<_Trait>::entry::mask() const
{
    return m_mask;
}

template <class _Trait>
const typename npl_ternary_table<_Trait>::value_type&
npl_ternary_table<_Trait>::entry::value() const
{
    return m_value;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::entry::update(value_type const& value)
{
    la_status status = m_table->set_entry_value(this, value);
    return_on_error(status);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
npl_ternary_table<_Trait>::npl_ternary_table() : m_is_initialized(false), m_max_size(0), m_resource_monitor(nullptr)
{
}

template <class _Trait>
npl_ternary_table<_Trait>::~npl_ternary_table()
{
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::initialize(table_translator_sptr_vec_t& translators)
{
    if (translators.empty() && (!m_is_initialized)) {
        log_debug(NPLAPI, "%s didn't get any translator", _Trait::get_table_name().c_str());
    }

    // For NSIM flow this function gets called twice. once for each nsim and ra translator_creators.
    for (auto trans : translators) {
        m_table_translators.push_back(trans);
    }

    if (!m_is_initialized) {
        m_max_size = _Trait::table_size;
    }

    for (const auto& translator : translators) {
        size_t res_size = translator->max_size();
        m_max_size = std::min(m_max_size, res_size);
        la_status status = translator->initialize();
        return_on_error(status);
    }

    m_is_initialized = true;

    if (m_table_translators.empty()) {
        return LA_STATUS_SUCCESS;
    }

    m_entries.resize(m_max_size, nullptr);
    m_phy_entries.resize(m_max_size, nullptr);
    log_debug(NPLAPI,
              "%s::initialize(size=%lu, phy_size=%lu, max_size=%lu)",
              _Trait::get_table_name().c_str(),
              m_entries.size(),
              m_phy_entries.size(),
              max_size());

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_logical_index(size_t logical_location, size_t& out_logical_index)
{
    size_t logical_index = 0, location = 0;

    // Check if location is in table's range.
    if (logical_location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    // Find the logical index for the entry.
    for (auto entry : m_entries) {
        if (location == logical_location) {
            out_logical_index = logical_index;
            return LA_STATUS_SUCCESS;
        }

        if (entry != nullptr) {
            logical_index++;
        }

        location++;
    }

    return LA_STATUS_EOUTOFRANGE;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::get_logical_next_free_slot(size_t location)
{
    size_t next_free_slot;

    // Find free entry starting from location.
    for (next_free_slot = location + 1; next_free_slot < m_max_size; next_free_slot++) {
        if (m_entries[next_free_slot] == nullptr) {
            break;
        }
    }

    log_debug(NPLAPI,
              "%s::get_next_free_slot(location=%lu, next_free_slot=%lu)",
              _Trait::get_table_name().c_str(),
              location,
              next_free_slot);
    return next_free_slot;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::get_next_free_slot(const container_type& entries, size_t location, size_t slots_number)
{
    size_t next_free_slot;
    size_t free_slots_found = 0;

    // Find free entry starting from location.
    for (next_free_slot = location; next_free_slot < m_max_size; next_free_slot++) {
        if (entries[next_free_slot] == nullptr) {
            free_slots_found++;
        }

        if (free_slots_found == slots_number) {
            break;
        }
    }

    log_debug(NPLAPI,
              "%s::get_next_free_slot(location=%lu, next_free_slot=%lu, slots_number=%lu)",
              _Trait::get_table_name().c_str(),
              location,
              next_free_slot,
              slots_number);
    return next_free_slot;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_physical_location(size_t logical_location, size_t& out_physical_location)
{
    size_t logical_index = 0, physical_location = 0, phy_index = 0;
    la_status status;

    status = get_logical_index(logical_location, logical_index);
    return_on_error(status);

    // Find the physical location for the entry.
    for (auto entry : m_phy_entries) {
        if (entry != nullptr) {
            if (logical_index == phy_index) {
                break;
            }
            phy_index++;
        }

        physical_location++;
    }

    if (physical_location >= max_size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    out_physical_location = physical_location;
    log_debug(NPLAPI,
              "%s::get_physical_location(logical_location=%lu, logical_size=%lu, phy_size=%lu, physical_location=%lu)",
              _Trait::get_table_name().c_str(),
              logical_location,
              size(),
              physical_size(),
              physical_location);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_physical_first_location(size_t logical_location,
                                                       size_t& out_physical_location,
                                                       int& out_last_empty_slot)
{
    size_t logical_index = 0, physical_location = 0, phy_index = 0;
    int last_empty_slot = -1;
    la_status status;

    status = get_logical_index(logical_location, logical_index);
    return_on_error(status);

    if (!logical_index) {
        out_physical_location = 0;
        out_last_empty_slot = -1;
        return LA_STATUS_SUCCESS;
    }

    // Find the physical location for the entry.
    for (auto entry : m_phy_entries) {
        if (entry != nullptr) {
            phy_index++;
            if (logical_index == phy_index) {
                if (last_empty_slot == -1) {
                    out_physical_location = physical_location + 1;
                } else {
                    // If there is an empty slot earlier then move entries down to free slot
                    // and insert at current location.
                    out_physical_location = physical_location;
                }
                out_last_empty_slot = last_empty_slot;
                break;
            }
        } else {
            last_empty_slot = physical_location;
        }

        physical_location++;
    }

    if (out_physical_location >= max_size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    log_debug(NPLAPI,
              "%s::get_physical_first_location(logical_location=%lu, logical_size=%lu, "
              "phy_size=%lu, out_physical_location=%lu, out_last_empty_slot=%d)",
              _Trait::get_table_name().c_str(),
              logical_location,
              size(),
              physical_size(),
              out_physical_location,
              out_last_empty_slot);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::get_physical_next_free_slot(size_t physical_location)
{
    size_t next_free_slot;

    // Find free entry starting from physical_location.
    for (next_free_slot = physical_location + 1; next_free_slot < m_max_size; next_free_slot++) {
        if (m_phy_entries[next_free_slot] == nullptr) {
            break;
        }
    }

    log_debug(NPLAPI,
              "%s::get_physical_next_free_slot(physical_location=%lu, next_free_slot=%lu)",
              _Trait::get_table_name().c_str(),
              physical_location,
              next_free_slot);
    return next_free_slot;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::insert_physical(size_t physical_location,
                                           entry_sptr_type& out_entry,
                                           const key_type& key,
                                           const key_type& mask,
                                           const value_type& value)
{
    log_debug(NPLAPI, "%s::insert_physical(physical_location=%lu)", _Trait::get_table_name().c_str(), physical_location);

    // Updating hw table.
    for (auto translator : m_table_translators) {
        la_status status = translator->insert(physical_location, key, mask, value);
        attach_table_info_to_la_status(status);
        return_on_error(status);
    }

    out_entry = set_physical(physical_location, key, mask, value);
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::push_physical(size_t location,
                                         entry_sptr_type& out_entry,
                                         const key_type& key,
                                         const key_type& mask,
                                         const value_type& value)
{
    size_t physical_location = 0;
    int last_empty_slot = -1;
    size_t next_free_slot;

    log_debug(NPLAPI, "%s::push_physical(location=%lu)", _Trait::get_table_name().c_str(), location);

    // Find the physical location for the entry.
    la_status status = get_physical_first_location(location, physical_location, last_empty_slot);
    return_on_error(status);

    // Check if phy location is occupied.
    if (m_phy_entries[physical_location] == nullptr) {
        return insert_physical(physical_location, out_entry, key, mask, value);
    }

    // Location is occupied: Check if there is free entry earlier than current push location.
    if ((last_empty_slot != -1) && (physical_location > 0)) {
        size_t count = physical_location - last_empty_slot;
        // Pull all entries from free location to uptil current push location one line down.
        for (auto translator : m_table_translators) {
            la_status status = translator->move(last_empty_slot, last_empty_slot + 1, count);
            return_on_error(status);
        }

        // Copy entries one level down till physical_location.
        for (next_free_slot = last_empty_slot; next_free_slot < physical_location; next_free_slot++) {
            move_physical(m_phy_entries[next_free_slot + 1], next_free_slot);
        }

        return insert_physical(physical_location, out_entry, key, mask, value);
    }

    // Location is occupied: iterate from end to physical_location and push all entries.
    next_free_slot = get_physical_next_free_slot(physical_location);

    // If no free slot, bail out.
    if (next_free_slot >= m_max_size) {
        return LA_STATUS_ERESOURCE_INFO(create_e_resource_table_info());
    }

    // At this point, all known conditions are checked and push is possible.
    for (auto translator : m_table_translators) {
        la_status status = translator->push(physical_location, next_free_slot, key, mask, value);
        attach_table_info_to_la_status(status);
        return_on_error(status);
    }

    // Pull all entries one line down.
    // Copy from last to first so the table is valid at any given point.
    for (size_t free_slot = next_free_slot; free_slot > physical_location; free_slot--) {
        move_physical(m_phy_entries[free_slot - 1], free_slot);
    }

    out_entry = set_physical(physical_location, key, mask, value);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::erase_physical(size_t location)
{
    size_t physical_location = 0;
    la_status status;

    log_debug(NPLAPI, "%s::erase_physical(location=%lu)", _Trait::get_table_name().c_str(), location);

    // Find the physical location for the entry.
    status = get_physical_location(location, physical_location);
    return_on_error(status);

    // Updating hw table.
    for (auto translator : m_table_translators) {
        status = translator->erase(physical_location);
        return_on_error(status);
    }

    clear_physical(physical_location);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::insert_logical(size_t location, entry_sptr_type entry)
{
    log_debug(NPLAPI,
              "%s::insert_logical(location=%lu, logical_size=%lu, phy_size=%lu)",
              _Trait::get_table_name().c_str(),
              location,
              size(),
              physical_size());

    set_logical(location, entry);

    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }
}

template <class _Trait>
void
npl_ternary_table<_Trait>::push_logical(size_t location, size_t next_free_slot, entry_sptr_type& entry)
{
    log_debug(NPLAPI,
              "%s::push_logical(location=%lu, logical_size=%lu, phy_size=%lu)",
              _Trait::get_table_name().c_str(),
              location,
              size(),
              physical_size());

    // Check if location is occupied.
    if (next_free_slot) {
        // Pull all entries one line down.
        // Copy from last to first so the table is valid at any given point.
        for (size_t free_slot = next_free_slot; free_slot > location; free_slot--) {
            move_logical(m_entries[free_slot - 1], free_slot);
        }
    }

    insert_logical(location, entry);
}

template <class _Trait>
void
npl_ternary_table<_Trait>::erase_logical(size_t location)
{
    log_debug(NPLAPI, "%s::erase_logical(location=%lu)", _Trait::get_table_name().c_str(), location);

    // Check if location is occupied.
    clear_logical(location);

    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }
}

template <class _Trait>
void
npl_ternary_table<_Trait>::pop_logical(size_t location)
{
    log_debug(NPLAPI, "%s::pop_logical(location=%lu)", _Trait::get_table_name().c_str(), location);

    erase_logical(location);

    // Iteratively copy next entry one level up and erase
    for (; (location + 1) < m_max_size; location++) {
        auto next_entry = m_entries[location + 1];
        if (next_entry) {
            move_logical(next_entry, location);
        }
    }
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::set(size_t location,
                               const key_type& key,
                               const key_type& mask,
                               const value_type& value,
                               entry_wptr_type& out_entry)
{
    log_debug(NPLAPI,
              "%s::set(location=%lu, key=%s, mask=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              location,
              to_short_string(key).c_str(),
              to_short_string(mask).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // Check if location is in table's range.
    if (location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    if (m_entries[location]) {
        la_status status = erase(location);
        return_on_error(status);
    }

    return insert(location, key, mask, value, out_entry);
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::set(size_t location,
                               const key_type& key,
                               const key_type& mask,
                               const value_type& value,
                               entry_pointer_type& out_entry)
{
    entry_wptr_type entry_wptr;
    auto status = set(location, key, mask, value, entry_wptr);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::insert(size_t location,
                                  const key_type& key,
                                  const key_type& mask,
                                  const value_type& value,
                                  entry_wptr_type& out_entry)
{
    log_debug(NPLAPI,
              "%s::insert(location=%lu, key=%s, mask=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              location,
              to_short_string(key).c_str(),
              to_short_string(mask).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // Check if location is in table's range.
    if (location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    // Check if location is occupied.
    if (m_entries[location] != nullptr) {
        return LA_STATUS_EEXIST;
    }

    entry_sptr_type entry_sptr;
    la_status status = push_physical(location, entry_sptr, key, mask, value);
    return_on_error(status);

    insert_logical(location, entry_sptr);
    out_entry = entry_sptr;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::insert(size_t location,
                                  const key_type& key,
                                  const key_type& mask,
                                  const value_type& value,
                                  entry_pointer_type& out_entry)
{
    entry_wptr_type entry_wptr;
    auto status = insert(location, key, mask, value, entry_wptr);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::push(size_t location,
                                const key_type& key,
                                const key_type& mask,
                                const value_type& value,
                                entry_wptr_type& out_entry)
{
    la_status status;
    size_t next_free_slot = 0;

    log_debug(NPLAPI,
              "%s::push(location=%lu, key=%s, mask=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              location,
              to_short_string(key).c_str(),
              to_short_string(mask).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // Check if location is in table's range.
    if (location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    // Check if location is occupied.
    if (m_entries[location] != nullptr) {
        // Location is occupied: iterate from end to location and find free entry.
        next_free_slot = get_logical_next_free_slot(location);

        // If no free slot, bail out.
        if (next_free_slot == m_max_size) {
            return LA_STATUS_ERESOURCE_INFO(create_e_resource_table_info());
        }
    }

    entry_sptr_type entry_sptr;
    status = push_physical(location, entry_sptr, key, mask, value);
    return_on_error(status);

    push_logical(location, next_free_slot, entry_sptr);
    out_entry = entry_sptr;

    return status;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::push(size_t location,
                                const key_type& key,
                                const key_type& mask,
                                const value_type& value,
                                entry_pointer_type& out_entry)
{
    entry_wptr_type entry_wptr;
    auto status = push(location, key, mask, value, entry_wptr);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::erase(size_t location)
{
    log_debug(NPLAPI, "%s::erase(location=%lu)", _Trait::get_table_name().c_str(), location);

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // Check if location is in table's range.
    if (location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    if (m_entries[location] == nullptr) {
        return LA_STATUS_ENOTFOUND;
    }

    la_status status = erase_physical(location);
    return_on_error(status);

    erase_logical(location);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::pop(size_t location)
{
    log_debug(NPLAPI, "%s::pop(location=%lu)", _Trait::get_table_name().c_str(), location);

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // Check if location is in table's range.
    if (location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    la_status status = erase_physical(location);
    return_on_error(status);

    pop_logical(location);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_entry(size_t location, entry_wptr_type& entry)
{
    if (location >= m_max_size) {
        return LA_STATUS_EOUTOFRANGE;
    }

    entry = m_entries[location];

    if (entry == nullptr) {
        return LA_STATUS_ENOTFOUND;
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_entry(size_t location, entry_pointer_type& entry)
{
    entry_wptr_type entry_wptr;
    auto status = get_entry(location, entry_wptr);
    return_on_error(status);
    entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::lookup(const key_type& key, entry_wptr_type& out_result_entry)
{
    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    for (auto entry : m_entries) {
        if (!entry) {
            continue;
        }

        const key_type& entry_key = entry->key();
        const key_type& entry_mask = entry->mask();

        if (_Trait::key_match(key, entry_key, entry_mask)) {
            out_result_entry = entry;

            return LA_STATUS_SUCCESS;
        }
    }

    return LA_STATUS_ENOTFOUND;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::lookup(const key_type& key, entry_pointer_type& out_result_entry)
{
    entry_wptr_type entry_wptr;
    auto status = lookup(key, entry_wptr);
    return_on_error(status);
    out_result_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::find(const key_type& key, const key_type& mask, entry_wptr_type& out_entry, size_t& out_location)
{
    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    size_t location = 0;
    for (auto entry : m_entries) {
        if (entry != nullptr) {
            const key_type& entry_key = entry->key();
            const key_type& entry_mask = entry->mask();
            if ((memcmp(&key, &entry_key, sizeof(key_type)) == 0) && (memcmp(&mask, &entry_mask, sizeof(key_type)) == 0)) {
                out_entry = entry;
                out_location = location;

                return LA_STATUS_SUCCESS;
            }
        }

        location++;
    }

    return LA_STATUS_ENOTFOUND;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::find(const key_type& key, const key_type& mask, entry_pointer_type& out_entry, size_t& out_location)
{
    entry_wptr_type entry_wptr;
    auto status = find(key, mask, entry_wptr, out_location);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::locate_free_entry(size_t start_location, size_t& out_location) const
{
    if (start_location >= m_entries.size()) {
        return LA_STATUS_EINVAL;
    }

    auto it = std::find(m_entries.begin() + start_location, m_entries.end(), nullptr);
    if (it == m_entries.end()) {
        return LA_STATUS_ENOTFOUND;
    }

    out_location = std::distance(m_entries.begin(), it);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::locate_first_free_entry(size_t& out_location) const
{
    return locate_free_entry(0, out_location);
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::size() const
{
    size_t n = 0;

    for (auto entry : m_entries) {
        if (entry) {
            n++;
        }
    }

    return n;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::physical_size() const
{
    size_t n = 0;

    for (auto entry : m_phy_entries) {
        if (entry) {
            n++;
        }
    }

    return n;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::max_size() const
{
    return m_max_size;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_available_entries(size_t& out_available_space) const
{
    size_t smallest_available_space = (size_t)-1;

    for (auto translator : m_table_translators) {
        size_t translator_available_space;
        la_status status = translator->get_max_available_space(translator_available_space);
        return_on_error(status);
        smallest_available_space = std::min(smallest_available_space, translator_available_space);
    }
    out_available_space = smallest_available_space;
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_physical_usage(size_t& out_physical_usage) const
{
    size_t max_usage = 0;
    for (auto translator : m_table_translators) {
        size_t translator_usage;
        la_status status = translator->get_physical_usage(translator_usage);
        return_on_error(status);
        max_usage = std::max(max_usage, translator_usage);
    }
    out_physical_usage = max_usage;
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
size_t
npl_ternary_table<_Trait>::get_entries(entry_pointer_type* out_entries, size_t max_entries)
{
    size_t i = 0;
    for (auto entry : m_entries) {
        if (!entry) {
            continue;
        }

        out_entries[i] = entry.get();
        i++;

        if (i >= max_entries) {
            break;
        }
    }

    return i;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::set_entry_value(const entry_wptr_type& entry, const value_type& value)
{
    log_debug(NPLAPI,
              "%s::set(location=%lu, key=%s, mask=%s, value=%s)",
              _Trait::get_table_name().c_str(),
              entry->line(),
              to_short_string(entry->key()).c_str(),
              to_short_string(entry->mask()).c_str(),
              to_short_string(value).c_str());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    if (!entry) {
        return LA_STATUS_EINVAL;
    }

    // updating hw table
    size_t location = entry->line();
    const key_type& entry_key = entry->key();
    const key_type& entry_mask = entry->mask();
    for (auto translator : m_table_translators) {
        la_status status = translator->set_entry_value(location, entry_key, entry_mask, value);
        if (status != LA_STATUS_SUCCESS) {
            return LA_STATUS_EUNKNOWN;
        }
    }

    // hw table updated successfully, updating functional model
    entry->m_value = value;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::set_entry_value(const entry_pointer_type entry, const value_type& value)
{
    entry_wptr_type entry_wptr = entry->shared_from_this();
    auto status = set_entry_value(entry_wptr, value);
    return_on_error(status);
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
npl_tables_e
npl_ternary_table<_Trait>::get_table_type() const
{
    return _Trait::table_id;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::set_logical(size_t location, entry_sptr_type entry)
{
    log_debug(NPLAPI, "%s::set_logical(location=%lu)", _Trait::get_table_name().c_str(), location);
    entry->m_line = location;
    m_entries[location] = entry;
}

template <class _Trait>
typename npl_ternary_table<_Trait>::entry_sptr_type
npl_ternary_table<_Trait>::set_physical(size_t physical_location,
                                        const key_type& key,
                                        const key_type& mask,
                                        const value_type& value)
{
    log_debug(NPLAPI, "%s::set_physical(physical_location=%lu)", _Trait::get_table_name().c_str(), physical_location);
    auto new_entry = std::make_shared<entry_type>(this->shared_from_this(), physical_location, key, mask, value);

    m_phy_entries[physical_location] = new_entry;
    return new_entry;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::move_logical(entry_sptr_type entry, size_t new_location)
{
    log_debug(
        NPLAPI, "%s::move_logical(current=%lu, new_location=%lu)", _Trait::get_table_name().c_str(), entry->m_line, new_location);
    m_entries[entry->m_line] = nullptr;
    m_entries[new_location] = entry;
    entry->m_line = new_location;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::move_physical(entry_sptr_type entry, size_t new_physical_location)
{
    log_debug(NPLAPI,
              "%s::move_physical(current=%lu, new_physical_location=%lu)",
              _Trait::get_table_name().c_str(),
              entry->m_phy_line,
              new_physical_location);
    m_phy_entries[entry->m_phy_line] = nullptr;
    m_phy_entries[new_physical_location] = entry;
    entry->m_phy_line = new_physical_location;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::clear_logical(size_t location)
{
    log_debug(NPLAPI, "%s::clear_logical(location=%lu)", _Trait::get_table_name().c_str(), location);
    if (m_entries[location] == nullptr) {
        return;
    }

    m_entries[location] = nullptr;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::clear_physical(size_t physical_location)
{
    log_debug(NPLAPI, "%s::clear_physical(physical_location=%lu)", _Trait::get_table_name().c_str(), physical_location);
    auto entry = m_phy_entries[physical_location];
    m_phy_entries[physical_location] = nullptr;
    entry->m_phy_line = -1;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::set_resource_monitor(const resource_monitor_sptr& monitor)
{
    m_resource_monitor = monitor;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_resource_monitor(resource_monitor_sptr& out_monitor) const
{
    out_monitor = m_resource_monitor;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
const std::shared_ptr<la_status_info>
npl_ternary_table<_Trait>::create_e_resource_table_info() const
{
    la_resource_descriptor::type_e resource_type;
    std::shared_ptr<la_status_info_e_resource_table> table_info;
    if (m_resource_monitor != nullptr) {
        resource_type = static_cast<la_resource_descriptor::type_e>(m_resource_monitor->get_resource_type());
        table_info
            = std::make_shared<la_status_info_e_resource_table>(resource_type,                                  // resource enum
                                                                _Trait::get_table_name(),                       // name
                                                                m_resource_monitor->get_resource_instance_idx() // instance_id
                                                                );
    } else {
        resource_type = la_resource_descriptor::type_e::UNSPECIFIED;
        table_info = std::make_shared<la_status_info_e_resource_table>(resource_type,                     // resource enum
                                                                       _Trait::get_table_name(),          // name
                                                                       LA_RESOURCE_INSTANCE_INDEX_INVALID // instance_id
                                                                       );
    }
    return table_info;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::set_trans_info(void* trans_info)
{
    for (auto translator : m_table_translators) {
        la_status status = translator->set_trans_info(trans_info);
        if (status != LA_STATUS_SUCCESS) {
            return LA_STATUS_EUNKNOWN;
        }
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::get_free_tcam_line_after_last_entry(size_t& out_location)
{
    int last_entry_location = -1;

    for (size_t n = 0; n < m_entries.size(); n++) {
        if (m_entries[n]) {
            last_entry_location = n;
        }
    }

    out_location = (size_t)(last_entry_location + 1);

    if (out_location < m_entries.size()) {
        return LA_STATUS_SUCCESS;
    }

    return LA_STATUS_EOUTOFRANGE;
}

template <class _Trait>
la_status

npl_ternary_table<_Trait>::attach_table_info_to_la_status(la_status& status) const
{
    if (status == LA_STATUS_ERESOURCE) {

        la_status set_info_status = status.set_info(create_e_resource_table_info());
        return_on_error(set_info_status);
    }
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::push_bulk(size_t first_location, size_t entries_num, const vector_alloc<npl_entry_desc>& entries_info)
{
    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    if (first_location >= m_entries.size()) {
        return LA_STATUS_EOUTOFRANGE;
    }

    if (entries_num == 0) {
        return LA_STATUS_SUCCESS;
    }

    size_t free_slots_to_find = entries_num;
    size_t next_free_slot = 0;

    if (free_slots_to_find > 0) {
        // find free free_slots_to_find slots after first_location.
        next_free_slot = get_next_free_slot(m_entries, first_location, free_slots_to_find);

        // If not enough free slots, bail out.
        if (next_free_slot >= m_max_size) {
            return LA_STATUS_ERESOURCE;
        }
    }

    // if this is true, then all the entries_num slots from first_location are free - no need to push
    if (next_free_slot == first_location + entries_num - 1) {
        next_free_slot = 0;
    }

    vector_alloc<entry_sptr_type> entry_sptrs(entries_num);

    // push physical entries
    la_status status = push_physical_bulk(first_location, entries_num, entries_info, entry_sptrs);
    return_on_error(status);

    push_logical_bulk(first_location, entries_num, next_free_slot, entry_sptrs);

    return status;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::push_physical_bulk(size_t first_location,
                                              size_t entries_num,
                                              const vector_alloc<npl_entry_desc>& entries_info,
                                              vector_alloc<entry_sptr_type>& entry_sptrs)
{
    vector_alloc<size_t> empty_slots;
    size_t logical_idx = 0, physical_location = 0, physical_idx = 0;
    size_t empty_slot_physical_idx = 0, empty_slots_count = 0;
    la_status status;

    // search logical index of first_location
    status = get_logical_index(first_location, logical_idx);

    // search physical location of first_location and save the empty slots to fill later
    while (physical_idx != logical_idx) {
        if (m_phy_entries[physical_location]) {
            physical_idx++;
        } else {
            empty_slots.push_back(physical_location);
            empty_slots_count++;
        }
        physical_location++;
    }

    // if there are empty slots before physical_location - push entries to fill the slots to make room for bulk
    if (!empty_slots.empty()) {
        empty_slot_physical_idx = empty_slots[std::min(empty_slots_count - 1, empty_slots_count - entries_num)];
        for (size_t i = empty_slot_physical_idx; i < physical_location; i++) {
            size_t first_entry_to_move = i;
            size_t count_entries_to_move = 0;

            while (m_phy_entries[i] && i < physical_location) {
                count_entries_to_move++;
                i++;
            }

            if (count_entries_to_move > 0) {
                // Pull all count_entries_to_move entries from first_entry_to_move to empty_slot_physical_idx.
                for (auto translator : m_table_translators) {
                    status = translator->move(empty_slot_physical_idx, first_entry_to_move, count_entries_to_move);
                    return_on_error(status);
                }

                // Copy entries one level down till physical_location.
                for (size_t next_free_slot = empty_slot_physical_idx;
                     next_free_slot < empty_slot_physical_idx + count_entries_to_move;
                     next_free_slot++, first_entry_to_move++) {
                    move_physical(m_phy_entries[first_entry_to_move], next_free_slot);
                }

                empty_slot_physical_idx = empty_slot_physical_idx + count_entries_to_move;
            }
        }

        physical_location = empty_slot_physical_idx;
    }

    size_t free_slot = get_next_free_slot(m_phy_entries, physical_location, entries_num);
    // If no free slot, bail out.
    if (free_slot >= m_max_size) {
        return LA_STATUS_ERESOURCE;
    }
    // in case the free slot is above physical_location + entries_num, it means there are entries needed to be pushed
    if (free_slot >= physical_location + entries_num) {
        for (size_t i = free_slot - 1; i >= physical_location; i--) {
            if (m_phy_entries[i]) {
                for (auto translator : m_table_translators) {
                    status = translator->move(free_slot, i, 1);
                    return_on_error(status);
                }

                move_physical(m_phy_entries[i], free_slot);

                free_slot--;
            }
        }
    }

    status = insert_physical_bulk(physical_location, entries_num, entries_info, entry_sptrs);

    return status;
}

template <class _Trait>
la_status
npl_ternary_table<_Trait>::insert_physical_bulk(size_t physical_location,
                                                size_t entries_num,
                                                const vector_alloc<npl_entry_desc>& entries_info,
                                                vector_alloc<entry_sptr_type>& entry_sptrs)
{
    // At this point, all known conditions are checked and bulk insert is possible.
    for (auto translator : m_table_translators) {
        la_status status = translator->insert_bulk(physical_location, entries_num, entries_info);
        return_on_error(status);
    }

    // create and save entries in m_physical_entries
    for (size_t i = 0; i < entries_num; i++) {
        entry_sptrs[i] = set_physical(physical_location + i, entries_info[i].key, entries_info[i].mask, entries_info[i].value);
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
void
npl_ternary_table<_Trait>::push_logical_bulk(size_t first_location,
                                             size_t entries_num,
                                             size_t free_slot,
                                             vector_alloc<entry_sptr_type>& entries)
{
    log_debug(NPLAPI,
              "%s::insert_logical_bulk(logical_size=%lu, phy_size=%lu)",
              _Trait::get_table_name().c_str(),
              size(),
              physical_size());

    // if next_free_slot is 0 then no need to move entries
    if (free_slot > 0) {
        for (size_t i = free_slot - 1; i >= first_location; i--) {
            if (m_entries[i]) {
                move_logical(m_entries[i], free_slot);
                free_slot--;
            }
        }
    }

    for (size_t i = 0; i < entries_num; i++) {
        set_logical(first_location + i, entries[i]);
    }

    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }
}

} // namespace silicon_one

#endif
