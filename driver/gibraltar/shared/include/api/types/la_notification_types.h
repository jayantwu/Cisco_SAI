// BEGIN_LEGAL
//
// Copyright (c) 2017-current, Cisco Systems, Inc. ("Cisco"). All Rights Reserved.
//
// This file and all technical concepts, proprietary knowledge, algorithms and
// intellectual property rights it contains (collectively the "Confidential Information"),
// are the sole propriety information of Cisco and shall remain at Cisco's ownership.
// You shall not disclose the Confidential Information to any third party and you
// shall use it solely in connection with operating and/or maintaining of Cisco's
// products and pursuant to the terms and conditions of the license agreement you
// entered into with Cisco.
//
// THE SOURCE CODE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
// IN NO EVENT SHALL CISCO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
// THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// END_LEGAL

#ifndef __LA_NOTIFICATION_TYPES_H__
#define __LA_NOTIFICATION_TYPES_H__

/// @file
/// @brief Leaba MAC Port API-s.
///
/// Defines API-s for managing MAC port.
///

#include "api/types/la_bfd_types.h"
#include "api/types/la_common_types.h"
#include "api/types/la_system_types.h"
#include "api/types/la_tm_types.h"

/// @file
/// @brief Leaba notifications API
///

namespace silicon_one
{

/// @brief Notifications API exposes interrupts generated by Leaba device to the application using the SDK.
///
/// This API allows to monitor device interrupts and discover interrupt sources.
/// There are several interrupt types, each accompanied with a meta data.
/// See #silicon_one::la_notification_type_e and #silicon_one::la_notification_desc.
///
/// The interrupt monitoring and information extraction is done through a file
/// descriptor. A file descriptor may be attached to multiple interrupt types,
/// but each interrupt type can map to only one file descriptor.
///
/// An application can monitor multile file descriptors simultaneously with select/poll or similar.
///
/// The following operations can be performed on the file descriptor:
///     read()
///         Read notification descriptor.
///         Can be called as a blocking operation, in which case read() will
///         return either with a full notification descriptor or if signalled.
///
///     poll()/select() (and similar)
///         The file descriptor is readable if one or more notification descriptors
///         are available for read.
///
/// Note, calling close() on the file descriptor would interfere with SDK's internal book keeping.
/// Use silicon_one::la_device::close_notification_fd() instead.
///

#pragma pack(push, 1)

enum class la_notification_type_e : uint8_t {
    NONE = 0, ///< Reserved
    BFD,
    ECC, ///< ECC error reported by anything other than CIF block protected memory.
    ECC_REMOTE,
    INFORMATIVE,          ///< Informative.
    LACK_OF_RESOURCES,    ///< Lack of resources.
    LINK,                 ///< MAC link notification.
    LPM_SRAM_MEM_PROTECT, ///< Memory protection error in LPM SRAM - ECC 1b, ECC 2b.
    MEM_PROTECT,          ///< Generic CIF block memory protection - ECC 1b, ECC 2b, Parity.
    MISCONFIGURATION,     ///< Misconfiguration.
    OTHER,
    PCI,                          ///< PCI interface hotplug and AER.
    RESOURCE_MONITOR,             ///< Resources notifications.
    THRESHOLD_CROSSED,            ///< Threshold crossed.
    PFC_WATCHDOG,                 ///< PFC watchdog events.
    CREDIT_GRANT_DEV_UNREACHABLE, ///< Unreachable device during credit grant event.
    QUEUE_AGED_OUT,               ///< VOQ with packets is not granted with credits.
    DRAM_CORRUPTED_BUFFER,        ///< DRAM corrupted buffer.
    LAST                          ///< Reserved.
};

/// @brief  Bit mask for all notifications
static const int LA_NOTIFICATION_MASK_ALL = ((1 << (int)la_notification_type_e::LAST) - 1);

/// @brief Link notification types.
enum class la_link_notification_type_e : uint8_t {
    UP = 0, ///< MAC link UP.
    DOWN,   ///< MAC link down.
    ERROR,  ///< MAC link error.
    LAST
};

/// @brief Request for application action
///
/// Action that SDK recommends the application to perform as a result of delivered notification.
enum class la_notification_action_e : uint8_t {
    NONE,
    FIRST = NONE,

    HARD_RESET,     ///< Hard reset
    SOFT_RESET,     ///< Soft reset
    REPLACE_DEVICE, ///< Replace device

    LAST = REPLACE_DEVICE,
};

/// @brief Memory protection errors
///
/// @note  The enum values are used both for generic logic and as bit shifts or values for mem_protect registers
enum class la_mem_protect_error_e {
    ECC_1B = 0, ///< 1bit ECC error
    FIRST = ECC_1B,

    ECC_2B = 1, ///< 2bit ECC error
    PARITY = 2, ///< Parity error

    LAST = PARITY
};

/// @brief MAC link_down interrupt information.
struct link_down_interrupt_info {
    bool rx_link_status_down;                                                    ///< MAC link down
    bool rx_remote_link_status_down;                                             ///< MAC fault type - True = Remote, False = Local
    bool rx_pcs_link_status_down;                                                ///< PCS link down
    bool rx_pcs_align_status_down;                                               ///< Alignment marker down
    bool rx_pcs_hi_ber_up;                                                       ///< PCS high BER
    bool rsf_rx_high_ser_interrupt_register;                                     ///< RS-FEC high SER
    bool rx_deskew_fifo_overflow[la_mac_port_max_lanes_e::PCS];                  ///< PCS Rx deskew fifo overflow.
    bool rx_pma_sig_ok_loss_interrupt_register[la_mac_port_max_lanes_e::SERDES]; ///< CDR lock loss
};

/// @brief MAC link_error interrupt information.
struct link_error_interrupt_info {
    bool rx_code_error;           ///< MAC Rx code error.
    bool rx_crc_error;            ///< MAC Rx CRC error.
    bool rx_invert_crc_error;     ///< MAC Rx inverted CRC error.
    bool rx_oob_invert_crc_error; ///< MAC Rx Out-Of-Band interleaved inverted CRC error.
    bool rx_oversize_error;       ///< MAC Rx oversize error.
    bool rx_undersize_error;      ///< MAC Rx undersize error.

    bool tx_crc_error;         ///< MAC Tx CRC error.
    bool tx_underrun_error;    ///< MAC Tx underrun error.
    bool tx_missing_eop_error; ///< MAC Tx missing End-Of-Packet.

    bool rsf_rx_degraded_ser;        ///< RS-FEC degraded SER.
    bool rsf_rx_remote_degraded_ser; ///< RS-FEC remote degraded SER.

    bool device_time_fifo_not_empty; ///< Device time fifo of port is not empty.
    bool device_time_override;       ///< Device time failed to read before next packet with record command.
    bool ptp_time_stamp_error;       ///< PTP time stamp operation failed and packet will be sent with bad CRC.
};

/// @brief MAC link interrupt information union.
union link_interrupt_info {
    link_down_interrupt_info link_down;
    link_error_interrupt_info link_error;
};

/// @brief BFD events.
enum class la_bfd_notification_cause {
    STATE_CHANGE,  ///< State received from remote has changed.
    TIME_EXCEEDED, ///< No packet received within configured detection time.
};

enum class la_pci_notification_type_e {
    HOT_REMOVE,          ///< PCI hot remove
    AER_NON_RECOVERABLE, ///< PCI AER non-recoverable
    AER_RECOVERABLE,     ///< PCI AER recoverable
    AER_RECOVERED,       ///< PCI AER recoverable
    NODEV,               ///< PCI device is not present
};

struct lpm_sram_mem_protect {
    la_mem_protect_error_e error;    ///< ECC 1b or 2b.
    la_block_id_t cdb_core_block_id; ///< Block ID of the corresponding CDB core.
    la_entry_addr_t addr;            ///< LPM entry.
    uint8_t lpm_index;               ///< LPM index, 0 or 1.
};

struct dram_corrupted_buffer {
    uint8_t bank_base;    ///< Base bank of the corrupted DRAM buffer.
    uint8_t channel_base; ///< Base channel of the corrupted DRAM buffer.
    uint16_t row;         ///< Row of the corrupted DRAM buffer.
    uint8_t column;       ///< Column of the corrupted DRAM buffer.
    uint64_t bad_cells;   ///< Bitmask that indicates which of the cells in the DRAM buffer are corrupted.
};

typedef uint64_t la_notification_id_t;

/// @brief  Interrupt descriptor
struct la_notification_desc {
    /// Unique ID of this descriptor, non-zero, wraps around at UINT64_MAX
    la_notification_id_t id;

    /// Block ID of interrupt source register
    la_block_id_t block_id;

    /// Address of interrupt source register
    la_entry_addr_t addr;

    /// Index of interrupt bit in the interrupt source register
    uint32_t bit_i;

    /// Time stamp of the notification in nano-seconds based on CLOCK_MONOTONIC.
    uint64_t timestamp_ns;

    /// Notification type
    la_notification_type_e type;

    /// Requested action
    la_notification_action_e requested_action;

    /// Threshold value for the requested action, 0 if no threshold was crossed.
    uint32_t action_threshold;

    union u_s {
        /// Interrupt data for la_notification_type_e::MEM_PROTECT
        struct mem_protect_s {
            la_mem_protect_error_e error;
            la_entry_addr_t instance_addr;
            la_entry_addr_t entry;
        } mem_protect;

        /// Interrupt data for la_notification_type_e::LPM_SRAM_MEM_PROTECT
        struct lpm_sram_mem_protect lpm_sram_mem_protect;

        /// Interrupt data for la_notification_type_e::DRAM_CORRUPTED_BUFFER
        struct dram_corrupted_buffer dram_corrupted_buffer;

        /// Interrupt data for la_notification_type_e::ECC
        struct ecc_s {
            uint64_t data;
        } ecc;

        /// Interrupt data for la_notification_type_e::ECC_REMOTE
        struct ecc_remote_s {
            uint64_t data;
        } ecc_remote;

        /// Interrupt data for la_notification_type_e::LINK_UP
        struct link_s {
            /// Notification type
            la_link_notification_type_e type;

            la_slice_id_t slice_id;
            la_ifg_id_t ifg_id;
            la_uint_t first_serdes_id;

            link_interrupt_info u;
        } link;

        /// Interrupt data for la_notification_type_e::LACK_OF_RESOURCES
        struct lack_of_resources_s {
            uint64_t data;
        } lack_of_resources;

        /// Interrupt data for la_notification_type_e::RESOURCE_MONITOR
        struct resource_monitor_s {
            la_resource_usage_descriptor resource_usage;
        } resource_monitor;

        /// Interrupt data for la_notification_type_e::THRESHOLD_CROSSED
        struct threshold_crossed_s {
            uint64_t data;
        } threshold_crossed;

        /// Interrupt data for la_notification_type_e::INFORMATIVE
        struct informative_s {
            uint64_t data;
        } informative;

        /// Interrupt data for la_notification_type_e::MISCONFIGURATION
        struct misconfiguration_s {
            uint64_t data;
        } misconfiguration;

        /// Notification data for la_notification_type_e::BFD
        struct bfd_s {
            la_bfd_discriminator local_discriminator;
            la_bfd_notification_cause cause;

            struct state_change_s {
                la_bfd_flags flags;
                la_bfd_diagnostic_code_e diagnostic_code;
            } state_change;
        } bfd;

        /// Notification data for la_notification_type_e::PCI
        struct pci_s {
            la_pci_notification_type_e type;
        } pci;

        /// Notification data for la_notification_type_e::PFC_WATCHDOG
        struct pfc_watchdog_s {
            la_slice_id_t slice_id;
            la_ifg_id_t ifg_id;
            la_uint_t first_serdes_id;
            la_uint8_t pfc_priority; // PFC priority class of queue that is stuck. Definition of stuck is:
                                     // 1. non-empty.
                                     // 2. queue ptrs have not moved in one polling time,
                                     // 3. PFC packets have been received for that class in the last polling time.
            bool detected;           // pfc watchdog detected (true) or pfc watchdog recovered (false)
                                     // If no pfc watchdog recovery interval is specified, then you will not receive
                                     // this notification for a recovered pfc watchdog, just the detected state.
        } pfc_watchdog;

        /// Notification data for la_notification_type_e::CREDIT_GRANT_DEV_UNREACHABLE
        struct dev_unreachable_s {
            la_device_id_t remote_dev_id; // ID of the remote unreachable device
            la_slice_id_t slice_id;       // Local slice ID of the VSC sending credits to the remote device
            la_ifg_id_t ifg_id;           // Local IFG ID of the VSC sending credits to the remote device
            la_vsc_gid_t vsc_id;          // Local VSC sending credits to the remote device
        } dev_unreachable;

        /// Notification data for la_notification_type_e::QUEUE_AGED_OUT
        struct voq_info_s {
            la_voq_gid_t voq_id;
        } voq_info;

    } u;
};

#pragma pack(pop)
} // namespace silicon_one

/// @}

#endif
