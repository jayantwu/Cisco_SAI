// BEGIN_LEGAL
//
// Copyright (c) 2017-current, Cisco Systems, Inc. ("Cisco"). All Rights Reserved.
//
// This file and all technical concepts, proprietary knowledge, algorithms and
// intellectual property rights it contains (collectively the "Confidential Information"),
// are the sole propriety information of Cisco and shall remain at Cisco's ownership.
// You shall not disclose the Confidential Information to any third party and you
// shall use it solely in connection with operating and/or maintaining of Cisco's
// products and pursuant to the terms and conditions of the license agreement you
// entered into with Cisco.
//
// THE SOURCE CODE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
// IN NO EVENT SHALL CISCO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
// THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// END_LEGAL

#include "em/crc_divisors.h"

#include <map>

namespace silicon_one
{

typedef std::multimap<size_t, em::hash_bv_t> crc_divisor_map_t;

static const crc_divisor_map_t s_crc_long_primitive_divisor_map = {
    // for hash{16}{16} = 10110100000000001
    {16, em::hash_bv_t("0x16801", 17)},

    // for hash{18}{18} = 1000000100000000001
    {18, em::hash_bv_t("0x40801", 19)},

    // for hash{20}{20} = 110010100000000000001
    {20, em::hash_bv_t("0x194001", 21)},

    // for hash{22}{22} = 11000000000000000000001
    {22, em::hash_bv_t("0x600001", 23)},

    // for hash{24}{24} = 1101100000000000000000001
    {24, em::hash_bv_t("0x1b00001", 25)},

    // for hash{26}{26} = 111000100000000000000000001
    {26, em::hash_bv_t("0x7100001", 27)},

    // for hash{28}{28} = 11001010000000000000000000001
    {28, em::hash_bv_t("0x19400001", 29)},

    // for hash{30}{30} = 1100101000000000000000000000001
    {30, em::hash_bv_t("0x65000001", 31)},

    // for hash{32}{32} = 101000110000000000000000000000001
    {32, em::hash_bv_t("0x146000001", 33)},

    // for hash{34}{34} = 10011000100000000000000000000000001
    {34, em::hash_bv_t("0x4c4000001", 35)},

    // for hash{36}{36} = 1100000110000000000000000000000000001
    {36, em::hash_bv_t("0x1830000001", 37)},

    // for hash{38}{38} = 110001100000000000000000000000000000001
    {38, em::hash_bv_t("0x6300000001", 39)},

    // for hash{40}{40} = 10011100000000000000000000000000000000001
    {40, em::hash_bv_t("0x13800000001", 41)},

    // for hash{42}{42} = 1010010100000000000000000000000000000000001
    {42, em::hash_bv_t("0x52800000001", 43)},

    // for hash{44}{44} = 101001100000000000000000000000000000000000001
    {44, em::hash_bv_t("0x14c000000001", 45)},

    // for hash{46}{46} = 10000011100000000000000000000000000000000000001
    {46, em::hash_bv_t("0x41c000000001", 47)},

    // for hash{48}{48} = 1000100101000000000000000000000000000000000000001
    {48, em::hash_bv_t("0x1128000000001", 49)},

    // for hash{50}{50} = 101110000000000000000000000000000000000000000000001
    {50, em::hash_bv_t("0x5c00000000001", 51)},

    // for hash{56}{56} = 110001100000000000000000000000000000000000000000000000001
    {56, em::hash_bv_t("0x18c000000000001", 57)},

    // for hash{58}{58} = 11000110000000000000000000000000000000000000000000000000001
    {58, em::hash_bv_t("0x630000000000001", 59)},

    // for hash{64}{64} = 11011000000000000000000000000000000000000000000000000000000000001
    {64, em::hash_bv_t("0x1b000000000000001", 65)},

    // for hash{70}{70} = 11010100000000000000000000000000000000000000000000000000000000000000001
    {70, em::hash_bv_t("0x6a0000000000000001", 71)},

    // for hash{76}{76} = 10101100000000000000000000000000000000000000000000000000000000000000000000001
    {76, em::hash_bv_t("0x15800000000000000001", 77)},

    // for hash{78}{78} = 1110000100000000000000000000000000000000000000000000000000000000000000000000001
    {78, em::hash_bv_t("0x70800000000000000001", 79)},

    // for hash{80}{80} = 101010000100000000000000000000000000000000000000000000000000000000000000000000001
    {80, em::hash_bv_t("0x150800000000000000001", 81)},

    // for hash{92}{92} = 101001100000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {92, em::hash_bv_t("0x14c000000000000000000001", 93)},

    // for hash{112}{112} =
    // 10001010000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {112, em::hash_bv_t("0x11420000000000000000000000001", 113)},

    // for hash{140}{140} =
    // 100000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {140, em::hash_bv_t("0x100000008000000000000000000000000001", 141)},

    // for hash{142}{142} =
    // 11010000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {142, em::hash_bv_t("0x681000000000000000000000000000000001", 143)}};

static const crc_divisor_map_t s_crc_long_non_primitive_divisor_map = {
    // for hash{16}{16} = 11111111000000001
    {16, em::hash_bv_t("0x1fe01", 17)},

    // for hash{18}{18} = 1111111110000000001
    {18, em::hash_bv_t("0x7fc01", 19)},

    // for hash{20}{20} = 111111111100000000001
    {20, em::hash_bv_t("0x1ff801", 21)},

    // for hash{22}{22} = 11111111111000000000001
    {22, em::hash_bv_t("0x7ff001", 23)},

    // for hash{24}{24} = 1111111111110000000000001
    {24, em::hash_bv_t("0x1ffe001", 25)},

    // for hash{26}{26} = 111111111111100000000000001
    {26, em::hash_bv_t("0x7ffc001", 27)},

    // for hash{28}{28} = 11111111111110000000000000001
    {28, em::hash_bv_t("0x1fff0001", 29)},

    // for hash{30}{30} = 1111111111111010000000000000001
    {30, em::hash_bv_t("0x7ffd0001", 31)},

    // for hash{32}{32} = 111111111111101000000000000000001
    {32, em::hash_bv_t("0x1fff40001", 33)},

    // for hash{34}{34} = 11111111111111110000000000000000001
    {34, em::hash_bv_t("0x7fff80001", 35)},

    // for hash{36}{36} = 1111111111111110100000000000000000001
    {36, em::hash_bv_t("0x1fffd00001", 37)},

    // for hash{38}{38} = 111111111111010001000000000000000000001
    {38, em::hash_bv_t("0x7ffa200001", 39)},

    // for hash{40}{40} = 11111111111111001000000000000000000000001
    {40, em::hash_bv_t("0x1fff9000001", 41)},

    // for hash{42}{42} = 1111111111111100100000000000000000000000001
    {42, em::hash_bv_t("0x7ffe4000001", 43)},

    // for hash{44}{44} = 111111111111111001000000000000000000000000001
    {44, em::hash_bv_t("0x1fffc8000001", 45)},

    // for hash{46}{46} = 11111011101001000000000000000000000000000000001
    {46, em::hash_bv_t("0x7dd200000001", 47)},

    // for hash{48}{48} = 1111111111111111100100000000000000000000000000001
    {48, em::hash_bv_t("0x1ffff20000001", 49)},

    // for hash{50}{50} = 111111111111110000000010000000000000000000000000001
    {50, em::hash_bv_t("0x7ffe010000001", 51)},

    // for hash{56}{56} = 111111111111001100100000000000000000000000000000000000001
    {56, em::hash_bv_t("0x1ffe64000000001", 57)},

    // for hash{58}{58} = 11111111111100110010000000000000000000000000000000000000001
    {58, em::hash_bv_t("0x7ff990000000001", 59)},

    // for hash{64}{64} = 11111001111111000000000000000000000000000000000000000000000000001
    {64, em::hash_bv_t("0x1f3f8000000000001", 65)},

    // for hash{70}{70} = 11111111111111000100000000000000000000000000000000000000000000000000001
    {70, em::hash_bv_t("0x7ffe20000000000001", 71)},

    // for hash{76}{76} = 11111111111110010000000000000000000000000000000000000000000000000000000000001
    {76, em::hash_bv_t("0x1fff2000000000000001", 77)},

    // for hash{78}{78} = 1111100011111110010000000000000000000000000000000000000000000000000000000000001
    {78, em::hash_bv_t("0x7c7f2000000000000001", 79)},

    // for hash{80}{80} = 111111111111110000001000000000000000000000000000000000000000000000000000000000001
    {80, em::hash_bv_t("0x1fff81000000000000001", 81)},

    // for hash{92}{92} = 111111111101000101000000000000000000000000000000000000000000000000000000000000000000000000001
    {92, em::hash_bv_t("0x1ffa28000000000000000001", 93)},

    // for hash{106}{106} =
    // 11111111111110000000010000100000000000000000000000000000000000000000000000000000000000000000000000000000001
    {106, em::hash_bv_t("0x7ffc02100000000000000000001", 107)},

    // for hash{112}{112} =
    // 11111110110111110000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {112, em::hash_bv_t("0x1fdbe040000000000000000000001", 113)},

    // for hash{140}{140} =
    // 111111111111000100001000010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {140, em::hash_bv_t("0x1ffe21088000000000000000000000000001", 141)},

    // for hash{142}{142} =
    // 11111111111111000100001000010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    {142, em::hash_bv_t("0x7ffe21088000000000000000000000000001", 143)},

    // for hash{158}{158} =
    // 101101111000001011010001000000001000000000000001001001000011000100001110100001100000000000000000000000000000000000000000000000000000000000000000000000000000001
    {158, em::hash_bv_t("0x5bc1688040009218874300000000000000000001", 159)}};

static const crc_divisor_map_t s_crc_short_divisor_map = {
    // for hash{8}{3} = 1101
    {8, em::hash_bv_t("0xd", 4)},

    // for hash{9}{4} = 11001
    {9, em::hash_bv_t("0x19", 5)},

    // for hash{10}{4} = 11001
    {10, em::hash_bv_t("0x19", 5)},

    // for hash{11}{4} = 11001
    {11, em::hash_bv_t("0x19", 5)},

    // for hash{12}{4} = 11001
    {12, em::hash_bv_t("0x19", 5)},

    // for hash{13}{4} = 11001
    {13, em::hash_bv_t("0x19", 5)},

    // for hash{14}{4} = 11001
    {14, em::hash_bv_t("0x19", 5)},

    // for hash{15}{4} = 11001
    {15, em::hash_bv_t("0x19", 5)},

    // for hash{16}{4} = 11001
    {16, em::hash_bv_t("0x19", 5)},

    // for hash{17}{5} = 111101
    {17, em::hash_bv_t("0x3d", 6)},

    // for hash{18}{5} = 111101
    {18, em::hash_bv_t("0x3d", 6)},

    // for hash{19}{5} = 111101
    {19, em::hash_bv_t("0x3d", 6)},

    // for hash{20}{5} = 111101
    {20, em::hash_bv_t("0x3d", 6)},

    // for hash{21}{5} = 111101
    {21, em::hash_bv_t("0x3d", 6)},

    // for hash{22}{5} = 111101
    {22, em::hash_bv_t("0x3d", 6)},

    // for hash{23}{5} = 111101
    {23, em::hash_bv_t("0x3d", 6)},

    // for hash{24}{5} = 111101
    {24, em::hash_bv_t("0x3d", 6)},

    // for hash{25}{5} = 111101
    {25, em::hash_bv_t("0x3d", 6)},

    // for hash{28}{5} = 111101
    {28, em::hash_bv_t("0x3d", 6)},

    // for hash{29}{5} = 111101
    {29, em::hash_bv_t("0x3d", 6)},

    // for hash{32}{5} = 111101
    {32, em::hash_bv_t("0x3d", 6)},

    // for hash{35}{6} = 1101101
    {35, em::hash_bv_t("0x6d", 7)},

    // for hash{36}{6} = 1101101
    {36, em::hash_bv_t("0x6d", 7)},

    // for hash{38}{6} = 1101101
    {38, em::hash_bv_t("0x6d", 7)},

    // for hash{39}{6} = 1101101
    {39, em::hash_bv_t("0x6d", 7)},

    // for hash{40}{6} = 1101101
    {40, em::hash_bv_t("0x6d", 7)},

    // for hash{46}{6} = 1101000
    {46, em::hash_bv_t("0x68", 7)},

    // for hash{53}{6} = 1101101
    {53, em::hash_bv_t("0x6d", 7)},

    // for hash{56}{6} = 1101101
    {56, em::hash_bv_t("0x6d", 7)},

    // for hash{70}{7} = 11000001
    {70, em::hash_bv_t("0xc1", 8)},

    // for hash{71}{7} = 11110001
    {71, em::hash_bv_t("0xf1", 8)},

    // for hash{79}{7} = 11000001
    {79, em::hash_bv_t("0xc1", 8)}};

em::hash_bv_t
get_crc_divisor(const crc_divisor_map_t& mymap, size_t key_width)
{
    auto found_entry = mymap.find(key_width);
    if (found_entry == mymap.end()) {
        return em::hash_bv_t();
    }

    return found_entry->second;
}

em::hash_bv_t
get_long_primitive_crc_divisor(size_t key_width)
{
    return get_crc_divisor(s_crc_long_primitive_divisor_map, key_width);
}

em::hash_bv_t
get_long_non_primitive_crc_divisor(size_t key_width)
{
    return get_crc_divisor(s_crc_long_non_primitive_divisor_map, key_width);
}

em::hash_bv_t
get_short_crc_divisor(size_t key_width)
{
    return get_crc_divisor(s_crc_short_divisor_map, key_width / 2);
}

} // namespace silicon_one
