#!/usr/bin/env python3
# BEGIN_LEGAL
#
# Copyright (c) 2017-current, Cisco Systems, Inc. ("Cisco"). All Rights Reserved.
#
# This file and all technical concepts, proprietary knowledge, algorithms and
# intellectual property rights it contains (collectively the "Confidential Information"),
# are the sole propriety information of Cisco and shall remain at Cisco's ownership.
# You shall not disclose the Confidential Information to any third party and you
# shall use it solely in connection with operating and/or maintaining of Cisco's
# products and pursuant to the terms and conditions of the license agreement you
# entered into with Cisco.
#
# THE SOURCE CODE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
# IN NO EVENT SHALL CISCO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
# THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# END_LEGAL

import os.path
import logging
import sys
import argparse

from nplapi_utilities import file_utils
from nplapi_utilities import nplapi_table_json_reader


#######################################################
# CLASS: npl_tables_file_template
# @brief Generates npl_tables header file
#######################################################


class npl_tables_file_template:
    file_name = 'nplapi_tables.h'

    prefix = '''
        // npsuite compiled headers
        #include "nplapi/npl_enums.h"
        #include "nplapi/npl_tables_enum.h"
        #include "nplapi/npl_table_types.h"
        #include "nplapi/npl_functional_table_traits.h"

        // nplapi
        #include "nplapi/npl_table.h"
        #include "nplapi/npl_lpm_table.h"
        #include "nplapi/npl_ternary_table.h"

        #include "common/weak_ptr_unsafe.h"
        namespace silicon_one {
    '''
    file_line = '''
        // table:    %(name)s
        // type:     %(location)s/%(match_type)s
        typedef %(functional_table)s<npl_%(name)s_functional_traits_t> npl_%(name)s_t;
        typedef std::shared_ptr<%(functional_table)s<npl_%(name)s_functional_traits_t> > npl_%(name)s_sptr_t;
        typedef typename npl_%(name)s_t::entry_type npl_%(name)s_entry_t;
        typedef typename std::shared_ptr<npl_%(name)s_t::entry_type> npl_%(name)s_entry_sptr_t;
        typedef weak_ptr_unsafe<npl_%(name)s_t::entry_type> npl_%(name)s_entry_wptr_t;
    '''

    suffix = '''
        }; // namespace silicon_one
    '''

    @classmethod
    def generate_file(cls, dir_name, data):

        lines = []
        lines.append(cls.prefix)

        for params in data:
            lines.append(cls.file_line % params)

        lines.append(cls.suffix)

        file_utils.generate_header_file(dir_name, cls.file_name, lines)


#######################################################
# CLASS: npl_tables_swig_file_template
# @brief Generates npl_tables SWIG file
#######################################################


class npl_tables_swig_file_template:
    file_name = 'nplapi_tables.i'

    file_line = '''NPL_TABLE_TEMPLATE_TYPEMAPS(%(name)s, %(functional_table)s)'''

    @classmethod
    def generate_file(cls, dir_name, data):

        lines = []
        for params in data:
            lines.append(cls.file_line % params)

        file_utils.generate_source_file(dir_name, cls.file_name, lines)

#######################################################
# SCRIPT
#######################################################


def parse_arguments():
    # configure an argument parser
    parser = argparse.ArgumentParser(
        description="Generate table definitions, based on NPL compiler inputs",
        add_help=True)

    req_group = parser.add_argument_group(title='required arguments')
    req_group.add_argument('-m', '--metadata_file', required=True, help='input JSON file generated by NPL compiler')
    req_group.add_argument('-o', '--output', required=True, help='base output directory to store results')
    parser.add_argument('-v', '--verbose', required=False, action='store_true', help='verbose/debug mode')

    # parse arguments
    parsed_args = parser.parse_args()

    # enable debugging if verbose argument is enable
    if parsed_args.verbose:
        logging.basicConfig(stream=sys.stderr, level=logging.DEBUG, format='%(funcName)-20s:%(lineno)3s: %(message)s')
    else:
        logging.basicConfig(stream=sys.stdout, level=logging.INFO, format='-I- %(message)s')

    logging.debug("Output dir = %s" % parsed_args.output)
    logging.debug("Metadata file = %s" % parsed_args.metadata_file)
    return parsed_args


if __name__ == '__main__':
    parsed_args = parse_arguments()
    os.makedirs(parsed_args.output, exist_ok=True)

    # Parse input file
    table_def_generator = nplapi_table_json_reader(parsed_args.metadata_file)
    table_params = table_def_generator.read()

    # generate npl_tables.h
    npl_tables_file_template.generate_file(parsed_args.output, table_params)

    # generate npl_tables.i
    npl_tables_swig_file_template.generate_file(parsed_args.output, table_params)

    keys = ['name', 'key_width', 'payload_width', 'match_type', 'location', 'context', 'database', 'block', ]
    table_def_generator.dump_csv(parsed_args.output + '/nplapi_tables.csv', keys)
