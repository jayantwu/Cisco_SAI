// BEGIN_LEGAL
//
// Copyright (c) 2016-current, Cisco Systems, Inc. ("Cisco"). All Rights Reserved.
//
// This file and all technical concepts, proprietary knowledge, algorithms and
// intellectual property rights it contains (collectively the "Confidential Information"),
// are the sole propriety information of Cisco and shall remain at Cisco's ownership.
// You shall not disclose the Confidential Information to any third party and you
// shall use it solely in connection with operating and/or maintaining of Cisco's
// products and pursuant to the terms and conditions of the license agreement you
// entered into with Cisco.
//
// THE SOURCE CODE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED.
// IN NO EVENT SHALL CISCO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
// THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// END_LEGAL

#ifndef __NPL_LPM_TABLE_H__
#define __NPL_LPM_TABLE_H__

#include <algorithm>
#include <set>
#include <string.h>

#include "api/types/la_status_info_types.h"
#include "common/defines.h"
#include "common/gen_operators.h"
#include "common/la_status.h"
#include "common/resource_monitor.h"
#include "common/weak_ptr_unsafe.h"
#include "nplapi/npl_lpm_bulk_types.h"
#include "nplapi/npl_lpm_table_translator_base.h"

#include "nplapi/npl_tables_enum.h"

namespace silicon_one
{

/// @brief NPL table
///
/// Provides basic facilities for maintaining NPL tables: insert, erase, lookup, etc.
template <class _Trait>
class npl_lpm_table : public std::enable_shared_from_this<npl_lpm_table<_Trait> >
{

    CEREAL_SUPPORT_PRIVATE_MEMBERS

public:
    typedef _Trait trait_type;

    typedef typename _Trait::key_type key_type;
    typedef typename _Trait::value_type value_type;

    /// @brief NPL table entry, consists of a <key, value> pair.
    /// Key and Value types are typically auto-generated by the NPL compiler.
    class entry : public std::enable_shared_from_this<entry>
    {

        CEREAL_SUPPORT_PRIVATE_MEMBERS

    public:
        typedef npl_lpm_table<_Trait> table_type;
        friend table_type;

        entry(weak_ptr_unsafe<table_type> table,
              const key_type& key,
              size_t length,
              const value_type& value,
              la_user_data_t user_data,
              bool latency_sensitive);

        const key_type& key() const;
        size_t length() const;
        const value_type& value() const;

        la_user_data_t user_data() const;
        bool latency_sensitive() const;

        la_status update(value_type const& value, la_user_data_t user_data);

    private:
        entry() = default;

        template <class Archive>
        void serialize(Archive& ar)
        {
            ar(m_length);
            ar(m_key);
            ar(m_value);
            ar(m_user_data);
            ar(m_latency_sensitive);
            ar(m_table);
        }

        weak_ptr_unsafe<table_type> m_table;
        size_t m_length;
        key_type m_key;
        value_type m_value;
        la_user_data_t m_user_data;
        bool m_latency_sensitive;
    };

    typedef entry entry_type;
    typedef std::shared_ptr<entry_type> entry_sptr_type;
    typedef weak_ptr_unsafe<entry_type> entry_wptr_type;
    typedef entry_type* entry_pointer_type;
    typedef entry_type& entry_type_reference;

    typedef npl_lpm_table_translator_base<_Trait> table_translator_t;
    typedef std::shared_ptr<table_translator_t> table_translator_sptr_t;
    typedef std::vector<table_translator_t*> table_translator_vec_t;
    typedef std::vector<table_translator_sptr_t> table_translator_sptr_vec_t;

    /// @brief Comparator for NPL table entries.
    struct entry_less {
        bool operator()(const entry_sptr_type lhs, const entry_sptr_type rhs) const;
    };

    typedef std::set<entry_sptr_type, entry_less> container_type;

    npl_lpm_table();
    ~npl_lpm_table();

    /// @brief Initialize the table object.
    ///
    /// @param[in] tranlsators          Translators to be updated on insert/update/erase operations.
    ///
    /// @retval LA_STATUS_SUCCESS       Success.
    /// @retval LA_STATUS_EEXIST        Double initialization with different index.
    /// @retval LA_STATUS_EUNKONWN      Internal error.
    la_status initialize(table_translator_sptr_vec_t& translators);

    /// @brief Add a new entry to the table.
    ///
    /// If key already exists, out_entry will point to the existing entry in the table.
    ///
    /// @param[in]  key                         The key of the new entry.
    /// @param[in]  length                      Length of the prefix to use for matching the entry.
    /// @param[in]  user_data                   Opaque data associated with the entry.
    /// @param[in]  latency_sensitive           Boolean to specify if it's high-priority route.
    /// @param[in]  value                       The value of the new entry.
    /// @param[out] out_entry                   Host representation of the new entry.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized.
    /// @retval     LA_STATUS_EEXIST            Entry already exists in the table. out_entry points to the existing entry.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status insert(const key_type& key,
                     size_t length,
                     const value_type& value,
                     la_user_data_t user_data,
                     bool latency_sensitive,
                     entry_wptr_type& out_entry);

    /// @brief Add a new entry to the table.
    ///
    /// If key already exists, out_entry will point to the existing entry in the table.
    ///
    /// @param[in]  key                         The key of the new entry.
    /// @param[in]  length                      Length of the prefix to use for matching the entry.
    /// @param[in]  user_data                   Opaque data associated with the entry.
    /// @param[in]  latency_sensitive           Boolean to specify if it's high-priority route.
    /// @param[in]  value                       The value of the new entry.
    /// @param[out] out_entry                   Host representation of the new entry.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED   Table object was not initialized.
    /// @retval     LA_STATUS_EEXIST            Entry already exists in the table. out_entry points to the existing entry.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status insert(const key_type& key,
                     size_t length,
                     const value_type& value,
                     la_user_data_t user_data,
                     bool latency_sensitive,
                     entry_pointer_type& out_entry);

    /// @brief Remove a specific entry in the table.
    ///
    /// @param[in]  key                          The key of the removed entry.
    /// @param[in]  length                       Length of the prefix to use for matching the entry.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table.
    /// @retval     LA_STATUS_EUNKONWN           Internal error.
    la_status erase(const key_type& key, size_t length);

    /// @brief Bulk entry in the table.
    ///
    /// Preparation for route modification is done in order. Actual hardware update is performed in bulk.
    /// Count of number of successfully programmed routes is returned.
    /// If there is an error in programming routes, count of successful routes would be less than the requested routes to program.
    /// If route modification fails in the preparation step for a specific route, failure is returned for first failed route.
    /// All the route entries prior to the failed one are programmed to the hardware.
    /// If route modification fails in the subsequent step for bulk route programming, success is returned.
    /// All the route entries prior to the failed ones are still programmed to the hardware.
    ///
    /// @param[in]  lpm_bulk_entries             Bulk entries to program.
    /// @param[out] out_count_success            Returns the number of successfully programmed routes.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_EEXIST             Entry already exists in the table.
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table.
    /// @retval     LA_STATUS_EUNKONWN           Internal error.
    la_status bulk_updates(npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, size_t& out_count_success);

    /// @brief Retrive a specific entry from the table, using LPM lookup.
    ///
    /// @param[in]  key                         The key of entry.
    /// @param[out] out_result_entry            Host representation of the entry.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table.
    la_status lookup(const key_type& key, entry_pointer_type& out_result_entry);
    la_status lookup(const key_type& key, entry_wptr_type& out_result_entry);

    /// @brief Retrieve a specific entry from the table, finding an entry with specific key and length.
    ///
    /// @param[in]  key                         The key of entry.
    /// @param[in]  length                      Length of the prefix to use for matching the entry.
    /// @param[out] out_result_entry            Host representation of the entry.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_ENOTFOUND          Entry not in the table.
    la_status find(const key_type& key, size_t length, entry_pointer_type& out_result_entry);
    la_status find(const key_type& key, size_t length, entry_wptr_type& out_result_entry);

    /// @brief Retrieve the number of entries in the table.
    ///
    /// @retval Number of entries.
    size_t size() const;

    /// @brief Retrieve entries from the table.
    ///
    /// @param[out] out_entries     Buffer where the retrieved entries are written to.
    /// @param[in]  max_entries     Max number of elements that can fit in the provided buffer.
    ///
    /// @retval    Number of entries retrieved.
    size_t get_entries(entry_pointer_type* out_entries, size_t max_entries);

    /// @brief Modify the value of a specific entry in the table.
    ///
    /// @param[in]  Key                          The key of the modified entry.
    /// @param[in]  Value                        The new value.
    ///
    /// @retval     LA_STATUS_SUCCESS            Success.
    /// @retval     LA_STATUS_ENOTINITIALIZED    Table object was not initialized.
    /// @retval     LA_STATUS_EUNKONWN           Internal error.
    la_status set_entry_value(const entry_pointer_type entry_ref, const value_type& value);
    la_status set_entry_value(const entry_wptr_type& entry_ref, const value_type& value);

    /// @brief Retrieve maximum table size.
    ///
    /// @retval Maximum number of entries supported by table.
    size_t max_size() const;

    /// @brief Retrieve percentage of the physical usage used by this logical table out of the total physical resource.
    ///
    /// @param[out]  out_physical_usage     Percentage of used physical usage out of the total physical table size used by this
    /// logical table.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTIMPLEMENTED   Function not yet implemented.
    la_status get_physical_usage(size_t& out_physical_usage) const;

    /// @brief Retrieve number of available free entries for the table.
    ///
    /// @param[out]  out_available_entries     Number of available free entries for the table.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success
    /// @retval     LA_STATUS_ENOTIMPLEMENTED   Function not yet implemented.
    la_status get_available_entries(size_t& out_available_entries) const;

    /// @brief Set resource monitor.
    ///
    /// @param[in]  resource_monitor            Resource monitor.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status set_resource_monitor(const resource_monitor_sptr& monitor);

    /// @brief Get resource monitor.
    ///
    /// @param[out] out_resource_monitor        Resource monitor to populate.
    ///
    /// @retval     LA_STATUS_SUCCESS           Success.
    /// @retval     LA_STATUS_EUNKONWN          Internal error.
    la_status get_resource_monitor(resource_monitor_sptr& out_monitor) const;

    /// @brief Retrieve the table's type.
    ///
    /// @retval The table's type
    npl_tables_e get_table_type() const;

    /// @brief Forward iterator for the entries container.
    class iterator
    {
    public:
        typedef npl_lpm_table<_Trait> table_type;
        iterator(typename container_type::iterator it);
        iterator();
        ~iterator();

        iterator& operator=(const iterator& copy_from);

        bool operator==(const iterator& other);
        bool operator!=(const iterator& other);

        iterator& operator++();
        iterator operator++(int unused);

        entry_sptr_type operator*();

    private:
        typename container_type::iterator m_it;
        bool m_is_initialized;
    };

    /// @brief Return an iterator to the beginning of the entries
    iterator begin() const;

    /// @brief Return an iterator to the end of the entries
    iterator end() const;

private:
    template <class Archive>
    void serialize(Archive& ar)
    {
        ar(m_entries);
        ar(m_is_initialized);
        ar(m_bulk_entries);
        ar(m_table_translators);
        ar(m_resource_monitor);
    }
    la_status insert_pre(const key_type& key,
                         const size_t length,
                         const value_type& value,
                         const la_user_data_t& user_data,
                         bool latency_sensitive,
                         entry_sptr_type& out_entry);
    la_status insert_core(const key_type& key, size_t length, const value_type& value, entry_sptr_type& entry);
    void insert_post(entry_sptr_type entry);
    la_status erase_pre(const key_type& key, size_t length, entry_sptr_type& out_entry);
    la_status erase_core(entry_sptr_type table_entry);
    void erase_post(entry_sptr_type table_entry);
    la_status set_entry_value_pre(const key_type& key, size_t length, entry_sptr_type& out_entry);
    la_status set_entry_value_core(const entry_wptr_type& entry_ref, const value_type& value);
    void set_entry_value_post(const entry_wptr_type& entry_ref, const value_type& value);
    void set_entry_user_data(const entry_wptr_type& entry_ref, const la_user_data_t& user_data);
    la_status bulk_updates_pre(const npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, size_t& out_count_success);
    void bulk_updates_post(npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, const size_t count_success);
    void bulk_updates_failed(const npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, const size_t count_success);
    la_status attach_table_info_to_la_status(la_status& status) const;

    container_type m_entries;
    bool m_is_initialized;

    vector_alloc<entry_sptr_type> m_bulk_entries;

    table_translator_sptr_vec_t m_table_translators;

    resource_monitor_sptr m_resource_monitor;
};

// npl_lpm_table_entry implementation
template <class _Trait>
npl_lpm_table<_Trait>::entry::entry(weak_ptr_unsafe<table_type> table,
                                    const key_type& key,
                                    size_t length,
                                    const value_type& value,
                                    la_user_data_t user_data,
                                    bool latency_sensitive)
{
    memset(this, 0, sizeof(*this));
    m_table = table;
    m_key = key;
    m_length = length;
    m_value = value;
    m_user_data = user_data;
    m_latency_sensitive = latency_sensitive;
}

template <class _Trait>
const typename npl_lpm_table<_Trait>::key_type&
npl_lpm_table<_Trait>::entry::key() const
{
    return m_key;
}

template <class _Trait>
size_t
npl_lpm_table<_Trait>::entry::length() const
{
    return m_length;
}

template <class _Trait>
const typename npl_lpm_table<_Trait>::value_type&
npl_lpm_table<_Trait>::entry::value() const
{
    return m_value;
}

template <class _Trait>
la_user_data_t
npl_lpm_table<_Trait>::entry::user_data() const
{
    return m_user_data;
}

template <class _Trait>
bool
npl_lpm_table<_Trait>::entry::latency_sensitive() const
{
    return m_latency_sensitive;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::entry::update(value_type const& value, la_user_data_t user_data)
{
    la_status status = m_table->set_entry_value(this, value);
    return_on_error(status);

    m_user_data = user_data;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
bool
npl_lpm_table<_Trait>::entry_less::operator()(entry_sptr_type lhs, entry_sptr_type rhs) const
{
    key_type lhs_key(lhs->key());
    key_type rhs_key(rhs->key());

    if (lhs->length() != rhs->length()) {
        return lhs->length() < rhs->length();
    }

    _Trait::mask_key(&lhs_key, lhs->length());
    _Trait::mask_key(&rhs_key, rhs->length());

    return memcmp(&lhs_key, &rhs_key, sizeof(key_type)) < 0;
}

// npl_lpm_table implementation
template <class _Trait>
npl_lpm_table<_Trait>::npl_lpm_table() : m_is_initialized(false), m_resource_monitor(nullptr)
{
}

template <class _Trait>
npl_lpm_table<_Trait>::~npl_lpm_table()
{
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::initialize(table_translator_sptr_vec_t& translators)
{
    log_debug(NPLAPI, "%s got %lu translators", _Trait::get_table_name().c_str(), translators.size());

    // For NSIM flow this function gets called twice. once for each of nsim and ra translator_creators
    for (auto trans : translators) {
        m_table_translators.push_back(trans);
    }

    m_is_initialized = true;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::insert_pre(const key_type& key,
                                  const size_t length,
                                  const value_type& value,
                                  const la_user_data_t& user_data,
                                  bool latency_sensitive,
                                  entry_sptr_type& out_entry)
{
    auto new_entry = std::make_shared<entry_type>(this->shared_from_this(), key, length, value, user_data, latency_sensitive);

    // Check if new entry already exists
    auto it = m_entries.find(new_entry);
    if (it != m_entries.end()) {
        out_entry = *it;

        return LA_STATUS_EEXIST;
    }

    out_entry = new_entry;
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::insert_core(const key_type& key, size_t length, const value_type& value, entry_sptr_type& entry)
{
    la_status status;

    // Update hw table
    for (auto translator : m_table_translators) {
        status = translator->insert(key, length, value);
        if (status != LA_STATUS_SUCCESS) {
            entry = nullptr;
            attach_table_info_to_la_status(status);
            return status;
        }
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
void
npl_lpm_table<_Trait>::insert_post(entry_sptr_type entry)
{
    // HW table updated successfully, update the functional model
    m_entries.insert(entry);

    // Update resource monitor
    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::insert(const key_type& key,
                              size_t length,
                              const value_type& value,
                              la_user_data_t user_data,
                              bool latency_sensitive,
                              entry_wptr_type& out_entry)
{
    entry_sptr_type new_entry;
    la_status status;

    log_debug(NPLAPI,
              "%s::insert(key=%s, length=%lu, value=%s, user_data=%llu, latency_sensitive=%d)",
              _Trait::get_table_name().c_str(),
              to_short_string(key).c_str(),
              length,
              to_short_string(value).c_str(),
              user_data,
              latency_sensitive);

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    status = insert_pre(key, length, value, user_data, latency_sensitive, new_entry);
    return_on_error(status);

    status = insert_core(key, length, value, new_entry);
    return_on_error(status);

    insert_post(new_entry);
    out_entry = new_entry;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::insert(const key_type& key,
                              size_t length,
                              const value_type& value,
                              la_user_data_t user_data,
                              bool latency_sensitive,
                              entry_pointer_type& out_entry)
{
    entry_wptr_type entry_wptr;
    auto status = insert(key, length, value, user_data, latency_sensitive, entry_wptr);
    return_on_error(status);
    out_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::erase_pre(const key_type& key, size_t length, entry_sptr_type& out_entry)
{
    auto temp_entry = std::make_shared<entry_type>(
        this->shared_from_this(), key, length, value_type(), 0 /* user_data */, false /* latency_sensitive */);

    // check whether entry exists in table
    auto it = m_entries.find(temp_entry);
    if (it == m_entries.end()) {
        return LA_STATUS_ENOTFOUND;
    }

    // updating HW table
    out_entry = *it;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::erase_core(entry_sptr_type table_entry)
{
    // updating HW table
    for (auto translator : m_table_translators) {
        la_status status = translator->erase(table_entry->m_key, table_entry->m_length, table_entry->m_value);
        attach_table_info_to_la_status(status);
        return_on_error(status);
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
void
npl_lpm_table<_Trait>::erase_post(entry_sptr_type table_entry)
{
    // HW table updated successfully, updating functional model
    auto it = m_entries.find(table_entry);
    if (it == m_entries.end()) {
        return;
    }

    m_entries.erase(it);

    // Update resource monitor
    if (m_resource_monitor != nullptr) {
        size_t current_size = size();
        m_resource_monitor->update_size(current_size);
    }
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::erase(const key_type& key, size_t length)
{
    la_status status;
    entry_sptr_type entry;

    log_debug(NPLAPI, "%s::erase(key=%s, length=%lu)", _Trait::get_table_name().c_str(), to_short_string(key).c_str(), length);

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    status = erase_pre(key, length, entry);
    return_on_error(status);

    status = erase_core(entry);
    return_on_error(status);

    erase_post(entry);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::lookup(const key_type& key, entry_wptr_type& out_result_entry)
{
    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    // Temporary implementation - to be replaced with performant code

    size_t max_length = 0;
    value_type dummy_value;
    bool found = false;

    for (auto entry : m_entries) {
        auto input_entry = std::make_shared<entry_type>(
            this->shared_from_this(), key, entry->length(), dummy_value, 0 /* user_data */, false /* latency_sensitive */);
        npl_lpm_table<_Trait>::entry_less lt;

        if (!lt(entry, input_entry) && !lt(input_entry, entry)) {
            // Keys match
            if (!found || (entry->length() > max_length)) {
                out_result_entry = entry;
                max_length = entry->length();
                found = true;
            }
        }
    }

    return found ? LA_STATUS_SUCCESS : LA_STATUS_ENOTFOUND;
}
template <class _Trait>
la_status
npl_lpm_table<_Trait>::lookup(const key_type& key, entry_pointer_type& out_result_entry)
{
    entry_wptr_type entry_wptr;
    auto status = lookup(key, entry_wptr);
    return_on_error(status);
    out_result_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::find(const key_type& key, size_t length, entry_wptr_type& out_result_entry)
{
    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    auto temp_entry = std::make_shared<entry_type>(
        this->shared_from_this(), key, length, value_type(), 0 /* user_data */, false /* latency_sensitive */);
    auto it = m_entries.find(temp_entry);
    if (it == m_entries.end()) {
        return LA_STATUS_ENOTFOUND;
    }

    out_result_entry = (*it);

    return LA_STATUS_SUCCESS;
}
template <class _Trait>
la_status
npl_lpm_table<_Trait>::find(const key_type& key, size_t length, entry_pointer_type& out_result_entry)
{
    entry_wptr_type entry_wptr;
    auto status = find(key, length, entry_wptr);
    return_on_error(status);
    out_result_entry = entry_wptr.get();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::bulk_updates_pre(const npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, size_t& out_count_success)
{
    size_t i;
    la_status status = LA_STATUS_SUCCESS;

    for (i = 0; i < lpm_bulk_entries.size(); i++) {
        switch (lpm_bulk_entries[i].action) {
        case npl_action_e::ADD:
            status = insert_pre(lpm_bulk_entries[i].key,
                                lpm_bulk_entries[i].length,
                                lpm_bulk_entries[i].value,
                                lpm_bulk_entries[i].user_data,
                                lpm_bulk_entries[i].latency_sensitive,
                                m_bulk_entries[i]);
            break;
        case npl_action_e::DELETE:
            status = erase_pre(lpm_bulk_entries[i].key, lpm_bulk_entries[i].length, m_bulk_entries[i]);
            break;
        case npl_action_e::MODIFY:
            status = set_entry_value_pre(lpm_bulk_entries[i].key, lpm_bulk_entries[i].length, m_bulk_entries[i]);
            break;
        default:
            break;
        }

        if (status != LA_STATUS_SUCCESS) {
            break;
        }
    }

    out_count_success = i;
    return status;
}

template <class _Trait>
void
npl_lpm_table<_Trait>::bulk_updates_post(npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, const size_t count_success)
{
    for (size_t i = 0; i < count_success; i++) {
        switch (lpm_bulk_entries[i].action) {
        case npl_action_e::ADD:
            insert_post(m_bulk_entries[i]);
            break;
        case npl_action_e::DELETE:
            erase_post(m_bulk_entries[i]);
            break;
        case npl_action_e::MODIFY:
            set_entry_value_post(m_bulk_entries[i], lpm_bulk_entries[i].value);
            set_entry_user_data(m_bulk_entries[i], lpm_bulk_entries[i].user_data);
            break;
        default:
            break;
        }
    }
}

template <class _Trait>
void
npl_lpm_table<_Trait>::bulk_updates_failed(const npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, const size_t count_success)
{
    for (size_t i = count_success; i < lpm_bulk_entries.size(); i++) {
        if (lpm_bulk_entries[i].action == npl_action_e::ADD) {
            m_bulk_entries[i] = nullptr;
        }
    }
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::bulk_updates(npl_lpm_bulk_entries_vec<_Trait>& lpm_bulk_entries, size_t& out_count_success)
{
    la_status status = LA_STATUS_SUCCESS;
    size_t count_success = 0;

    log_debug(NPLAPI, "%s::bulk_updates(size=%zu)", _Trait::get_table_name().c_str(), lpm_bulk_entries.size());
    out_count_success = 0;

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    m_bulk_entries.resize(lpm_bulk_entries.size());

    la_status pre_status = bulk_updates_pre(lpm_bulk_entries, count_success);
    if (count_success == 0) {
        return pre_status;
    }

    lpm_bulk_entries.resize(count_success);
    m_bulk_entries.resize(count_success);

    // updating HW table
    for (auto translator : m_table_translators) {
        status = translator->bulk_updates(lpm_bulk_entries, count_success);
        if (status != LA_STATUS_SUCCESS) {
            bulk_updates_post(lpm_bulk_entries, count_success);
            bulk_updates_failed(lpm_bulk_entries, count_success);
            out_count_success = count_success;
            attach_table_info_to_la_status(status);
            return status;
        }
    }

    bulk_updates_post(lpm_bulk_entries, count_success);
    out_count_success = count_success;

    return pre_status;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::attach_table_info_to_la_status(la_status& status) const
{
    if (status == LA_STATUS_ERESOURCE) {
        la_resource_descriptor::type_e resource_type;
        std::shared_ptr<la_status_info_e_resource_table> table_info;
        if (m_resource_monitor != nullptr) {
            resource_type = static_cast<la_resource_descriptor::type_e>(m_resource_monitor->get_resource_type());
            table_info
                = std::make_shared<la_status_info_e_resource_table>(resource_type,                                  // resource enum
                                                                    _Trait::get_table_name(),                       // name
                                                                    m_resource_monitor->get_resource_instance_idx() // instance_id
                                                                    );
        } else {
            resource_type = la_resource_descriptor::type_e::UNSPECIFIED;
            table_info = std::make_shared<la_status_info_e_resource_table>(resource_type,                     // resource enum
                                                                           _Trait::get_table_name(),          // name
                                                                           LA_RESOURCE_INSTANCE_INDEX_INVALID // instance_id
                                                                           );
        }
        la_status set_info_status = status.set_info(table_info);
        return_on_error(set_info_status);
    }
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
size_t
npl_lpm_table<_Trait>::size() const
{
    return m_entries.size();
}

template <class _Trait>
size_t
npl_lpm_table<_Trait>::get_entries(entry_pointer_type* out_entries, size_t max_entries)
{
    size_t i = 0;
    for (auto entry : m_entries) {
        out_entries[i] = entry.get();
        i++;

        if (i >= max_entries) {
            break;
        }
    }

    return i;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::set_entry_value_pre(const key_type& key, size_t length, entry_sptr_type& out_entry)
{
    auto temp_entry = std::make_shared<entry_type>(
        this->shared_from_this(), key, length, value_type(), 0 /* user_data */, false /* latency_sensitive */);

    // check whether entry exists in table
    auto it = m_entries.find(temp_entry);
    if (it == m_entries.end()) {
        return LA_STATUS_ENOTFOUND;
    }

    // updating HW table
    out_entry = *it;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::set_entry_value_core(const entry_wptr_type& entry_ref, const value_type& value)
{
    // updating hw table
    key_type key(entry_ref->key());
    size_t entry_length = entry_ref->length();

    for (auto translator : m_table_translators) {
        la_status status = translator->set_entry_value(key, entry_length, value);
        attach_table_info_to_la_status(status);
        return_on_error(status);
    }

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
void
npl_lpm_table<_Trait>::set_entry_value_post(const entry_wptr_type& entry_ref, const value_type& value)
{
    // hw table updated successfully, updating functional model
    entry_ref->m_value = value;
}

template <class _Trait>
void
npl_lpm_table<_Trait>::set_entry_user_data(const entry_wptr_type& entry_ref, const la_user_data_t& user_data)
{
    // hw table updated successfully, updating functional model
    entry_ref->m_user_data = user_data;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::set_entry_value(const entry_wptr_type& entry_ref, const value_type& value)
{
    log_debug(NPLAPI,
              "%s::set_entry_value(key=%s, length=%lu, value=%s, user_data=%llu)",
              _Trait::get_table_name().c_str(),
              to_short_string(entry_ref->key()).c_str(),
              entry_ref->length(),
              to_short_string(value).c_str(),
              entry_ref->user_data());

    if (!m_is_initialized) {
        return LA_STATUS_ENOTINITIALIZED;
    }

    la_status status = set_entry_value_core(entry_ref, value);
    return_on_error(status);

    set_entry_value_post(entry_ref, value);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::set_entry_value(const entry_pointer_type entry_ref, const value_type& value)
{
    entry_wptr_type entry_wptr = entry_ref->shared_from_this();
    auto status = set_entry_value(entry_wptr, value);
    return_on_error(status);

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
npl_lpm_table<_Trait>::iterator::iterator(typename container_type::iterator it)
{
    m_it = it;
    m_is_initialized = true;
}

template <class _Trait>
npl_lpm_table<_Trait>::iterator::iterator() : m_is_initialized(false)
{
}

template <class _Trait>
npl_lpm_table<_Trait>::iterator::~iterator()
{
}

template <class _Trait>
typename npl_lpm_table<_Trait>::iterator&
npl_lpm_table<_Trait>::iterator::operator=(const iterator& copy_from)
{
    m_it = copy_from.m_it;
    m_is_initialized = copy_from.m_is_initialized;

    return *this;
}

template <class _Trait>
bool
npl_lpm_table<_Trait>::iterator::operator==(const iterator& other)
{
    return (m_is_initialized == other.m_is_initialized) && (m_it == other.m_it);
}

template <class _Trait>
bool
npl_lpm_table<_Trait>::iterator::operator!=(const iterator& other)
{
    return (m_is_initialized != other.m_is_initialized) || (m_it != other.m_it);
}

template <class _Trait>
typename npl_lpm_table<_Trait>::iterator& npl_lpm_table<_Trait>::iterator::operator++()
{
    m_it++;

    return *this;
}

template <class _Trait>
typename npl_lpm_table<_Trait>::iterator npl_lpm_table<_Trait>::iterator::operator++(int unused)
{
    iterator temp(*this);
    m_it++;

    return temp;
}

template <class _Trait>
typename npl_lpm_table<_Trait>::entry_sptr_type npl_lpm_table<_Trait>::iterator::operator*()
{
    if (!m_is_initialized)
        *(volatile char*)0 = 0; // Better crash now than corrupt data later
    typename table_type::entry_sptr_type entry_ptr = *m_it;

    return entry_ptr;
}

template <class _Trait>
typename npl_lpm_table<_Trait>::iterator
npl_lpm_table<_Trait>::begin() const
{
    iterator it(m_entries.begin());

    return it;
}

template <class _Trait>
typename npl_lpm_table<_Trait>::iterator
npl_lpm_table<_Trait>::end() const
{
    iterator it(m_entries.end());

    return it;
}

template <class _Trait>
npl_tables_e
npl_lpm_table<_Trait>::get_table_type() const
{
    return _Trait::table_id;
}

template <class _Trait>
size_t
npl_lpm_table<_Trait>::max_size() const
{
    auto translator = std::min_element(
        m_table_translators.begin(),
        m_table_translators.end(),
        [](table_translator_sptr_t const& lhs, table_translator_sptr_t const& rhs) { return lhs->max_size() < rhs->max_size(); });

    return (*translator)->max_size();
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::get_physical_usage(size_t& out_physical_usage) const
{
    size_t num_of_entries = size();
    auto translator = std::max_element(m_table_translators.begin(),
                                       m_table_translators.end(),
                                       [num_of_entries](table_translator_sptr_t const& lhs, table_translator_sptr_t const& rhs) {
                                           return lhs->get_physical_usage(num_of_entries) < rhs->get_physical_usage(num_of_entries);
                                       });

    out_physical_usage = (*translator)->get_physical_usage(num_of_entries);
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::get_available_entries(size_t& out_available_entries) const
{
    if (m_table_translators.size() == 0) {
        out_available_entries = 0;
        return LA_STATUS_SUCCESS;
    }
    auto translator = std::min_element(m_table_translators.begin(),
                                       m_table_translators.end(),
                                       [](table_translator_sptr_t const& lhs, table_translator_sptr_t const& rhs) {
                                           return lhs->get_available_entries() < rhs->get_available_entries();
                                       });

    out_available_entries = (*translator)->get_available_entries();
    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::set_resource_monitor(const resource_monitor_sptr& monitor)
{
    m_resource_monitor = monitor;

    return LA_STATUS_SUCCESS;
}

template <class _Trait>
la_status
npl_lpm_table<_Trait>::get_resource_monitor(resource_monitor_sptr& out_monitor) const
{
    out_monitor = m_resource_monitor;

    return LA_STATUS_SUCCESS;
}

} // namespace silicon_one

#endif
