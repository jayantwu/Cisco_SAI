$block{nw_reorder_block} = {
  Defines_db => "Z:\\leaba_reg_db_example\\defines.v",
  ProjectName => "Pacific",
  InterruptRegister => { #Structure Type: Reg; Skip Register;
    Name => "InterruptRegister",
    RegMem => "Reg",
    Address => "0",
    Description => "Master Interrupt Register",
    Width => "1",
    Type => "Interrupt",
    MemProtectInterruptSummary => { #Structure Type: RegField;
      Name => "MemProtectInterruptSummary",
      RegMem => "RegField",
      Description => "When this bit is set, MemProtectInterrupt has asserted interrupt",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
    },
  },
  MemProtectInterrupt => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterrupt",
    RegMem => "Reg",
    Address => "1",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "Interrupt",
    Ecc_1bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b error was detected",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    Ecc_2bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b error was detected",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    ParityErrInterrupt => { #Structure Type: RegField;
      Name => "ParityErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, Parity error was detected",
      Width => "1",
      Position => "2",
      Type => "Interrupt",
      UsedBy => "SER",
    },
  },
  MemProtectInterruptTest => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterruptTest",
    RegMem => "Reg",
    Address => "2",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "InterruptTest",
    Ecc_1bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterruptTest",
      RegMem => "RegField",
      Description => "This field masks Ecc_1bErrInterrupt",
      Width => "1",
      Position => "0",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    Ecc_2bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterruptTest",
      RegMem => "RegField",
      Description => "This field masks Ecc_2bErrInterrupt",
      Width => "1",
      Position => "1",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ParityErrInterruptTest => { #Structure Type: RegField;
      Name => "ParityErrInterruptTest",
      RegMem => "RegField",
      Description => "This field masks ParityErrInterrupt",
      Width => "1",
      Position => "2",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "3",
    Description => "ECC 1b Error Interrupt Mask Register",
    Width => "12",
    Type => "Config",
    NwConnectionTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwConnectionTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFifoEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFifoEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchFBM0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchFBM0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchFBM1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchFBM1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchPdMemoryNarrowEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryNarrowEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchPdMemoryWideEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryWideEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    EventChain2ConnectionTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "EventChain2ConnectionTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Connection2EventChainTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Connection2EventChainTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },
  Ecc_2bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "4",
    Description => "ECC 2b Error Interrupt Mask Register",
    Width => "12",
    Type => "Config",
    NwConnectionTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwConnectionTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFifoEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFifoEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchFBM0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchFBM0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchFBM1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchFBM1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchPdMemoryNarrowEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryNarrowEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchPdMemoryWideEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryWideEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    EventChain2ConnectionTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "EventChain2ConnectionTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Connection2EventChainTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Connection2EventChainTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NwExactMatchVerifier3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },

  Ecc_1bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInitiateRegister",
    RegMem => "Reg",
    Address => "30",
    Description => "ECC 1b Error Initiator Register",
    Width => "12",
    Type => "Config",
    NwConnectionTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwConnectionTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFifoEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFifoEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchFBM0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchFBM0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchFBM1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchFBM1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchPdMemoryNarrowEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryNarrowEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchPdMemoryWideEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryWideEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    EventChain2ConnectionTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "EventChain2ConnectionTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Connection2EventChainTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Connection2EventChainTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  Ecc_2bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInitiateRegister",
    RegMem => "Reg",
    Address => "31",
    Description => "ECC 2b Error Initiator Register",
    Width => "12",
    Type => "Config",
    NwConnectionTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwConnectionTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFifoEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFifoEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchFBM0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchFBM0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchFBM1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchFBM1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchPdMemoryNarrowEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryNarrowEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchPdMemoryWideEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryWideEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    EventChain2ConnectionTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "EventChain2ConnectionTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Connection2EventChainTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Connection2EventChainTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NwExactMatchVerifier3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  MemProtectErrStatus => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectErrStatus",
    RegMem => "Reg",
    Address => "33",
    Description => "Memory SER protected error status",
    Width => "12",
    Type => "ReadOnly",
    NwConnectionTableErrInt => { #Structure Type: RegField;
      Name => "NwConnectionTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "0",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFifoErrInt => { #Structure Type: RegField;
      Name => "OutPdFifoErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "1",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchFBM0ErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchFBM0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "2",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchFBM1ErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchFBM1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "3",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchPdMemoryNarrowErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryNarrowErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "4",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchPdMemoryWideErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchPdMemoryWideErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "5",
      Type => "Status",
      UsedBy => "SER",
    },
    EventChain2ConnectionTableErrInt => { #Structure Type: RegField;
      Name => "EventChain2ConnectionTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "6",
      Type => "Status",
      UsedBy => "SER",
    },
    Connection2EventChainTableErrInt => { #Structure Type: RegField;
      Name => "Connection2EventChainTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "7",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchVerifier0ErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "8",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchVerifier1ErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "9",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchVerifier2ErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "10",
      Type => "Status",
      UsedBy => "SER",
    },
    NwExactMatchVerifier3ErrInt => { #Structure Type: RegField;
      Name => "NwExactMatchVerifier3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "11",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SelectedSerErrorInfo => { #Structure Type: Reg; Skip Register;
    Name => "SelectedSerErrorInfo",
    RegMem => "Reg",
    Address => "34",
    Description => "Address and Type of SER error of selected memory",
    Width => "15",
    Type => "ReadOnly",
    MemErrAddr => { #Structure Type: RegField;
      Name => "MemErrAddr",
      RegMem => "RegField",
      Description => "Address of SER error of selected memory",
      Width => "13",
      Position => "12:0",
      Type => "Status",
      UsedBy => "SER",
    },
    MemErrType => { #Structure Type: RegField;
      Name => "MemErrType",
      RegMem => "RegField",
      Description => "0 = ECC 1b, 1 = ECC 2b, 2 = Parity",
      Width => "2",
      Position => "14:13",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SerErrorDebugConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SerErrorDebugConfiguration",
    RegMem => "Reg",
    Address => "35",
    Description => "Address and Type of SER error of selected memory",
    Width => "5",
    Type => "Config",
    ErroneousMemorySelector => { #Structure Type: RegField;
      Name => "ErroneousMemorySelector",
      RegMem => "RegField",
      Description => "Selects which memory error address and error type to set on the status register",
      Width => "4",
      Position => "3:0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
    ResetMemoryErrors => { #Structure Type: RegField;
      Name => "ResetMemoryErrors",
      RegMem => "RegField",
      Description => "When set to 1 - all the memory SER errors are reset. Need to set back to 0 to resume error recording",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrDebug",
    RegMem => "Reg",
    Address => "36",
    Description => "ECC 1b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_1bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_1bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 1b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  Ecc_2bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrDebug",
    RegMem => "Reg",
    Address => "37",
    Description => "ECC 2b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_2bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_2bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 2b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  MbistPassStatus => { #Structure Type: Reg; Skip Register;
    Name => "MbistPassStatus",
    RegMem => "Reg",
    Address => "39",
    Description => "MBIST pass status",
    Width => "64",
    Type => "ReadOnly",
    BistDonePassOut => { #Structure Type: RegField;
      Name => "BistDonePassOut",
      RegMem => "RegField",
      Description => "When this bit is set, MBIST passed",
      Width => "64",
      Position => "63:0",
      Type => "Status",
      UsedBy => "MEM",
    },
  },
  MbistFailStatus => { #Structure Type: Reg; Skip Register;
    Name => "MbistFailStatus",
    RegMem => "Reg",
    Address => "3A",
    Description => "MBIST fail status",
    Width => "64",
    Type => "ReadOnly",
    BistDoneFailOut => { #Structure Type: RegField;
      Name => "BistDoneFailOut",
      RegMem => "RegField",
      Description => "When this bit is set, MBIST failed",
      Width => "64",
      Position => "63:0",
      Type => "Status",
      UsedBy => "MEM",
    },
  },
  TcamBistStatus => { #Structure Type: Reg; Skip Register;
    Name => "TcamBistStatus",
    RegMem => "Reg",
    Address => "3B",
    Description => "TCAM BIST pass fail status",
    Width => "16",
    Type => "ReadOnly",
    TcamBistDonePassOut => { #Structure Type: RegField;
      Name => "TcamBistDonePassOut",
      RegMem => "RegField",
      Description => "When this bit is set, TCAM BIST passed",
      Width => "8",
      Position => "7:0",
      Type => "Status",
      UsedBy => "TCAM",
    },
    TcamBistDoneFailOut => { #Structure Type: RegField;
      Name => "TcamBistDoneFailOut",
      RegMem => "RegField",
      Description => "When this bit is set, TCAM BIST failed",
      Width => "8",
      Position => "15:8",
      Type => "Status",
      UsedBy => "TCAM",
    },
  },
  TcamScanPeriodCfg => { #Structure Type: Reg; Skip Register;
    Name => "TcamScanPeriodCfg",
    RegMem => "Reg",
    Address => "3C",
    Description => "Configures period of TCAM scan for SER, set 0 to disable",
    Width => "32",
    Type => "Config",
    TcamScanPeriod => { #Structure Type: RegField;
      Name => "TcamScanPeriod",
      RegMem => "RegField",
      Description => "",
      Width => "32",
      Position => "31:0",
      Type => "Config",
      UsedBy => "TCAM",
      DefaultValue => "d120000000",
    },
  },

  CounterTimer => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimer",
    RegMem => "Reg",
    Address => "40",
    Description => "Defines Counter Timer parameters",
    Width => "33", # Excel Formula: =calc_reg_width(E8:E9,F9)
    Type => "Config",
    CounterTimerEnable => { #Structure Type: RegField;
      Name => "CounterTimerEnable",
      RegMem => "RegField",
      Description => "If set, Counter Timer will applied for the counters, otherwise the counters are free running",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
    CounterTimerCycle => { #Structure Type: RegField;
      Name => "CounterTimerCycle",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "32",
      Position => "32:1", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h3B9ACA00",
    },
  },
  CounterTimerTriggerReg => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimerTriggerReg",
    RegMem => "Reg",
    Address => "41", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Activates Counter Timer",
    Width => "1", # Excel Formula: =calc_reg_width(E11:E11,F11)
    Type => "External",
    UsedBy => "CIF",
    CounterTimerTrigger => { #Structure Type: RegField;
      Name => "CounterTimerTrigger",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F10,E11,TRUE)
      Type => "External",
      DefaultValue => "b0",
    },
  },
  MemoryAccessTimeout => { #Structure Type: Reg; Skip Register;
    Name => "MemoryAccessTimeout",
    RegMem => "Reg",
    Address => "42", # Excel Formula: =calc_reg_address(C10,A10,G10)
    Description => "Defines parameters for memory access timer expiry",
    Width => "38", # Excel Formula: =calc_reg_width(E13:E15,F15)
    Type => "Config",
    BubbleCounterThr => { #Structure Type: RegField;
      Name => "BubbleCounterThr",
      RegMem => "RegField",
      Description => "When BubbleCounterThr clocks passed from CIF memory access without grant, Bubble Request signal raised towards the block ",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F12,E13,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d256",
    },
    TimeoutCounterThr => { #Structure Type: RegField;
      Name => "TimeoutCounterThr",
      RegMem => "RegField",
      Description => "When TimeoutCounterThr clocks passed from CIF memory access without grant, the access is terminated with error ",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d4096",
    },
    AnsWindowCounterThr => { #Structure Type: RegField;
      Name => "AnsWindowCounterThr",
      RegMem => "RegField",
      Description => "When memory access is terminated because of  TimeoutCounterThr, the CIF waits AnsWindowCounterThr clocks for access termination",
      Width => "6",
      Position => "37:32", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d16",
    },
  },
  BroadcastConfigReg => { #Structure Type: Reg; Skip Register;
    Name => "BroadcastConfigReg",
    RegMem => "Reg",
    Address => "43", # Excel Formula: =calc_reg_address(C12,A12,G12)
    Description => "Config Top broadcast parameters",
    Width => "12", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "Config",
    BroadcastId => { #Structure Type: RegField;
      Name => "BroadcastId",
      RegMem => "RegField",
      Description => "Broadcast ID used by Config Top protocol for broadcast messages",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hFFF",
    },
  },
  MemoryProtBypass => { #Structure Type: Reg; Skip Register;
    Name => "MemoryProtBypass",
    RegMem => "Reg",
    Address => "44", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Description => "Bypass for ECC/Parity, used for debug",
    Width => "3", # Excel Formula: =calc_reg_width(E19:E21,F21)
    Type => "Config",
    DisableEcc => { #Structure Type: RegField;
      Name => "DisableEcc",
      RegMem => "RegField",
      Description => "If set, ECC fix is bypassed and is taken from payload",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtGenBypass => { #Structure Type: RegField;
      Name => "CifProtGenBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity generation is bypassed and is taken from payload for CIF access",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F19,E20)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtFixBypass => { #Structure Type: RegField;
      Name => "CifProtFixBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity fix is bypassed and original ECC/Parity is forwarded towards the CIF",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F20,E21)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  SoftResetConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SoftResetConfiguration",
    RegMem => "Reg",
    Address => "45", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Description => "Soft Reset Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    SoftRstn => { #Structure Type: RegField;
      Name => "SoftRstn",
      RegMem => "RegField",
      Description => "Triggers soft reset signal for the block, active low register",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
  },
  MbistConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "MbistConfiguration",
    RegMem => "Reg",
    Address => "46", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "MBIST Configuration for the block",
    Width => "3", # Excel Formula: =calc_reg_width(E25:E27,F27)
    Type => "Config",
    CoreBistRprMode => { #Structure Type: RegField;
      Name => "CoreBistRprMode",
      RegMem => "RegField",
      Description => "Used by MBIST logic",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CoreBistRun => { #Structure Type: RegField;
      Name => "CoreBistRun",
      RegMem => "RegField",
      Description => "Used by MBIST logic",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CoreBistPtrnFill => { #Structure Type: RegField;
      Name => "CoreBistPtrnFill",
      RegMem => "RegField",
      Description => "Used by MBIST logic",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F26,E27)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  PowerDownConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "PowerDownConfiguration",
    RegMem => "Reg",
    Address => "47", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Description => "Power Down Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E29:E29,F29)
    Type => "Config",
    PowerDown => { #Structure Type: RegField;
      Name => "PowerDown",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F28,E29,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
      Comments => "Default value should always be 0",
    },
  },
  SpareReg => { #Structure Type: Reg; Skip Register;
    Name => "SpareReg",
    RegMem => "Reg",
    Address => "48", # Excel Formula: =calc_reg_address(C28,A28,G28)
    Description => "Power Down Configuration for the block",
    Width => "128", # Excel Formula: =calc_reg_width(E31:E31,F31)
    Type => "Config",
    SpareRegister => { #Structure Type: RegField;
      Name => "SpareRegister",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "128",
      Position => "127:0", # Excel Formula: =calc_position(F30,E31,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hffffffffffffffff",
    },
  },
  PmroCtrl => { #Structure Type: Reg; Skip Register;
    Name => "PmroCtrl",
    RegMem => "Reg",
    Address => "49", # Excel Formula: =calc_reg_address(C30,A30,G30)
    Width => "39", # Excel Formula: =calc_reg_width(E33:E37,F37)
    Type => "Config",
    PmroExecute => { #Structure Type: RegField;
      Name => "PmroExecute",
      RegMem => "RegField",
      Description => "0->1: execute pmro command.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F32,E33,TRUE)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroCmd => { #Structure Type: RegField;
      Name => "PmroCmd",
      RegMem => "RegField",
      Description => "Pmro command to execute:
0: reset.
1: write.
2: read.
3: invalid.",
      Width => "2",
      Position => "2:1", # Excel Formula: =calc_position(F33,E34)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroSbusReset => { #Structure Type: RegField;
      Name => "PmroSbusReset",
      RegMem => "RegField",
      Description => "Reset pmro sbus chain. Need to set to 0 before starting access to pmro registers.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F34,E35)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroAddr => { #Structure Type: RegField;
      Name => "PmroAddr",
      RegMem => "RegField",
      Description => "PMRO register address:
0 - control register, 8b, def: 0x0.
1 - SVT Configuration Register, 16b, def: 0xFFFF.
2 - LVT Configuration Register, 16b, def: 0xFFFF.
3 - ULVT Configuration Register, 16b, def: 0xFFFF.
4 - Interconnect Configuration Register, 16b, def: 0xFFFF.
5 - Reference Clock Counter Register, 24b, def: 0xFFF000.
6 - Oscillator Counter Register, 24b, def: 0x000000.
7 - SBus ID register, read as 0x0B.
Set to '0' on reset command.",
      Width => "3",
      Position => "6:4", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroData => { #Structure Type: RegField;
      Name => "PmroData",
      RegMem => "RegField",
      Description => "PMRO data, set to 0x0 on reset and read command.",
      Width => "32",
      Position => "38:7", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
  },
  PmroStatus => { #Structure Type: Reg; Skip Register;
    Name => "PmroStatus",
    RegMem => "Reg",
    Address => "4A", # Excel Formula: =calc_reg_address(C32,A32,G32)
    Width => "34", # Excel Formula: =calc_reg_width(E39:E41,F41)
    Type => "ReadOnly",
    PmroRdata => { #Structure Type: RegField;
      Name => "PmroRdata",
      RegMem => "RegField",
      Description => "Read data from pmro. Valid when PmroFinish=1 and PmroFailed=0.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F38,E39,TRUE)
      Type => "Capture",
      UsedBy => "pmro",
    },
    PmroFailed => { #Structure Type: RegField;
      Name => "PmroFailed",
      RegMem => "RegField",
      Description => "Pmro command failed. Valid only when PmroFinish=1.",
      Width => "1",
      Position => "32", # Excel Formula: =calc_position(F39,E40)
      Type => "Capture",
      UsedBy => "pmro",
    },
    PmroFinish => { #Structure Type: RegField;
      Name => "PmroFinish",
      RegMem => "RegField",
      Description => "Pmro command finished.",
      Width => "1",
      Position => "33", # Excel Formula: =calc_position(F40,E41)
      Type => "Event",
      UsedBy => "pmro",
    },
  },
  MirrorBusConfReg => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusConfReg",
    RegMem => "Reg",
    Address => "4B", # Excel Formula: =calc_reg_address(C38,A38,G38)
    Description => "aaa",
    Width => "11", # Excel Formula: =calc_reg_width(E43:E44,F44)
    Type => "Config",
    MirrorBusEn => { #Structure Type: RegField;
      Name => "MirrorBusEn",
      RegMem => "RegField",
      Description => "aaa",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F42,E43,TRUE)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
    MirrorBusSel => { #Structure Type: RegField;
      Name => "MirrorBusSel",
      RegMem => "RegField",
      Description => "aaa",
      Width => "10",
      Position => "10:1", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
  },
  MirrorBusStatus => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusStatus",
    RegMem => "Reg",
    Address => "4C", # Excel Formula: =calc_reg_address(C42,A42,G42)
    Description => "aaa",
    Width => "32", # Excel Formula: =calc_reg_width(E46:E46,F46)
    Type => "ReadOnly",
    MirrorBus => { #Structure Type: RegField;
      Name => "MirrorBus",
      RegMem => "RegField",
      Description => "aaa",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F45,E46,TRUE)
      Type => "Status",
      UsedBy => "BLOCK",
    },
  },
  DeviceTimeOffsetCfg => { #Structure Type: Reg; Skip Register;
    Name => "DeviceTimeOffsetCfg",
    RegMem => "Reg",
    Address => "4D", # Excel Formula: =calc_reg_address(C45,A45,G45)
    Description => "Define time offset configuration",
    Width => "10", # Excel Formula: =calc_reg_width(E48:E48,F48)
    Type => "Config",
    DeviceTimeOffset => { #Structure Type: RegField;
      Name => "DeviceTimeOffset",
      RegMem => "RegField",
      Description => "Define time offset",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F47,E48,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h0",
    },
  },
  BlockGeneralConfigurations => { #Structure Type: Reg;
    Name => "BlockGeneralConfigurations",
    RegMem => "Reg",
    Address => "100",
    Width => "33", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    BlockNumOfReorderBlocks => { #Structure Type: RegField;
      Name => "BlockNumOfReorderBlocks",
      RegMem => "RegField",
      Description => "Indicates how many reorder blocks are connected in the chain.
In SLB and TS PLB - set to 1.
In SN PLB - set to 6.",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h6",
      Comments => "Constant",
    },
    MySliceNumber => { #Structure Type: RegField;
      Name => "MySliceNumber",
      RegMem => "RegField",
      Description => "Indicates the slice number of the block",
      Width => "3",
      Position => "5:3", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Change to constant number piushed from the top",
    },
    BlockReorderBlockNumber => { #Structure Type: RegField;
      Name => "BlockReorderBlockNumber",
      RegMem => "RegField",
      Description => "The reorder block number inside the chain",
      Width => "3",
      Position => "8:6", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Check if can change to value pushed from the top",
    },
    SliceMode => { #Structure Type: RegField;
      Name => "SliceMode",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice with SLB
5  // TOR mode network slice with PLB --> not supported
6  // TOR mode fabric slice with SLB
7  // TOR mode fabric slice with PLB --> not supported
8  // FE mode with TS
9  // FE mode with SN
10 // DRAM slice ",
      Width => "4",
      Position => "12:9", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
    },
    BlockPpReorderMinConnectionNumber => { #Structure Type: RegField;
      Name => "BlockPpReorderMinConnectionNumber",
      RegMem => "RegField",
      Description => "The minimal connection number associated with PP reorder.
Used for aging and init.
This field was used for tuning parameters during the design phase. 
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d4096",
      Comments => "Constant",
    },
    ResetDoneFifoFullThr => { #Structure Type: RegField;
      Name => "ResetDoneFifoFullThr",
      RegMem => "RegField",
      Description => "When the number of reuse indication that hadn't finished the reset process crosses this threshold - no more reuse will be processed.
Relevant in block 5 only.",
      Width => "5",
      Position => "30:26", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d14",
      Comments => "ConfigDB",
    },
    PacketLossDetectionUsingSkewEnable => { #Structure Type: RegField;
      Name => "PacketLossDetectionUsingSkewEnable",
      RegMem => "RegField",
      Description => "0 - Disable - the packet loss detection using the configurable skew is disabled.
1 - Enable - the packet loss detection using the configurable skew is enabled.",
      Width => "1",
      Position => "31", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d1",
    },
    DisableAssuredReadInSlb => { #Structure Type: RegField;
      Name => "DisableAssuredReadInSlb",
      RegMem => "RegField",
      Description => "If set to 1 - assured read will be disabled for SLB connections.",
      Width => "1",
      Position => "32", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
    },
  },
  BlockEventsRegister => { #Structure Type: Reg;
    Name => "BlockEventsRegister",
    RegMem => "Reg",
    Address => "101", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Width => "4", # Excel Formula: =calc_reg_width(E17:E20,F20)
    Type => "ReadOnly",
    ConnectionReachedMaxSize => { #Structure Type: RegField;
      Name => "ConnectionReachedMaxSize",
      RegMem => "RegField",
      Description => "The connection size in the connection table reached the maximal supported size (all bits are 1).
This should not occur since it will cause a wraparound of the connection size.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Event",
      UsedBy => "DSN",
    },
    WriteFailed => { #Structure Type: RegField;
      Name => "WriteFailed",
      RegMem => "RegField",
      Description => "The block received write failed from the exact match. Should not occur since in PP reorder and SLB the pipe will not insert new packets when the CAM is almost full thus ensuring there will be no write fail.",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F17,E18)
      Type => "Event",
      UsedBy => "DSN",
    },
    AssuredReadBufferManagerEmpty => { #Structure Type: RegField;
      Name => "AssuredReadBufferManagerEmpty",
      RegMem => "RegField",
      Description => "Indicates that the assured read buffer manager was empty.",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F18,E19)
      Type => "Event",
      UsedBy => "DSN",
    },
    EventChainFull => { #Structure Type: RegField;
      Name => "EventChainFull",
      RegMem => "RegField",
      Description => "Indicates that the reorder block sent the maximal allowed number of events to the pipe so it must not send more events.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F19,E20)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  BlockResetConfiguration => { #Structure Type: Reg;
    Name => "BlockResetConfiguration",
    RegMem => "Reg",
    Address => "102", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Width => "13", # Excel Formula: =calc_reg_width(E22:E23,F23)
    Type => "Config",
    BlockFullScanResetEnable => { #Structure Type: RegField;
      Name => "BlockFullScanResetEnable",
      RegMem => "RegField",
      Description => "When set to 1 the reset process continues regardless of the size of the connection in the blocks",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F21,E22,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    BlockResetDoneValue => { #Structure Type: RegField;
      Name => "BlockResetDoneValue",
      RegMem => "RegField",
      Description => "The value of the reset done vector in the RD that indcates that all blocks in the chain rechead reset done",
      Width => "12",
      Position => "12:1", # Excel Formula: =calc_position(F22,E23)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1",
      Comments => "Constant",
    },
  },
  BlockAssuredReadConfiguration => { #Structure Type: Reg;
    Name => "BlockAssuredReadConfiguration",
    RegMem => "Reg",
    Address => "103", # Excel Formula: =calc_reg_address(C21,A21,G21)
    Width => "25", # Excel Formula: =calc_reg_width(E25:E27,F27)
    Type => "Config",
    BlockAssuredReadCounterThreshold => { #Structure Type: RegField;
      Name => "BlockAssuredReadCounterThreshold",
      RegMem => "RegField",
      Description => "Indicates the number of consecutive read look aheads that should indicate that assured read can be performed.
Should be set to: 
(EMDB latency + 1)/ReorderBlocksInChain + 3
Note - should be an odd number so should be rounded up to the closest odd number
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d19",
      Comments => "Constant",
    },
    BlockAssuredReadTrigValue => { #Structure Type: RegField;
      Name => "BlockAssuredReadTrigValue",
      RegMem => "RegField",
      Description => "The bit vector in the RD that indicates that all blocks in the chain reached.
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "12",
      Position => "16:5", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1",
      Comments => "Constant",
    },
    BlockAssuredReadSeqNumAddition => { #Structure Type: RegField;
      Name => "BlockAssuredReadSeqNumAddition",
      RegMem => "RegField",
      Description => "Should be configured to:
Block[n]AssuredReadCounterThreshold * ReorderBlockInChain
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "8",
      Position => "24:17", # Excel Formula: =calc_position(F26,E27)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d19",
      Comments => "Constant",
    },
  },
  BlockInitConfiguration => { #Structure Type: Reg;
    Name => "BlockInitConfiguration",
    RegMem => "Reg",
    Address => "104", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Width => "19", # Excel Formula: =calc_reg_width(E29:E30,F30)
    Type => "Config",
    BlockNumOfPktsRequiredForInit => { #Structure Type: RegField;
      Name => "BlockNumOfPktsRequiredForInit",
      RegMem => "RegField",
      Description => "The number of packets that are required to determine the connections minimal sequence number in initialization phase.
Relevant for SN PLB only.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F28,E29,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h8",
      Comments => "Default",
    },
    BlockTimeIntervalRequiredForInit => { #Structure Type: RegField;
      Name => "BlockTimeIntervalRequiredForInit",
      RegMem => "RegField",
      Description => "The time interval that is required to determine the connections minimal sequence number in initialization phase.
Relevant for SN PLB only.",
      Width => "7",
      Position => "18:12", # Excel Formula: =calc_position(F29,E30)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h3F",
      Comments => "Default",
    },
  },
  BlockSkewConfigurations => { #Structure Type: Reg;
    Name => "BlockSkewConfigurations",
    RegMem => "Reg",
    Address => "105", # Excel Formula: =calc_reg_address(C28,A28,G28)
    Width => "25", # Excel Formula: =calc_reg_width(E32:E35,F35)
    Type => "Config",
    BlockTValue => { #Structure Type: RegField;
      Name => "BlockTValue",
      RegMem => "RegField",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F31,E32,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h3F",
      Comments => "Default",
    },
    BlockWValue => { #Structure Type: RegField;
      Name => "BlockWValue",
      RegMem => "RegField",
      Width => "7",
      Position => "13:7", # Excel Formula: =calc_position(F32,E33)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h3F",
      Comments => "Default",
    },
    BlockLowerSkewCounterThreshold => { #Structure Type: RegField;
      Name => "BlockLowerSkewCounterThreshold",
      RegMem => "RegField",
      Width => "4",
      Position => "17:14", # Excel Formula: =calc_position(F33,E34)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasurementAddition => { #Structure Type: RegField;
      Name => "BlockSkewMeasurementAddition",
      RegMem => "RegField",
      Description => "Defines the skew of the block. In 512nsec resolution.",
      Width => "7",
      Position => "24:18", # Excel Formula: =calc_position(F34,E35)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h3F",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf0 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 0; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "106", # Excel Formula: =calc_reg_address(C31,A31,G31)
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "0",
    BlockSkewMeasConnection0Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection0UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf1 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 1; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "107",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "1",
    BlockSkewMeasConnection1Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection1UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf2 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 2; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "108",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "2",
    BlockSkewMeasConnection2Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection2UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf3 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 3; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "109",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "3",
    BlockSkewMeasConnection3Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection3UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf4 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 4; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "10A",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "4",
    BlockSkewMeasConnection4Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 4; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection4UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 4; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf5 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 5; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "10B",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "5",
    BlockSkewMeasConnection5Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 5; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection5UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 5; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf6 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 6; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "10C",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "6",
    BlockSkewMeasConnection6Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 6; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection6UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 6; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementConf7 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 7; ArrayLocationInName: 25;
    Name => "BlockSkewMeasurementConf[8]",
    RegMem => "Reg",
    Address => "10D",
    Width => "26", # Excel Formula: =calc_reg_width(E37:E38,F38)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "7",
    BlockSkewMeasConnection7Number => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 7; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]Number",
      RegMem => "RegField",
      Description => "Holds 8 sets of connections and masks that the skew measurement should measure it's skew.
A packet participates in the calculation only if it's connection number after the un-mask selection equals the configured connection number",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Default",
    },
    BlockSkewMeasConnection7UnMask => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 7; ArrayLocationInName: 24;
      Name => "BlockSkewMeasConnection[n]UnMask",
      RegMem => "RegField",
      Width => "13",
      Position => "25:13", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1fff",
      Comments => "Default",
    },
  },
  BlockSkewMeasurementResults0 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 0; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "10E", # Excel Formula: =calc_reg_address(C36,A36,G36)
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "0",
    BlockSkewMeasCon0MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults1 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 1; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "10F",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "1",
    BlockSkewMeasCon1MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults2 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 2; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "110",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "2",
    BlockSkewMeasCon2MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 2; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults3 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 3; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "111",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "3",
    BlockSkewMeasCon3MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 3; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults4 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 4; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "112",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "4",
    BlockSkewMeasCon4MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 4; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults5 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 5; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "113",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "5",
    BlockSkewMeasCon5MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 5; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults6 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 6; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "114",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "6",
    BlockSkewMeasCon6MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 6; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSkewMeasurementResults7 => { #Structure Type: Reg; ArrayLength: 8; ArrayIndex: 7; ArrayLocationInName: 28;
    Name => "BlockSkewMeasurementResults[8]",
    RegMem => "Reg",
    Address => "115",
    Width => "7", # Excel Formula: =calc_reg_width(E40:E40,F40)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "8",
    ArrayIndex => "7",
    BlockSkewMeasCon7MaxSkew => { #Structure Type: RegField; ArrayLength: 8; ArrayIndex: 7; ArrayLocationInName: 17;
      Name => "BlockSkewMeasCon[n]MaxSkew",
      RegMem => "RegField",
      Description => "Holds the maximal skew measured for the connection",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "MaxWmk",
      UsedBy => "DSN",
    },
  },
  BlockSlbConfigurations => { #Structure Type: Reg;
    Name => "BlockSlbConfigurations",
    RegMem => "Reg",
    Address => "116", # Excel Formula: =calc_reg_address(C39,A39,G39)
    Width => "37", # Excel Formula: =calc_reg_width(E42:E46,F46)
    Type => "Config",
    ReorderModeSlb => { #Structure Type: RegField;
      Name => "ReorderModeSlb",
      RegMem => "RegField",
      Description => "Indicates if the reorder mode is SLB",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F41,E42,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
    },
    SlbResetDelay => { #Structure Type: RegField;
      Name => "SlbResetDelay",
      RegMem => "RegField",
      Description => "Defines the time to wait after notifiying the SNA to reset a connection and before starting to reset the connection inside the reorder block.
This time should be sufficient for the SNA to stop sending packets to the connection and the delay of the packets to the reorder block.
Resolution is in 512cc. ",
      Width => "6",
      Position => "6:1", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d16",
      Comments => "Constant",
    },
    SlbMaxEventsThr => { #Structure Type: RegField;
      Name => "SlbMaxEventsThr",
      RegMem => "RegField",
      Description => "Defines the maximal number of events that the reorder block can send to the event chain.
Calc for the threshold is:
The incoming event FIFO can consist up to 100 events
The AlgOutEventFifo can consist 30 events when it halts the pipe
The event chain out event FIFO can contain 40 events when it halts the pipe
These FIFOs exist in the 6 nw reorder blocks thus each block should be limited for having up to 170 events that it created alive together.
This field was used for tuning parameters during the design phase. 
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "8",
      Position => "14:7", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d140",
      Comments => "Constant",
    },
    SlbEventPipeOutFifoFullThr => { #Structure Type: RegField;
      Name => "SlbEventPipeOutFifoFullThr",
      RegMem => "RegField",
      Description => "Defines the fill level of the out event FIFO that will halt the event pipe from inserting new events for processing.
This field was used for tuning parameters during the design phase. 
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "10",
      Position => "24:15", # Excel Formula: =calc_position(F44,E45)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d40",
      Comments => "Constant",
    },
    SlbMaxConnectionNumber => { #Structure Type: RegField;
      Name => "SlbMaxConnectionNumber",
      RegMem => "RegField",
      Description => "Defines the maximal connection number that is defines as SLB.
This field was used for tuning parameters during the design phase. 
The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "12",
      Position => "36:25", # Excel Formula: =calc_position(F45,E46)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hfff",
      Comments => "Constant",
    },
  },
  BlockMaxCon0 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 12;
    Name => "BlockMaxCon[4]",
    RegMem => "Reg",
    Address => "117", # Excel Formula: =calc_reg_address(C41,A41,G41)
    Width => "28", # Excel Formula: =calc_reg_width(E48:E49,F49)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "4",
    ArrayIndex => "0",
    BlockMaxConnection0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 19;
      Name => "BlockMaxConnection[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F47,E48,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    BlockMaxSize0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "BlockMaxSize[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "15",
      Position => "27:13", # Excel Formula: =calc_position(F48,E49)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  BlockMaxCon1 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 12;
    Name => "BlockMaxCon[4]",
    RegMem => "Reg",
    Address => "118",
    Width => "28", # Excel Formula: =calc_reg_width(E48:E49,F49)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "4",
    ArrayIndex => "1",
    BlockMaxConnection1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 19;
      Name => "BlockMaxConnection[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F47,E48,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    BlockMaxSize1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "BlockMaxSize[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "15",
      Position => "27:13", # Excel Formula: =calc_position(F48,E49)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  BlockMaxCon2 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 12;
    Name => "BlockMaxCon[4]",
    RegMem => "Reg",
    Address => "119",
    Width => "28", # Excel Formula: =calc_reg_width(E48:E49,F49)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "4",
    ArrayIndex => "2",
    BlockMaxConnection2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 19;
      Name => "BlockMaxConnection[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F47,E48,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    BlockMaxSize2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "BlockMaxSize[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "15",
      Position => "27:13", # Excel Formula: =calc_position(F48,E49)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  BlockMaxCon3 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 12;
    Name => "BlockMaxCon[4]",
    RegMem => "Reg",
    Address => "11A",
    Width => "28", # Excel Formula: =calc_reg_width(E48:E49,F49)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "4",
    ArrayIndex => "3",
    BlockMaxConnection3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 19;
      Name => "BlockMaxConnection[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F47,E48,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    BlockMaxSize3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "BlockMaxSize[n]",
      RegMem => "RegField",
      Description => "Manages 4 sets of maximal sized connections",
      Width => "15",
      Position => "27:13", # Excel Formula: =calc_position(F48,E49)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  BlockDroppedPktConfiguration => { #Structure Type: Reg;
    Name => "BlockDroppedPktConfiguration",
    RegMem => "Reg",
    Address => "11B", # Excel Formula: =calc_reg_address(C47,A47,G47)
    Width => "19", # Excel Formula: =calc_reg_width(E51:E55,F55)
    Type => "Config",
    BlockDropPacketsDuringReset => { #Structure Type: RegField;
      Name => "BlockDropPacketsDuringReset",
      RegMem => "RegField",
      Description => "Indicates wether the reorder should drop the incoming packets when connection is in reset or should send it out which will cause OOO.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F50,E51,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1",
      Comments => "Constant",
    },
    BlockDropOldPackets => { #Structure Type: RegField;
      Name => "BlockDropOldPackets",
      RegMem => "RegField",
      Description => "Indicates wether the reorder should drop packets with sequence number below the expected sequence number or should allow a little out of order.
Relevant also for init state when the minimal sequnce number was determined and a packet with a smaller sequence numer arrives.
When connection is SLB - it means if to drop packets of the previous segment.",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1",
      Comments => "Constant",
    },
    BlockDropPacketsNotInRange => { #Structure Type: RegField;
      Name => "BlockDropPacketsNotInRange",
      RegMem => "RegField",
      Description => "Indicates wether the reorder should drop packets with sequence number that is not in the range of the current sequence number range.
Relevant also for init state when the init range was determined and a packet from a different range arrives.",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1",
      Comments => "Constant",
    },
    BlockDroppedPacketsWeight => { #Structure Type: RegField;
      Name => "BlockDroppedPacketsWeight",
      RegMem => "RegField",
      Description => "The weight that should be given to dropped packets when managing the dropped packets counter. When the counter reaches a threshold - the connection will be reset.",
      Width => "8",
      Position => "10:3", # Excel Formula: =calc_position(F53,E54)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h3",
      Comments => "Default",
    },
    BlockMaxDroppedPacketsThreshold => { #Structure Type: RegField;
      Name => "BlockMaxDroppedPacketsThreshold",
      RegMem => "RegField",
      Description => "When the drop counter reaches this threshold - the connection will be reset.",
      Width => "8",
      Position => "18:11", # Excel Formula: =calc_position(F54,E55)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFF",
      Comments => "Default",
    },
  },
  BlockStatusReg => { #Structure Type: Reg;
    Name => "BlockStatusReg",
    RegMem => "Reg",
    Address => "11C", # Excel Formula: =calc_reg_address(C50,A50,G50)
    Width => "28", # Excel Formula: =calc_reg_width(E57:E58,F58)
    Type => "ReadOnly",
    AdditionalInfo => "MirrorReadAccess",
    MaxReorderConnectionSize => { #Structure Type: RegField;
      Name => "MaxReorderConnectionSize",
      RegMem => "RegField",
      Description => "Holds the size of the largest reorder connection that existed since the last time the CPU read this status register.",
      Width => "15",
      Position => "14:0", # Excel Formula: =calc_position(F56,E57,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    MaxReorderConnection => { #Structure Type: RegField;
      Name => "MaxReorderConnection",
      RegMem => "RegField",
      Description => "Holds the largest reorder connection number",
      Width => "13",
      Position => "27:15", # Excel Formula: =calc_position(F57,E58)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  BlockCaptureReg => { #Structure Type: Reg;
    Name => "BlockCaptureReg",
    RegMem => "Reg",
    Address => "11D", # Excel Formula: =calc_reg_address(C56,A56,G56)
    Width => "13", # Excel Formula: =calc_reg_width(E60:E60,F60)
    Type => "ReadOnly",
    SlbConnectionWithError => { #Structure Type: RegField;
      Name => "SlbConnectionWithError",
      RegMem => "RegField",
      Description => "Captures the last connection that expirienced SLB error",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F59,E60,TRUE)
      Type => "Capture",
      UsedBy => "DSN",
    },
  },
  EmFbmConfigReg0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 15;
    Name => "EmFbmConfigReg[2]",
    RegMem => "Reg",
    Address => "11E", # Excel Formula: =calc_reg_address(C59,A59,G59)
    Width => "97", # Excel Formula: =calc_reg_width(E62:E68,F68)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "2",
    ArrayIndex => "0",
    Em0FbmWorkingMode => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmWorkingMode",
      RegMem => "RegField",
      Description => "0 - The design is initializing the FBM memory to use all the buffers
1 - The design will not initialize the FBM. Should be init by SW to the relevant buffer. 
Should be set to 1 in FE and FB slice. 
The FBM should be init by SW to have buffer 0 - 255 valid and all others not valid.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F61,E62,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Em0FbmTotalFreeBuffers => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmTotalFreeBuffers",
      RegMem => "RegField",
      Description => "The total number of free buffers in the FBM.
In FE/FB slices should be configured to 256 buffers and in all other modes to 3K",
      Width => "12",
      Position => "12:1", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d3072",
      Comments => "Constant",
    },
    Em0FbmNotEmptyEntry => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmNotEmptyEntry",
      RegMem => "RegField",
      Description => "A bitmap in the size of the FBM entries. Each bit indicates if there are valid buffers in the corresponding entry.
In FE/FB slice - should be configured to 0xF
In other modes - should be configured to all 1's",
      Width => "48",
      Position => "60:13", # Excel Formula: =calc_position(F63,E64)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFFFFFFFFFFF",
      Comments => "Constant",
    },
    Em0FbmInit => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmInit",
      RegMem => "RegField",
      Description => "If set - initializes FBM logic",
      Width => "1",
      Position => "61", # Excel Formula: =calc_position(F64,E65)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Em0FbmAlmostEmptyThr => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmAlmostEmptyThr",
      RegMem => "RegField",
      Description => "Used to indicate that the FBM is almost empty",
      Width => "12",
      Position => "73:62", # Excel Formula: =calc_position(F65,E66)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d8",
      Comments => "Constant",
    },
    Em0FbmDrainModeThr => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmDrainModeThr",
      RegMem => "RegField",
      Description => "Used to indicate that the FBM is in high utilization thus the reorder will try to drain it by declaring each packet that is not found in the data base as lost packet.
This scenaio should not be reached if the PP skew is as expected.
We are trying to avoid write fails due to no free buffers in the FBM because skipping lost packet is a long process (reuqired skew or PD counter per connection to cross threshold).
The assumption is that write fails due to full EM is very rare.",
      Width => "13",
      Position => "86:74", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d50",
      Comments => "Constant",
    },
    Em0FbmRateLimitThr => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "Em[n]FbmRateLimitThr",
      RegMem => "RegField",
      Description => "Used to indicate that the FBM is in high utilization thus the reorder will reduce the input PD rate to enable the block to empty its database.
This threshold is compared with the number of free buffers in the FBM",
      Width => "10",
      Position => "96:87", # Excel Formula: =calc_position(F67,E68)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d100",
      Comments => "Constant",
    },
  },
  EmFbmConfigReg1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 15;
    Name => "EmFbmConfigReg[2]",
    RegMem => "Reg",
    Address => "11F",
    Width => "97", # Excel Formula: =calc_reg_width(E62:E68,F68)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "2",
    ArrayIndex => "1",
    Em1FbmWorkingMode => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmWorkingMode",
      RegMem => "RegField",
      Description => "0 - The design is initializing the FBM memory to use all the buffers
1 - The design will not initialize the FBM. Should be init by SW to the relevant buffer. 
Should be set to 1 in FE and FB slice. 
The FBM should be init by SW to have buffer 0 - 255 valid and all others not valid.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F61,E62,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Em1FbmTotalFreeBuffers => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmTotalFreeBuffers",
      RegMem => "RegField",
      Description => "The total number of free buffers in the FBM.
In FE/FB slices should be configured to 256 buffers and in all other modes to 3K",
      Width => "12",
      Position => "12:1", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d3072",
      Comments => "Constant",
    },
    Em1FbmNotEmptyEntry => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmNotEmptyEntry",
      RegMem => "RegField",
      Description => "A bitmap in the size of the FBM entries. Each bit indicates if there are valid buffers in the corresponding entry.
In FE/FB slice - should be configured to 0xF
In other modes - should be configured to all 1's",
      Width => "48",
      Position => "60:13", # Excel Formula: =calc_position(F63,E64)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFFFFFFFFFFF",
      Comments => "Constant",
    },
    Em1FbmInit => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmInit",
      RegMem => "RegField",
      Description => "If set - initializes FBM logic",
      Width => "1",
      Position => "61", # Excel Formula: =calc_position(F64,E65)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Em1FbmAlmostEmptyThr => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmAlmostEmptyThr",
      RegMem => "RegField",
      Description => "Used to indicate that the FBM is almost empty",
      Width => "12",
      Position => "73:62", # Excel Formula: =calc_position(F65,E66)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d8",
      Comments => "Constant",
    },
    Em1FbmDrainModeThr => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmDrainModeThr",
      RegMem => "RegField",
      Description => "Used to indicate that the FBM is in high utilization thus the reorder will try to drain it by declaring each packet that is not found in the data base as lost packet.
This scenaio should not be reached if the PP skew is as expected.
We are trying to avoid write fails due to no free buffers in the FBM because skipping lost packet is a long process (reuqired skew or PD counter per connection to cross threshold).
The assumption is that write fails due to full EM is very rare.",
      Width => "13",
      Position => "86:74", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d50",
      Comments => "Constant",
    },
    Em1FbmRateLimitThr => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "Em[n]FbmRateLimitThr",
      RegMem => "RegField",
      Description => "Used to indicate that the FBM is in high utilization thus the reorder will reduce the input PD rate to enable the block to empty its database.
This threshold is compared with the number of free buffers in the FBM",
      Width => "10",
      Position => "96:87", # Excel Formula: =calc_position(F67,E68)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d100",
      Comments => "Constant",
    },
  },
  ReorderBlockDebugCounters => { #Structure Type: Reg;
    Name => "ReorderBlockDebugCounters",
    RegMem => "Reg",
    Address => "120", # Excel Formula: =calc_reg_address(C61,A61,G61)
    Width => "106", # Excel Formula: =calc_reg_width(E70:E76,F76)
    Type => "ReadOnly",
    DuplicatedEntryCounter => { #Structure Type: RegField;
      Name => "DuplicatedEntryCounter",
      RegMem => "RegField",
      Description => "Holds the number of duplicated entries found in the reorder block.",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F69,E70,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DropCounterSeqNumBelowExp => { #Structure Type: RegField;
      Name => "DropCounterSeqNumBelowExp",
      RegMem => "RegField",
      Description => "Holds the number of PDs dropped due the packet sequence number being below the expected sequence number",
      Width => "16",
      Position => "25:10", # Excel Formula: =calc_position(F70,E71)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DropCounterSeqNumNotInRange => { #Structure Type: RegField;
      Name => "DropCounterSeqNumNotInRange",
      RegMem => "RegField",
      Description => "Holds the number of PDs dropped due the packet sequence number not being in the range of the current sequence number",
      Width => "16",
      Position => "41:26", # Excel Formula: =calc_position(F71,E72)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DropCounterNewPktDuringReset => { #Structure Type: RegField;
      Name => "DropCounterNewPktDuringReset",
      RegMem => "RegField",
      Description => "Holds the number of new packets dropped when the connection was in reset",
      Width => "16",
      Position => "57:42", # Excel Formula: =calc_position(F72,E73)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DropCounterSlbPktFromPrevSegment => { #Structure Type: RegField;
      Name => "DropCounterSlbPktFromPrevSegment",
      RegMem => "RegField",
      Description => "Holds the number of new packets dropped since it's SSN was one less than the current SSN",
      Width => "16",
      Position => "73:58", # Excel Formula: =calc_position(F73,E74)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DropCounterPktFromEmdbDuringReset => { #Structure Type: RegField;
      Name => "DropCounterPktFromEmdbDuringReset",
      RegMem => "RegField",
      Description => "Holds the number of packets read & dropped from the EMDB during reset.",
      Width => "16",
      Position => "89:74", # Excel Formula: =calc_position(F74,E75)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DropNewPacketDueToFbmAlmostEmpty => { #Structure Type: RegField;
      Name => "DropNewPacketDueToFbmAlmostEmpty",
      RegMem => "RegField",
      Description => "Holds the number of packets that were dropped because the EMPD FBM was almost empty.",
      Width => "16",
      Position => "105:90", # Excel Formula: =calc_position(F75,E76)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReorderBlockSLBCounters => { #Structure Type: Reg;
    Name => "ReorderBlockSLBCounters",
    RegMem => "Reg",
    Address => "121", # Excel Formula: =calc_reg_address(C69,A69,G69)
    Width => "64", # Excel Formula: =calc_reg_width(E78:E81,F81)
    Type => "ReadOnly",
    UnexpectedPrevSegmentError => { #Structure Type: RegField;
      Name => "UnexpectedPrevSegmentError",
      RegMem => "RegField",
      Description => "Got SOS of segment X while the current SSN is X+1",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    MoreThanOneOwnerError => { #Structure Type: RegField;
      Name => "MoreThanOneOwnerError",
      RegMem => "RegField",
      Description => "More than one block received packets from the same segment",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F78,E79)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    CompleteSegementLossError => { #Structure Type: RegField;
      Name => "CompleteSegementLossError",
      RegMem => "RegField",
      Description => "A complete segment was lost ",
      Width => "16",
      Position => "47:32", # Excel Formula: =calc_position(F79,E80)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    ReuseSequenceError => { #Structure Type: RegField;
      Name => "ReuseSequenceError",
      RegMem => "RegField",
      Description => "More than 2 segments are alive during re-use",
      Width => "16",
      Position => "63:48", # Excel Formula: =calc_position(F80,E81)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwConnectionTable => { #Structure Type: Mem;
    Name => "NwConnectionTable",
    RegMem => "Mem",
    Address => "100000",
    Width => "120", # Excel Formula: =calc_mem_width(E83:E83,M82,F83,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "Entries 0 - 4K-1:,Data[111:0] = 0,Other Entries:,Data[87:68] = EntryNum,Data[98] = 1",
    MemEntries => "4256",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Skew table and connection table should have the same read latency",
    MemLogicalWidth => "112",
    NwConnectionTableData => { #Structure Type: MemField;
      Name => "NwConnectionTableData",
      RegMem => "MemField",
      Width => "112",
      Position => "111:0", # Excel Formula: =calc_position(F82,E83,TRUE)
    },
  },
  OutPdFifo => { #Structure Type: Mem;
    Name => "OutPdFifo",
    RegMem => "Mem",
    Address => "200000", # Excel Formula: =calc_mem_address(C82,A82,G84,L84)
    Width => "166", # Excel Formula: =calc_mem_width(E85:E85,M84,F85,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "N/A",
    MemEntries => "64",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    MemLogicalWidth => "157",
    OutPdFifoData => { #Structure Type: MemField;
      Name => "OutPdFifoData",
      RegMem => "MemField",
      Description => "Holds the outgoing PD width + trg slice (3b)",
      Width => "157",
      Position => "156:0", # Excel Formula: =calc_position(F84,E85,TRUE)
    },
  },
  ReorderAlgPdFifo => { #Structure Type: Mem;
    Name => "ReorderAlgPdFifo",
    RegMem => "Mem",
    Address => "300000", # Excel Formula: =calc_mem_address(C84,A84,G86,L86)
    Width => "154", # Excel Formula: =calc_mem_width(E87:E87,M86,F87,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "N/A",
    MemEntries => "16",
    MemWrapper => "Fifo",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,FfBased=Enabled,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "Latency should be the same for PP and NW.",
    MemLogicalWidth => "154",
    ReorderAlgPdFifoData => { #Structure Type: MemField;
      Name => "ReorderAlgPdFifoData",
      RegMem => "MemField",
      Description => "Holds the outgoing PD width",
      Width => "154",
      Position => "153:0", # Excel Formula: =calc_position(F86,E87,TRUE)
    },
  },
  NwExactMatchFBM0 => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 16;
    Name => "NwExactMatchFBM[2]",
    RegMem => "Mem",
    Address => "400000", # Excel Formula: =calc_mem_address(C86,A86,G88,L88)
    Width => "72", # Excel Formula: =calc_mem_width(E89:E89,M88,F89,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "hffffffffffffffff",
    MemEntries => "48",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Must have 2 cc samples",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "64",
    NwExactMatchFBMData0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "NwExactMatchFBMData[n]",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F88,E89,TRUE)
    },
  },
  NwExactMatchFBM1 => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 16;
    Name => "NwExactMatchFBM[2]",
    RegMem => "Mem",
    Address => "500000",
    Width => "72", # Excel Formula: =calc_mem_width(E89:E89,M88,F89,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "hffffffffffffffff",
    MemEntries => "48",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Must have 2 cc samples",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "64",
    NwExactMatchFBMData1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 20;
      Name => "NwExactMatchFBMData[n]",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F88,E89,TRUE)
    },
  },
  NwExactMatchPdMemoryNarrow => { #Structure Type: Mem;
    Name => "NwExactMatchPdMemoryNarrow",
    RegMem => "Mem",
    Address => "600000", # Excel Formula: =calc_mem_address(C88,A88,G90,L90)
    Description => "In FE and FB slice the PD is significantly wider but the reorder requires less PDs - thus the PD memory is split to a wide part  and a narrow part.",
    Width => "115", # Excel Formula: =calc_mem_width(E91:E91,M90,F91,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "N/A",
    MemEntries => "6144",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=25,ReadActivityFactor=25,PortErrPropagate=Disabled",
    Comments => "Should have the exact read/write latency as the wide pd memory",
    MemLogicalWidth => "107",
    NwExactMatchPdMemoryDataNarrow => { #Structure Type: MemField;
      Name => "NwExactMatchPdMemoryDataNarrow",
      RegMem => "MemField",
      Description => "Holds the out PD without the additional TS (additonal TS is relevant for FE and FB slices)  + out slice (2bits)",
      Width => "107",
      Position => "106:0", # Excel Formula: =calc_position(F90,E91,TRUE)
    },
  },
  NwExactMatchPdMemoryWide => { #Structure Type: Mem;
    Name => "NwExactMatchPdMemoryWide",
    RegMem => "Mem",
    Address => "700000", # Excel Formula: =calc_mem_address(C90,A90,G92,L92)
    Description => "In FE and FB the PD is significantly wider but the reorde requires less PDs - thus the PD memory is split to a wide part  and a narrow part.",
    Width => "56", # Excel Formula: =calc_mem_width(E93:E93,M92,F93,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "N/A",
    MemEntries => "512",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=25,ReadActivityFactor=25,PortErrPropagate=Disabled",
    Comments => "Should have the exact read/write latency as the narrow pd memory",
    MemLogicalWidth => "49",
    NwExactMatchPdMemoryDataWide => { #Structure Type: MemField;
      Name => "NwExactMatchPdMemoryDataWide",
      RegMem => "MemField",
      Description => "Holds the delta between the (narrow PD + out slice) and the (out PD + out slice)",
      Width => "49",
      Position => "48:0", # Excel Formula: =calc_position(F92,E93,TRUE)
    },
  },
  NwExactMatch0 => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "NwExactMatch[2]",
    RegMem => "Mem",
    Address => "700000", # Excel Formula: =calc_mem_address(C92,A92,G94,L94)
    Width => "13", # Excel Formula: =calc_mem_width(E95:E95,M94,F95,-1)
    Type => "DocOnly",
    UsedBy => "DSN",
    MemEntries => "6144",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=28,SourceIdWidth=1,NumberOfBanks=2,NumberOfCamEntries=64,QuickInsert=Enabled,BinSize=6,PackArrayToBus=Enabled,VerifierSampleReadBeforeProt=2,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=25,VrfReadActivityFactor=25,ValidSampleReadBeforeProt=2,ValidCpuReadAccess=Enabled,ValidCpuWriteAccess=Enabled,VldWriteActivityFactor=50,VldReadActivityFactor=50",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "13",
    NwExactMatchData0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "NwExactMatchData[n]",
      RegMem => "MemField",
      Description => "Payload Width - Pointer to the PD memory + 1 bit for EOS in SLB mode",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F94,E95,TRUE)
    },
  },
  NwExactMatch1 => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "NwExactMatch[2]",
    RegMem => "Mem",
    Address => "800000",
    Width => "13", # Excel Formula: =calc_mem_width(E95:E95,M94,F95,-1)
    Type => "DocOnly",
    UsedBy => "DSN",
    MemEntries => "6144",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=28,SourceIdWidth=1,NumberOfBanks=2,NumberOfCamEntries=64,QuickInsert=Enabled,BinSize=6,PackArrayToBus=Enabled,VerifierSampleReadBeforeProt=2,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=25,VrfReadActivityFactor=25,ValidSampleReadBeforeProt=2,ValidCpuReadAccess=Enabled,ValidCpuWriteAccess=Enabled,VldWriteActivityFactor=50,VldReadActivityFactor=50",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "13",
    NwExactMatchData1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "NwExactMatchData[n]",
      RegMem => "MemField",
      Description => "Payload Width - Pointer to the PD memory + 1 bit for EOS in SLB mode",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F94,E95,TRUE)
    },
  },
  EventChain2ConnectionTable => { #Structure Type: Mem;
    Name => "EventChain2ConnectionTable",
    RegMem => "Mem",
    Address => "800000", # Excel Formula: =calc_mem_address(C92,A92,G96,L96)
    Description => "Holds 2 entries in line to reduce ECC bits",
    Width => "24", # Excel Formula: =calc_mem_width(E97:E106,M96,F106,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "2048",
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read latency should be identical to connection table latency",
    MemLogicalWidth => "18",
    Entry0CurrentSsn => { #Structure Type: MemField;
      Name => "Entry0CurrentSsn",
      RegMem => "MemField",
      Description => "The next/currently working SSN",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F96,E97,TRUE)
      DefaultValue => "h0",
    },
    Entry0CloseSsnWhenDone => { #Structure Type: MemField;
      Name => "Entry0CloseSsnWhenDone",
      RegMem => "MemField",
      Description => "Indicates that a SSN is expected to be done by now thus if a packet is not found, it is assumed that it is EOS loss",
      Width => "4",
      Position => "5:2", # Excel Formula: =calc_position(F97,E98)
      DefaultValue => "h0",
    },
    Entry0CurrentSsnOwner => { #Structure Type: MemField;
      Name => "Entry0CurrentSsnOwner",
      RegMem => "MemField",
      Description => "This reorder block is the owner of the current SSN and it can transmit packets",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F98,E99)
      DefaultValue => "h0",
    },
    Entry0ReUse => { #Structure Type: MemField;
      Name => "Entry0ReUse",
      RegMem => "MemField",
      Description => "Indicates that the connection is expected to be reused thus the current SSN is irrelevant and all SSNs are acceptable",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F99,E100)
      DefaultValue => "h1",
    },
    Entry0Error => { #Structure Type: MemField;
      Name => "Entry0Error",
      RegMem => "MemField",
      Description => "Indicates that the connection is in error state thus no packets should be stored and in time it will be reset and set in reuse state.",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F100,E101)
      DefaultValue => "h0",
    },
    Entry1CurrentSsn => { #Structure Type: MemField;
      Name => "Entry1CurrentSsn",
      RegMem => "MemField",
      Description => "The next/currently working SSN",
      Width => "2",
      Position => "10:9", # Excel Formula: =calc_position(F101,E102)
      DefaultValue => "h0",
    },
    Entry1CloseSsnWhenDone => { #Structure Type: MemField;
      Name => "Entry1CloseSsnWhenDone",
      RegMem => "MemField",
      Description => "Indicates that a SSN is expected to be done by now thus if a packet is not found, it is assumed that it is EOS loss",
      Width => "4",
      Position => "14:11", # Excel Formula: =calc_position(F102,E103)
      DefaultValue => "h0",
    },
    Entry1CurrentSsnOwner => { #Structure Type: MemField;
      Name => "Entry1CurrentSsnOwner",
      RegMem => "MemField",
      Description => "This reorder block is the owner of the current SSN and it can transmit packets",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F103,E104)
      DefaultValue => "h0",
    },
    Entry1ReUse => { #Structure Type: MemField;
      Name => "Entry1ReUse",
      RegMem => "MemField",
      Description => "Indicates that the connection is expected to be reused thus the current SSN is irrelevant and all SSNs are acceptable",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F104,E105)
      DefaultValue => "h1",
    },
    Entry1Error => { #Structure Type: MemField;
      Name => "Entry1Error",
      RegMem => "MemField",
      Description => "Indicates that the connection is in error state thus no packets should be stored and in time it will be reset and set in reuse state.",
      Width => "1",
      Position => "17", # Excel Formula: =calc_position(F105,E106)
      DefaultValue => "h0",
    },
  },
  Connection2EventChainTable => { #Structure Type: Mem;
    Name => "Connection2EventChainTable",
    RegMem => "Mem",
    Address => "900000", # Excel Formula: =calc_mem_address(C96,A96,G107,L107)
    Width => "8", # Excel Formula: =calc_mem_width(E108:E108,M107,F108,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "4096",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    MemLogicalWidth => "4",
    StoredSsn => { #Structure Type: MemField;
      Name => "StoredSsn",
      RegMem => "MemField",
      Description => "A bit per SSN that indicates that the block holds packets of SSN = X (or in the process of transmitting packets of SSN X).",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F107,E108,TRUE)
      DefaultValue => "h0",
    },
  },
  SkewMeasurementTable => { #Structure Type: Mem;
    Name => "SkewMeasurementTable",
    RegMem => "Mem",
    Address => "A00000", # Excel Formula: =calc_mem_address(C107,A107,G109,L109)
    Width => "40", # Excel Formula: =calc_mem_width(E110:E110,M109,F110,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    DefaultValue => "h20000000",
    MemEntries => "8",
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    MemLogicalWidth => "40",
    SkewMeasurementTableEntry => { #Structure Type: MemField;
      Name => "SkewMeasurementTableEntry",
      RegMem => "MemField",
      Description => "Skew measurement table.
Note that skew measurement is valid only in SN PLB (not valid in SLB).",
      Width => "40",
      Position => "39:0", # Excel Formula: =calc_position(F109,E110,TRUE)
    },
  },
  ConnectionProfileTable => { #Structure Type: Mem;
    Name => "ConnectionProfileTable",
    RegMem => "Mem",
    Address => "B00000", # Excel Formula: =calc_mem_address(C109,A109,G111,L111)
    Width => "3", # Excel Formula: =calc_mem_width(E112:E112,M111,F112,-1)
    Type => "Config",
    UsedBy => "DSN",
    DefaultValue => "N/A",
    MemEntries => "160",
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,WriteActivityFactor=0,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Should have the exact read/write latency as the connection table",
    MemLogicalWidth => "3",
    ProfileNum => { #Structure Type: MemField;
      Name => "ProfileNum",
      RegMem => "MemField",
      Description => "Holds a profile per connection that will be associated with a PD drop threshold.
Relevant only to PP connections.",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F111,E112,TRUE)
    },
  },
  ProfileConfigTable => { #Structure Type: Mem;
    Name => "ProfileConfigTable",
    RegMem => "Mem",
    Address => "C00000", # Excel Formula: =calc_mem_address(C111,A111,G113,L113)
    Width => "11", # Excel Formula: =calc_mem_width(E114:E114,M113,F114,-1)
    Type => "Config",
    UsedBy => "DSN",
    DefaultValue => "N/A",
    MemEntries => "8",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    MemLogicalWidth => "11",
    ConnectionPdThreshold => { #Structure Type: MemField;
      Name => "ConnectionPdThreshold",
      RegMem => "MemField",
      Description => "Defines the max number of PDs that the connection may store before the expected packet is assumed to be lost.
Should be configured according to the RXPP skew and the connection rate.",
      Width => "11",
      Position => "10:0", # Excel Formula: =calc_position(F113,E114,TRUE)
    },
  },
  NwExactMatchVerifier0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 21; Skip Register;
    Name => "NwExactMatchVerifier[4]",
    RegMem => "Mem",
    Address => "D00000", # Excel Formula: =calc_mem_address(C113,A113,G115,L115)
    Width => "234", # Excel Formula: =calc_mem_width(E116:E116,M115,F116,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1P WriteMask",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=25,ReadActivityFactor=25,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "234",
    NwExactMatchVerifier0Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 21;
      Name => "NwExactMatchVerifier[n]Data",
      RegMem => "MemField",
      Width => "234",
      Position => "233:0", # Excel Formula: =calc_position(F115,E116,TRUE)
    },
  },
  NwExactMatchVerifier1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 21; Skip Register;
    Name => "NwExactMatchVerifier[4]",
    RegMem => "Mem",
    Address => "E00000",
    Width => "234", # Excel Formula: =calc_mem_width(E116:E116,M115,F116,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1P WriteMask",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=25,ReadActivityFactor=25,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "234",
    NwExactMatchVerifier1Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 21;
      Name => "NwExactMatchVerifier[n]Data",
      RegMem => "MemField",
      Width => "234",
      Position => "233:0", # Excel Formula: =calc_position(F115,E116,TRUE)
    },
  },
  NwExactMatchVerifier2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 21; Skip Register;
    Name => "NwExactMatchVerifier[4]",
    RegMem => "Mem",
    Address => "F00000",
    Width => "234", # Excel Formula: =calc_mem_width(E116:E116,M115,F116,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1P WriteMask",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=25,ReadActivityFactor=25,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "234",
    NwExactMatchVerifier2Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 21;
      Name => "NwExactMatchVerifier[n]Data",
      RegMem => "MemField",
      Width => "234",
      Position => "233:0", # Excel Formula: =calc_position(F115,E116,TRUE)
    },
  },
  NwExactMatchVerifier3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 21; Skip Register;
    Name => "NwExactMatchVerifier[4]",
    RegMem => "Mem",
    Address => "1000000",
    Width => "234", # Excel Formula: =calc_mem_width(E116:E116,M115,F116,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1P WriteMask",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=25,ReadActivityFactor=25,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "234",
    NwExactMatchVerifier3Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 21;
      Name => "NwExactMatchVerifier[n]Data",
      RegMem => "MemField",
      Width => "234",
      Position => "233:0", # Excel Formula: =calc_position(F115,E116,TRUE)
    },
  },
  NwExactMatchValid0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 18; Skip Register;
    Name => "NwExactMatchValid[4]",
    RegMem => "Mem",
    Address => "1100000", # Excel Formula: =calc_mem_address(C115,A115,G117,L117)
    Width => "6", # Excel Formula: =calc_mem_width(E118:E118,M117,F118,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1R1W WriteMask",
    MemProtect => "None",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "6",
    NwExactMatchValid0Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 18;
      Name => "NwExactMatchValid[n]Data",
      RegMem => "MemField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F117,E118,TRUE)
    },
  },
  NwExactMatchValid1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 18; Skip Register;
    Name => "NwExactMatchValid[4]",
    RegMem => "Mem",
    Address => "1200000",
    Width => "6", # Excel Formula: =calc_mem_width(E118:E118,M117,F118,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1R1W WriteMask",
    MemProtect => "None",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "6",
    NwExactMatchValid1Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 18;
      Name => "NwExactMatchValid[n]Data",
      RegMem => "MemField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F117,E118,TRUE)
    },
  },
  NwExactMatchValid2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 18; Skip Register;
    Name => "NwExactMatchValid[4]",
    RegMem => "Mem",
    Address => "1300000",
    Width => "6", # Excel Formula: =calc_mem_width(E118:E118,M117,F118,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1R1W WriteMask",
    MemProtect => "None",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "6",
    NwExactMatchValid2Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 18;
      Name => "NwExactMatchValid[n]Data",
      RegMem => "MemField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F117,E118,TRUE)
    },
  },
  NwExactMatchValid3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 18; Skip Register;
    Name => "NwExactMatchValid[4]",
    RegMem => "Mem",
    Address => "1400000",
    Width => "6", # Excel Formula: =calc_mem_width(E118:E118,M117,F118,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "512",
    MemWrapper => "1R1W WriteMask",
    MemProtect => "None",
    AdditionalInfo => "PackArrayToBus=Enabled,SampleReadBeforeProt=2,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "6",
    NwExactMatchValid3Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 18;
      Name => "NwExactMatchValid[n]Data",
      RegMem => "MemField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F117,E118,TRUE)
    },
  },
  NwExactMatchPerBankReg0 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 23; Skip Register;
    Name => "NwExactMatchPerBankReg[4]",
    RegMem => "Reg",
    Address => "122", # Excel Formula: =calc_reg_address(C77,A77,G77)
    Width => "58", # Excel Formula: =calc_reg_width(E120:E122,F122)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    NwExactMatchActiveBanks0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "NwExactMatchActiveBanks[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F119,E120,TRUE)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "d1",
    },
    NwExactMatchHashKey0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "NwExactMatchHashKey[n]",
      RegMem => "RegField",
      Width => "56",
      Position => "56:1", # Excel Formula: =calc_position(F120,E121)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchUsePrimitiveCrc0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 28;
      Name => "NwExactMatchUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "57", # Excel Formula: =calc_position(F121,E122)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
  },
  NwExactMatchPerBankReg1 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 23; Skip Register;
    Name => "NwExactMatchPerBankReg[4]",
    RegMem => "Reg",
    Address => "123",
    Width => "58", # Excel Formula: =calc_reg_width(E120:E122,F122)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    NwExactMatchActiveBanks1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "NwExactMatchActiveBanks[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F119,E120,TRUE)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "d1",
    },
    NwExactMatchHashKey1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 20;
      Name => "NwExactMatchHashKey[n]",
      RegMem => "RegField",
      Width => "56",
      Position => "56:1", # Excel Formula: =calc_position(F120,E121)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchUsePrimitiveCrc1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 28;
      Name => "NwExactMatchUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "57", # Excel Formula: =calc_position(F121,E122)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
  },
  NwExactMatchPerBankReg2 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 23; Skip Register;
    Name => "NwExactMatchPerBankReg[4]",
    RegMem => "Reg",
    Address => "124",
    Width => "58", # Excel Formula: =calc_reg_width(E120:E122,F122)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    NwExactMatchActiveBanks2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "NwExactMatchActiveBanks[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F119,E120,TRUE)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "d1",
    },
    NwExactMatchHashKey2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 20;
      Name => "NwExactMatchHashKey[n]",
      RegMem => "RegField",
      Width => "56",
      Position => "56:1", # Excel Formula: =calc_position(F120,E121)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchUsePrimitiveCrc2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 28;
      Name => "NwExactMatchUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "57", # Excel Formula: =calc_position(F121,E122)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
  },
  NwExactMatchPerBankReg3 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 23; Skip Register;
    Name => "NwExactMatchPerBankReg[4]",
    RegMem => "Reg",
    Address => "125",
    Width => "58", # Excel Formula: =calc_reg_width(E120:E122,F122)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    NwExactMatchActiveBanks3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "NwExactMatchActiveBanks[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F119,E120,TRUE)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "d1",
    },
    NwExactMatchHashKey3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 20;
      Name => "NwExactMatchHashKey[n]",
      RegMem => "RegField",
      Width => "56",
      Position => "56:1", # Excel Formula: =calc_position(F120,E121)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchUsePrimitiveCrc3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 28;
      Name => "NwExactMatchUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "57", # Excel Formula: =calc_position(F121,E122)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
  },
  NwExactMatchPerEmReg0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 21; Skip Register;
    Name => "NwExactMatchPerEmReg[2]",
    RegMem => "Reg",
    Address => "126", # Excel Formula: =calc_reg_address(C119,A119,G119)
    Width => "33", # Excel Formula: =calc_reg_width(E124:E126,F126)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "2",
    ArrayIndex => "0",
    NwExactMatchKeyWidth0 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 21;
      Name => "NwExactMatchKeyWidth[n]",
      RegMem => "RegField",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F123,E124,TRUE)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchAutoBubbleReq0 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "NwExactMatchAutoBubbleReq[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F124,E125)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchBubbleReqThreshold0 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "NwExactMatchBubbleReqThreshold[n]",
      RegMem => "RegField",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F125,E126)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
  },
  NwExactMatchPerEmReg1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 21; Skip Register;
    Name => "NwExactMatchPerEmReg[2]",
    RegMem => "Reg",
    Address => "127",
    Width => "33", # Excel Formula: =calc_reg_width(E124:E126,F126)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "2",
    ArrayIndex => "1",
    NwExactMatchKeyWidth1 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 21;
      Name => "NwExactMatchKeyWidth[n]",
      RegMem => "RegField",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F123,E124,TRUE)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchAutoBubbleReq1 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "NwExactMatchAutoBubbleReq[n]",
      RegMem => "RegField",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F124,E125)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
    NwExactMatchBubbleReqThreshold1 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "NwExactMatchBubbleReqThreshold[n]",
      RegMem => "RegField",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F125,E126)
      Type => "Config",
      UsedBy => "NwExactMatch",
      DefaultValue => "h0",
    },
  },
  NwExactMatchCamWmMaxReg0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 24; Skip Register;
    Name => "NwExactMatchCamWmMaxReg[2]",
    RegMem => "Reg",
    Address => "128", # Excel Formula: =calc_reg_address(C123,A123,G123)
    Width => "8", # Excel Formula: =calc_reg_width(E128:E128,F128)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "2",
    ArrayIndex => "0",
    NwExactMatchCamWmMax0 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 21;
      Name => "NwExactMatchCamWmMax[n]",
      RegMem => "RegField",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F127,E128,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwExactMatchCamWmMaxReg1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 24; Skip Register;
    Name => "NwExactMatchCamWmMaxReg[2]",
    RegMem => "Reg",
    Address => "129",
    Width => "8", # Excel Formula: =calc_reg_width(E128:E128,F128)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "2",
    ArrayIndex => "1",
    NwExactMatchCamWmMax1 => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 21;
      Name => "NwExactMatchCamWmMax[n]",
      RegMem => "RegField",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F127,E128,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwExactMatchBankWriteCntrReg0 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 29; Skip Register;
    Name => "NwExactMatchBankWriteCntrReg[4]",
    RegMem => "Reg",
    Address => "12A", # Excel Formula: =calc_reg_address(C127,A127,G127)
    Width => "64", # Excel Formula: =calc_reg_width(E130:E130,F130)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    NwExactMatchBankWriteCntr0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "NwExactMatchBankWriteCntr[n]",
      RegMem => "RegField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F129,E130,TRUE)
      Type => "Counter",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwExactMatchBankWriteCntrReg1 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 29; Skip Register;
    Name => "NwExactMatchBankWriteCntrReg[4]",
    RegMem => "Reg",
    Address => "12B",
    Width => "64", # Excel Formula: =calc_reg_width(E130:E130,F130)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    NwExactMatchBankWriteCntr1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "NwExactMatchBankWriteCntr[n]",
      RegMem => "RegField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F129,E130,TRUE)
      Type => "Counter",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwExactMatchBankWriteCntrReg2 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 29; Skip Register;
    Name => "NwExactMatchBankWriteCntrReg[4]",
    RegMem => "Reg",
    Address => "12C",
    Width => "64", # Excel Formula: =calc_reg_width(E130:E130,F130)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    NwExactMatchBankWriteCntr2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 26;
      Name => "NwExactMatchBankWriteCntr[n]",
      RegMem => "RegField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F129,E130,TRUE)
      Type => "Counter",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwExactMatchBankWriteCntrReg3 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 29; Skip Register;
    Name => "NwExactMatchBankWriteCntrReg[4]",
    RegMem => "Reg",
    Address => "12D",
    Width => "64", # Excel Formula: =calc_reg_width(E130:E130,F130)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    NwExactMatchBankWriteCntr3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 26;
      Name => "NwExactMatchBankWriteCntr[n]",
      RegMem => "RegField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F129,E130,TRUE)
      Type => "Counter",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  NwExactMatchCam0 => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 16; Skip Register;
    Name => "NwExactMatchCam[2]",
    RegMem => "Mem",
    Address => "1500000", # Excel Formula: =calc_mem_address(C117,A117,G131,L131)
    Width => "42", # Excel Formula: =calc_mem_width(E132:E134,"None",F134,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "64",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=13,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled",
    Comments => "EM Skip Reg",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "42",
    NwExactMatchCam0_key => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 16;
      Name => "NwExactMatchCam[n]_key",
      RegMem => "MemField",
      Width => "28",
      Position => "27:0", # Excel Formula: =calc_position(F131,E132,TRUE)
    },
    NwExactMatchCam0_payload => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 16;
      Name => "NwExactMatchCam[n]_payload",
      RegMem => "MemField",
      Width => "13",
      Position => "40:28", # Excel Formula: =calc_position(F132,E133)
    },
    NwExactMatchCam0_valid => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 16;
      Name => "NwExactMatchCam[n]_valid",
      RegMem => "MemField",
      Width => "1",
      Position => "41", # Excel Formula: =calc_position(F133,E134)
    },
  },
  NwExactMatchCam1 => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 16; Skip Register;
    Name => "NwExactMatchCam[2]",
    RegMem => "Mem",
    Address => "1600000",
    Width => "42", # Excel Formula: =calc_mem_width(E132:E134,"None",F134,-1)
    Type => "Dynamic",
    UsedBy => "NwExactMatch",
    MemEntries => "64",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=13,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled",
    Comments => "EM Skip Reg",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "42",
    NwExactMatchCam1_key => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 16;
      Name => "NwExactMatchCam[n]_key",
      RegMem => "MemField",
      Width => "28",
      Position => "27:0", # Excel Formula: =calc_position(F131,E132,TRUE)
    },
    NwExactMatchCam1_payload => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 16;
      Name => "NwExactMatchCam[n]_payload",
      RegMem => "MemField",
      Width => "13",
      Position => "40:28", # Excel Formula: =calc_position(F132,E133)
    },
    NwExactMatchCam1_valid => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 16;
      Name => "NwExactMatchCam[n]_valid",
      RegMem => "MemField",
      Width => "1",
      Position => "41", # Excel Formula: =calc_position(F133,E134)
    },
  },
};
